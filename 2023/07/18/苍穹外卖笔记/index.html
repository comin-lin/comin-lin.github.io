

  <!DOCTYPE html>
  <html lang="zh-CN">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="renderer" content="webkit">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta name="description" content= >
  <meta name="keywords" content=hexo,theme,MiHoYo >

  <head>
    <title>
      苍穹外卖笔记 [ comin-lin&#39;s blog ]
    </title>
  <meta name="generator" content="Hexo 6.3.0"></head>

  <body>

    <link rel="stylesheet" href="/css/header.css">
<div class="header">
  <div class="logo">
    <span class="pull-left">
      <a id="site-name" href="/">
        comin-lin&#39;s blog
      </a>
    </span>
  </div>
  <ul class="nav-list">
    
      <li>
        <a href="/">
          首页
        </a>
      </li>
      
  </ul>
</div>

      <!--<link rel="stylesheet" href="/css/top-header.css">
<div id="top-bar" class="fixed">

  <a class="goto-top" href="#"></a>
  <ul class="bar-list bar-list-1">
    
      <li>
        <p>
          <a href="/">
            <text class="bar-text bar-p1">
              首页
            </text>
            <text class="bar-text bar-p2"></text>
          </a>
          <text class="bar-p3">/</text>
        </p>
      </li>
      
  </ul>
</div>-->

        <div id="content-outer">
          <div class="content-inner">
            <link rel="stylesheet" href="/css/post.css">
<div class="posts">
  <a href="/index.html"><i class="fa fa-home
replay-btn" aria-hidden="true"></i></a>
  <div class="post-title">
    <p>
      苍穹外卖笔记
    </p>
    <hr>
  </div>
  <div class="post-content">
    <h1 id="p1"><a href="#p1" class="headerlink" title="p1"></a>p1</h1><ul>
<li>项目效果展示</li>
<li>2023-07-18 17:44:13</li>
</ul>
<h1 id="p2"><a href="#p2" class="headerlink" title="p2"></a>p2</h1><ul>
<li>软件开发流程介绍</li>
<li>需求分析阶段：需求规格说明书、产品原型（使用静态网页展示）</li>
<li>设计阶段：UI设计、数据库设计、接口设计</li>
<li>编码阶段：项目代码、单元测试</li>
<li>测试阶段：测试用例、测试报告</li>
<li>上线运维：软件环境安装、配置</li>
<li>软件环境：开发环境、测试环境、生产环境</li>
<li>2023-07-18 17:52:05</li>
</ul>
<h1 id="p3"><a href="#p3" class="headerlink" title="p3"></a>p3</h1><ul>
<li>项目介绍</li>
<li>前端分为管理端（vue实现）和用户端（微信小程序）</li>
<li>技术选型<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">用户层 node.js vue.js elementUI 微信小程序 apache-echarts</span><br><span class="line">网关层 nginx</span><br><span class="line">应用层 SpringBoot SpringMVC SpringTask httpclient SpringCache</span><br><span class="line">	   JWT 阿里云OSS Swagger POI WebSocket</span><br><span class="line">数据层 Mysql Redis mybatis pagehelper spring-data-redis	 </span><br><span class="line">工具   Git maven Junit postman  </span><br></pre></td></tr></table></figure></li>
<li>2023-07-18 18:03:27</li>
</ul>
<h1 id="p4"><a href="#p4" class="headerlink" title="p4"></a>p4</h1><ul>
<li>前端环境搭建</li>
<li>前端代码已打包部署到nginx中 运行nginx.exe即可启动前端项目，访问端口号为80</li>
<li>2023-07-18 18:09:09</li>
</ul>
<h1 id="p5"><a href="#p5" class="headerlink" title="p5"></a>p5</h1><ul>
<li>后端环境搭建</li>
<li>后端工程使用maven进行分模块开发</li>
<li>模块信息<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sky-take-out  maven父工程，统一管理依赖版本，聚合其他子模块</span><br><span class="line">sky-common 子模块，存放公共类（工具类、常量类、异常类）</span><br><span class="line">sky-pojo 子模块，存放实体类</span><br><span class="line">sky-server 子模块，后端服务，存放配置文件、Controller、Service、Mapper等</span><br></pre></td></tr></table></figure></li>
<li>2023-07-18 18:31:17</li>
</ul>
<h1 id="p6"><a href="#p6" class="headerlink" title="p6"></a>p6</h1><ul>
<li>使用git进行版本控制</li>
<li>将项目初始代码推送到git仓库</li>
<li>2023-07-18 18:32:29</li>
</ul>
<h1 id="p7"><a href="#p7" class="headerlink" title="p7"></a>p7</h1><ul>
<li>数据库环境搭建</li>
<li>建表语句已提供，直接执行sky.sql即可</li>
<li>2023-07-18 18:33:57</li>
</ul>
<h1 id="p8"><a href="#p8" class="headerlink" title="p8"></a>p8</h1><ul>
<li>前后端联调测试</li>
<li>外卖管理后台账号admin 密码123456 </li>
<li>修改数据库的配置后，启动springboot主程序类</li>
<li>测试外卖管理后台的登录</li>
<li>2023-07-18 20:56:04</li>
</ul>
<h1 id="p9"><a href="#p9" class="headerlink" title="p9"></a>p9</h1><ul>
<li>前端发送的请求端口为80，而后端的端口为8080，后端能接收到前端的请求，是因为nginx转发了请求</li>
<li>nginx反向代理的好处：提高访问速度、进行负载均衡、保证后端服务的安全（不暴露后端服务器）</li>
<li>2023-07-20 11:40:16</li>
</ul>
<h1 id="p10-p11"><a href="#p10-p11" class="headerlink" title="p10-p11"></a>p10-p11</h1><ul>
<li>配置nginx反向代理</li>
<li>listen： 监听端口号 </li>
<li>location：监听到的请求</li>
<li>proxy_pass指令： 转发的路径</li>
<li>配置nginx负载均衡</li>
<li>upstream webservers：指定多个后端服务器地址</li>
<li>server 192.168.100.128:8080：指定一个后端服务器地址</li>
<li>2023-07-20 11:43:32</li>
</ul>
<h1 id="p12"><a href="#p12" class="headerlink" title="p12"></a>p12</h1><ul>
<li>完善登录功能</li>
<li>不使用明文来存储密码，将密码加密后存储，使用MD5加密</li>
<li>2023-07-20 11:50:12</li>
</ul>
<h1 id="p13"><a href="#p13" class="headerlink" title="p13"></a>p13</h1><ul>
<li>导入接口文档</li>
<li>把接口.json文件导入到YApi平台</li>
<li><a target="_blank" rel="noopener" href="https://yapi.pro/">https://yapi.pro/</a></li>
<li>账号shengshui 密码shengshui </li>
<li>2023-07-20 11:54:59</li>
</ul>
<h1 id="p14"><a href="#p14" class="headerlink" title="p14"></a>p14</h1><ul>
<li>根据接口文档开发后端接口</li>
<li>使用Postman或者Swagger进行接口测试</li>
<li>knife4j是为Java MVC框架集成Swagger生成Api文档的增强解决方案</li>
<li>1.导入knife4j的maven坐标</li>
<li>2.在配置类中加入knife4j相关配置</li>
<li>3.设置静态资源映射，否则接口文档页面无法访问</li>
<li>启动项目后，访问localhost:8080&#x2F;doc.html查看接口文档</li>
<li>2023-07-20 12:02:08</li>
</ul>
<h1 id="pp15"><a href="#pp15" class="headerlink" title="pp15"></a>pp15</h1><ul>
<li>Swagger常用注解</li>
<li>@Api 用在类上，对类进行说明</li>
<li>@ApiModel 用在类上，例如entity、DTO&#x2F;VO</li>
<li>@ApiModelProperty 用在属性上，描述属性信息</li>
<li>@ApiOperation 用在方法上，例如Controller的方法，说明方法用途和作用</li>
<li>2023-07-20 12:04:52</li>
</ul>
<h1 id="p16"><a href="#p16" class="headerlink" title="p16"></a>p16</h1><ul>
<li>新增员工接口的需求分析</li>
<li>2023-07-21 14:43:50</li>
</ul>
<p>#p17</p>
<ul>
<li>使用DTO来封装数据</li>
<li>2023-07-21 14:58:18</li>
</ul>
<h1 id="p18"><a href="#p18" class="headerlink" title="p18"></a>p18</h1><ul>
<li>使用接口文档测试接口</li>
<li>通过登录接口获取JWT令牌，在接口文档的全局参数设置中添加token，以测试新增员工接口</li>
<li>2023-07-21 15:03:14</li>
</ul>
<h1 id="p19-p20"><a href="#p19-p20" class="headerlink" title="p19-p20"></a>p19-p20</h1><ul>
<li>完善新增员工接口</li>
<li>通过新增自定义异常，给前端返回异常的提示信息</li>
<li>使用ThreadLocal动态获取当前登录的用户id，为新增员工时添加操作者id</li>
<li>2023-07-21 15:39:39</li>
</ul>
<h1 id="p21-p24"><a href="#p21-p24" class="headerlink" title="p21-p24"></a>p21-p24</h1><ul>
<li>员工分页查询</li>
<li>使用分页插件完成</li>
<li>在员工实体类的属性上添加JsonFormat注解，让日期类型转化为指定格式</li>
<li>2023-07-21 16:24:25</li>
</ul>
<h1 id="p25-p26"><a href="#p25-p26" class="headerlink" title="p25-p26"></a>p25-p26</h1><ul>
<li>启用&#x2F;禁用员工账号</li>
<li>2023-07-22 18:41:25</li>
</ul>
<h1 id="p27-p29"><a href="#p27-p29" class="headerlink" title="p27-p29"></a>p27-p29</h1><ul>
<li>编辑员工</li>
<li>1.根据id查询员工信息以回显到前端 2.更新员工信息</li>
<li>2023-07-22 19:50:52</li>
</ul>
<h1 id="p30"><a href="#p30" class="headerlink" title="p30"></a>p30</h1><ul>
<li>导入分类管理模块功能源码</li>
<li>2023-07-22 20:05:52</li>
</ul>
<h1 id="p31-p34"><a href="#p31-p34" class="headerlink" title="p31-p34"></a>p31-p34</h1><ul>
<li>公共字段自动填充</li>
<li>公共字段使用java代码来填充，会造成代码冗余</li>
<li>解决方案：自定义注解AutoFill，自定义切面类统一拦截</li>
<li>使用技术：枚举、注解、AOP、反射</li>
<li>2023-07-23 13:40:26</li>
</ul>
<h1 id="p35-p39"><a href="#p35-p39" class="headerlink" title="p35-p39"></a>p35-p39</h1><ul>
<li>新增菜品功能</li>
<li>涉及接口：根据类型查询分类、文件上传、新增菜品</li>
<li>实现文件上传接口时，在JWT校验拦截器中放行文件下载请求<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//判断是否为文件下载接口，如果是直接放行</span><br><span class="line">        HandlerMethod handlerMethod = (HandlerMethod) handler;</span><br><span class="line">        if (handlerMethod.hasMethodAnnotation(GetMapping.class)) &#123;</span><br><span class="line">            GetMapping getMapping = handlerMethod.getMethodAnnotation(GetMapping.class);</span><br><span class="line">            if (getMapping != null &amp;&amp; Arrays.asList(getMapping.value()).contains(&quot;/download/&#123;name&#125;&quot;)) &#123;</span><br><span class="line">                // 当前请求为下载文件接口，直接放行</span><br><span class="line">                log.info(&quot;放行文件下载接口&quot;);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
<li>2023-07-24 17:06:10</li>
</ul>
<h1 id="p40-p41"><a href="#p40-p41" class="headerlink" title="p40-p41"></a>p40-p41</h1><ul>
<li>菜品分页查询</li>
<li>2023-07-24 17:19:56</li>
</ul>
<h1 id="p42-p48"><a href="#p42-p48" class="headerlink" title="p42-p48"></a>p42-p48</h1><ul>
<li>删除菜品、修改菜品</li>
<li>起售中的菜品、被套餐关联的菜品不能删除</li>
<li>菜品成功删除后，关联的口味数据也需要删除 </li>
<li>2023-07-27 13:41:59</li>
</ul>
<h1 id="p49-65"><a href="#p49-65" class="headerlink" title="p49-65"></a>p49-65</h1><ul>
<li>使用Redis来设置店铺营业状态</li>
<li>Redis常用数据类型<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">这些数据类型都是相对于value而言的，key一直是字符串</span><br><span class="line">字符串 string</span><br><span class="line">哈希 hash</span><br><span class="line">列表 list</span><br><span class="line">集合 set</span><br><span class="line">有序集合 sorted set/zset</span><br></pre></td></tr></table></figure></li>
<li>使用Spring Data Redis框架实现在java中操作redis</li>
<li>redis连接过程（自己的电脑为例）<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">虚拟机ip地址：http://192.168.169.128/</span><br><span class="line">打开虚拟机 打开终端</span><br><span class="line">关闭防火墙systemctl stop firewalld.service</span><br><span class="line">.cd /usr/local/redis/bin/ 进入redis安装目录</span><br><span class="line">./redis-server在前台启动redis</span><br><span class="line">再打开一个终端</span><br><span class="line">cd /usr/local/redis/bin/ 进入redis安装目录</span><br><span class="line">./redis-cli连接redis</span><br><span class="line">ping 出现pong说明连接成功</span><br><span class="line">config set protected-mode no 关闭redis的保护模式</span><br><span class="line">接下来可以在java中使用Spring Data Redis连接到redis进行操作了</span><br></pre></td></tr></table></figure></li>
<li>相关接口：设置营业状态 管理端查询营业状态 用户端查询营业状态</li>
<li>在controller下创建user软件包，复制admin软件包下的ShopController，由于两个Controller名字一样会冲突，在@RestController中指定bean的名字避免冲突</li>
<li>@RestController(“userShopController”) @RestController(“adminShopController”)</li>
<li>2023-07-30 15:21:29</li>
</ul>
<h1 id="p66-p69"><a href="#p66-p69" class="headerlink" title="p66-p69"></a>p66-p69</h1><ul>
<li>HttpClient：是一个开源的、用于发送 HTTP 请求的 Java 库</li>
<li>使用该库可以在java中发送http请求，以调用一些第三方的工具或接口。在本项目中用来实现向微信登录接口发送请求，得到登录用户的openid（微信用户的唯一标识）</li>
<li>2023-07-30 17:15:02</li>
</ul>
<h1 id="p70-p85"><a href="#p70-p85" class="headerlink" title="p70-p85"></a>p70-p85</h1><ul>
<li>实现用户端的微信登录和商品浏览</li>
<li>小程序目录结构<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">小程序文件</span><br><span class="line">app.js  必需 小程序逻辑文件</span><br><span class="line">app.json 必需 小程序公共配置</span><br><span class="line">app.wxss 非必需 小程序公共样式表</span><br><span class="line"></span><br><span class="line">页面文件</span><br><span class="line">js 必需 页面逻辑</span><br><span class="line">wxml 必需 页面结构</span><br><span class="line">json 非必需 页面配置</span><br><span class="line">wsxx 非必需 页面样式表</span><br></pre></td></tr></table></figure></li>
<li>导入已写好的微信小程序代码</li>
<li>使用官方提供的登录api实现微信登录，小程序会向生成并向后端发送微信登录授权码，后端拿到</li>
<li>2023-07-31 14:13:35</li>
</ul>
<h1 id="p86-p104"><a href="#p86-p104" class="headerlink" title="p86-p104"></a>p86-p104</h1><ul>
<li>缓存商品、购物车</li>
<li>使用Spring Cache框架：纯注解使用缓存</li>
<li>2023-08-01 12:55:31</li>
</ul>
<h1 id="p105-p122"><a href="#p105-p122" class="headerlink" title="p105-p122"></a>p105-p122</h1><ul>
<li>用户下单、订单支付</li>
</ul>
<h1 id="p123"><a href="#p123" class="headerlink" title="p123"></a>p123</h1><ul>
<li>SpringTask实现定时任务</li>
<li>WebSocket实现订单提醒</li>
</ul>
<h3 id="SpringTask"><a href="#SpringTask" class="headerlink" title="SpringTask"></a>SpringTask</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">使用cron表达式（本质是一个字符串）指定任务触发的时间</span><br><span class="line">构成规则：分为6或7个域，由空格分隔开，每个域分别代表秒、分钟、小时、日、月、周、年（可选）</span><br><span class="line"> </span><br><span class="line"> SpringTask坐标：spring-context</span><br><span class="line"> </span><br><span class="line"> 使用方法</span><br><span class="line"> 1.在启动类上添加@EnableScheduling</span><br><span class="line"> 2.在需要定时触发的方法上添加@Scheduled(cron = cron表达式)</span><br><span class="line"> 3. 注意该类是需要被Spring容器所管理的，否则@Scheduled 注解不生效</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">WebSocket是基于TCP的网络协议，实现浏览器与服务器全双工通信</span><br><span class="line">浏览器和服务器只需完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输</span><br><span class="line"></span><br><span class="line">1.导入坐标</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">2.创建WebSocket配置类</span><br><span class="line">@Configuration</span><br><span class="line">@EnableWebSocket</span><br><span class="line">public class WebSocketConfig implements WebSocketConfigurer &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) &#123;</span><br><span class="line">        registry.addHandler(myWebSocketHandler(), &quot;/websocket&quot;).setAllowedOrigins(&quot;*&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public WebSocketHandler myWebSocketHandler() &#123;</span><br><span class="line">        return new MyWebSocketHandler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">3. WebSocket处理程序</span><br><span class="line">public class MyWebSocketHandler extends TextWebSocketHandler &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterConnectionEstablished(WebSocketSession session) throws Exception &#123;</span><br><span class="line">        // 在建立WebSocket连接后执行的逻辑</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception &#123;</span><br><span class="line">        // 处理收到的文本消息</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception &#123;</span><br><span class="line">        // 在关闭WebSocket连接后执行的逻辑</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


  </div>
  
</div>
          </div>
        </div>

        <link rel="stylesheet" href="/css/footer.css">
<div class="bottom-outer">
  <div class="framework-info">
    <span>Power by</span>
    <a class="a1" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>
    <span class="footer-separator">|</span>
    <span>Theme by</span>
    <a class="a2" target="_blank" rel="noopener" href="https://github.com/redhat123456/hexo-theme-MiHoYo">MiHoYo</a>
  </div>
</div>

          
            <!-- scripts list from theme config.yml -->
            
              <script src="/js/MiHoYo.js"></script>
              
                

  </body>

  </html>