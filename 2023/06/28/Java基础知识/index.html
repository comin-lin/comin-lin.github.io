<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  
  <title>Java基础知识 | comin-lin&#39;s blog</title>
  <meta name="author" content="comin-lin">
  
  <meta name="description" content="数据类型java中的八个基本类型和大小（单位：比特）

boolean&amp;#x2F;1
byte&amp;#x2F;8
char&amp;#x2F;16
short&amp;#x2F;16
int&amp;#x2F;32
float&amp;#x2F;32
long&amp;#x2F;64
double&amp;#x2F;64

基本类型有对应的包装类型，">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Java基础知识"/>
  <meta property="og:site_name" content="comin-lin&#39;s blog"/>

  
    <meta property="og:image" content=""/>
  

  <link rel="shortcut icon" href="/favicon.png">
  
  
<link rel="stylesheet" href="/css/style.css">

  <!--[if lt IE 9]><script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script><![endif]-->
  

<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">comin-lin&#39;s blog</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article id="post-Java基础知识" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2023-06-28T04:22:43.000Z"><a href="/2023/06/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">2023-06-28</a></time>
      
      
  
    <h1 class="p-name title" itemprop="headline name">Java基础知识</h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>java中的八个基本类型和大小（单位：比特）</p>
<ul>
<li>boolean&#x2F;1</li>
<li>byte&#x2F;8</li>
<li>char&#x2F;16</li>
<li>short&#x2F;16</li>
<li>int&#x2F;32</li>
<li>float&#x2F;32</li>
<li>long&#x2F;64</li>
<li>double&#x2F;64</li>
</ul>
<p>基本类型有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p>
<h3 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h3><p>new Integer(123) 与 Integer.valueOf(123) 的区别：</p>
<ul>
<li>new Integer(123) 每次都会新建一个对象</li>
<li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用</li>
</ul>
<p>valueOf会先判断值是否在缓存池中，如果存在直接返回缓存池中的内容</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h6 id="String不可变"><a href="#String不可变" class="headerlink" title="String不可变"></a>String不可变</h6><ul>
<li>String声明为final类，无法被继承</li>
<li>String内部使用final修饰的char数组存储数据，意味着该数组初始化后不能再引用其他数组。并且String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</li>
</ul>
<h6 id="不可变的好处"><a href="#不可变的好处" class="headerlink" title="不可变的好处"></a>不可变的好处</h6><ul>
<li>可以缓存 hash 值：String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</li>
<li>String Pool 的需要：如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</li>
<li>安全性：String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。</li>
<li>线程安全：String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</li>
</ul>
<h3 id="String-StringBuffer-和-StringBuilder-的区别"><a href="#String-StringBuffer-和-StringBuilder-的区别" class="headerlink" title="String, StringBuffer 和 StringBuilder 的区别"></a>String, StringBuffer 和 StringBuilder 的区别</h3><ul>
<li>可变性：String 不可变，StringBuffer 和 StringBuilder 可变</li>
<li>线程安全：String 不可变，因此是线程安全的，StringBuilder 不是线程安全的，StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li>
</ul>
<h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><ul>
<li>参数传递：Java 的参数是以值传递的形式传入方法中，而不是引用传递。</li>
<li>float 与 double：1.1字面量属于double类型，不能直接float f&#x3D;1.1，需要float f&#x3D;1.1f。Java不能隐式执行向下转型，因为这会使得精度降低</li>
<li>隐式类型转换：字面量1是int类型，它比short类型精度要高，因此不能隐式地将 int 类型下转型为 short 类型。但是使用 +&#x3D; 运算符可以执行隐式类型转换，s1+&#x3D;1等价于s1&#x3D;(short)(s1+1)</li>
<li>switch：switch 不支持 long，是因为 switch 的设计初衷是对那些只有少数的几个值进行等值判断，如果值过于复杂，那么还是用 if 比较合适</li>
</ul>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>如果没有泛型，要实现不同类型的加法，每种类型都需要重载一个add方法，通过泛型可复用为一个方法：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static &lt;T extends Number&gt; double add(T a, T b) &#123;</span><br><span class="line">    System.out.println(a + &quot;+&quot; + b + &quot;=&quot; + (a.doubleValue() + b.doubleValue()));</span><br><span class="line">    return a.doubleValue() + b.doubleValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型类</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//创建一个使用了泛型的实例：Data&lt;String&gt; data=new Data();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Data&lt;T&gt;&#123;  //声明该类存在泛型T，T可以用其他任何合法标识符或字母指定，如Type等</span><br><span class="line">	private T val;</span><br><span class="line">	public T getVal() &#123; //返回泛型T，T的具体类型由外部决定</span><br><span class="line">		return val;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setVal(T val) &#123;</span><br><span class="line">		this.val=val;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//多元泛型</span><br><span class="line"></span><br><span class="line">class Notepad&lt;K,V&gt;&#123;       // 此处指定了两个泛型类型  </span><br><span class="line">    private K key ;     // 此变量的类型由外部决定  </span><br><span class="line">    private V value ;   // 此变量的类型由外部决定  </span><br><span class="line">    public K getKey()&#123;  </span><br><span class="line">        return this.key ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public V getValue()&#123;  </span><br><span class="line">        return this.value ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public void setKey(K key)&#123;  </span><br><span class="line">        this.key = key ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public void setValue(V value)&#123;  </span><br><span class="line">        this.value = value ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>泛型接口</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">//通过子类实例化对象i = new InfoImpl&lt;String&gt;(&quot;tom&quot;) ;</span><br><span class="line"></span><br><span class="line">interface Info&lt;T&gt;&#123;        // 在接口上定义泛型  </span><br><span class="line">    public T getVar() ; // 定义抽象方法，抽象方法的返回值就是泛型类型  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">class InfoImpl&lt;T&gt; implements Info&lt;T&gt;&#123;   // 定义泛型接口的子类  </span><br><span class="line">    private T var ;             // 定义属性  </span><br><span class="line">    public InfoImpl(T var)&#123;     // 通过构造方法设置属性内容  </span><br><span class="line">        this.setVar(var) ;    </span><br><span class="line">    &#125;  </span><br><span class="line">    public void setVar(T var)&#123;  </span><br><span class="line">        this.var = var ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public T getVar()&#123;  </span><br><span class="line">        return this.var ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>泛型方法</p>
<p>定义泛型方法时，必须在返回值前边加一个<T>，来声明这是一个泛型方法，持有一个泛型T</p>
<p>例如：public <T> void methodName(T parameter)</p>
<p>泛型数组</p>
<p>List<?>[] list = new ArrayList<?>[10]; &#x2F;&#x2F;这里?是通配符，不能修改为其他符号</p>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>作用有以下四方面</p>
<ul>
<li>生成文档，通过代码里标识的元数据生成javadoc文档。</li>
<li>编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。</li>
<li>编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。</li>
<li>运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。</li>
</ul>
<p>注解分类</p>
<ul>
<li>Java自带的标准注解，包括@Override、@Deprecated和@SuppressWarnings，分别用于标明重写某个方法、标明某个类或方法过时、标明要忽略的警告，用这些注解标明后编译器就会进行检查。</li>
<li>元注解，元注解是用于定义注解的注解，包括@Retention、@Target、@Inherited、@Documented，@Retention用于标明注解被保留的阶段，@Target用于标明注解使用的范围，@Inherited用于标明注解可继承，@Documented用于标明是否生成javadoc文档。</li>
<li>自定义注解，可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。</li>
</ul>
<p>内置注解 - @Override</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.METHOD) //用来修饰方法</span><br><span class="line">@Retention(RetentionPolicy.SOURCE) //源码级别保留 只在编译时有效，在编译后的class文件中便不再存在</span><br><span class="line">public @interface Override &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//作用：告诉编译器被修饰的方法是重写的父类的中的相同签名的方法，编译器会对此做出检查，若发现父类中不存在这个方法或是存在的方法签名不同，则会报错</span><br></pre></td></tr></table></figure>

<p>内置注解 - @Deprecated</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Documented //生成javadoc文档</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME) //运行时保留</span><br><span class="line">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;) //能够修饰构造方法、属性、局部变量、方法、包、参数、类型</span><br><span class="line">public @interface Deprecated &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//作用：告诉编译器被修饰的程序元素已被“废弃”，不再建议用户使用</span><br></pre></td></tr></table></figure>

<p>内置注解 - @SuppressWarnings</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;) // 能够修饰的程序元素包括类型、属性、方法、参数、构造器、局部变量</span><br><span class="line">@Retention(RetentionPolicy.SOURCE) //源码级别保留</span><br><span class="line">public @interface SuppressWarnings &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//作用：编译器忽略指定的警告信息，指定的信息由String[] 内容决定</span><br></pre></td></tr></table></figure>


<p>元注解 - @Target</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">描述注解的使用范围（即：被修饰的注解可以用在什么地方）</span><br><span class="line">取值范围定义在ElementType 枚举</span><br><span class="line"></span><br><span class="line">public enum ElementType &#123;</span><br><span class="line"> </span><br><span class="line">    TYPE, // 类、接口、枚举类</span><br><span class="line"> </span><br><span class="line">    FIELD, // 成员变量（包括：枚举常量）</span><br><span class="line"> </span><br><span class="line">    METHOD, // 成员方法</span><br><span class="line"> </span><br><span class="line">    PARAMETER, // 方法参数</span><br><span class="line"> </span><br><span class="line">    CONSTRUCTOR, // 构造方法</span><br><span class="line"> </span><br><span class="line">    LOCAL_VARIABLE, // 局部变量</span><br><span class="line"> </span><br><span class="line">    ANNOTATION_TYPE, // 注解类</span><br><span class="line"> </span><br><span class="line">    PACKAGE, // 可用于修饰：包</span><br><span class="line"> </span><br><span class="line">    TYPE_PARAMETER, // 类型参数，JDK 1.8 新增</span><br><span class="line"> </span><br><span class="line">    TYPE_USE // 使用类型的任何地方，JDK 1.8 新增</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>元注解 - @Retention &amp; @RetentionTarget</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">描述注解保留的时间范围（即：被描述的注解在它所修饰的类中可以被保留到何时）</span><br><span class="line">取值范围定义在RetentionPolicy枚举中</span><br><span class="line"></span><br><span class="line">public enum RetentionPolicy &#123;</span><br><span class="line"> </span><br><span class="line">    SOURCE,    // 源文件保留</span><br><span class="line">    CLASS,       // 编译期保留，默认值</span><br><span class="line">    RUNTIME   // 运行期保留，可通过反射去获取注解信息</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>元注解 - @Documented</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">描述在使用 javadoc 工具为类生成帮助文档时是否要保留其注解信息。</span><br></pre></td></tr></table></figure>

<p>元注解 - @Inherited</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">被它修饰的Annotation将具有继承性。如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解。</span><br></pre></td></tr></table></figure>

<p>元注解 - @Repeatable (Java8)</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用于标记某个注解可以在同一个元素上重复应用多次。在使用@Repeatable注解后，可以简化对同一元素多次应用同一个注解的语法。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>元注解 - @Native (Java8)</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用 @Native 注解修饰成员变量，则表示这个变量可以被本地代码引用，常常被代码生成工具使用</span><br><span class="line">当一个方法或代码被标记为@Native时，它的实现将由底层的本地语言（如C、C++）提供</span><br></pre></td></tr></table></figure>

<p>注解与反射接口</p>
<p>定义注解后，如何获取注解中的内容呢？反射包java.lang.reflect下的AnnotatedElement接口提供这些方法</p>
<p>AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的方法来访问Annotation信息</p>
<ul>
<li>boolean isAnnotationPresent(Class&lt;?extends Annotation&gt; annotationClass) 判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false</li>
<li><T extends Annotation> T getAnnotation(Class<T> annotationClass) 返回该程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。</li>
<li>Annotation[] getAnnotations() 返回该程序元素上存在的所有注解，若没有注解，返回长度为0的数组。</li>
<li><T extends Annotation> T[] getAnnotationsByType(Class<T> annotationClass) 返回一个指定类型的注解数组，包含指定元素上的所有匹配注解对象。</li>
<li><T extends Annotation> T getDeclaredAnnotation(Class<T> annotationClass) 返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注释。如果没有注释直接存在于此元素上，则返回null</li>
<li>Annotation[] getDeclaredAnnotations() 返回直接存在于此元素上的所有注解及注解对应的重复注解容器。与此接口中的其他方法不同，该方法将忽略继承的注解。如果没有注释直接存在于此元素上，则返回长度为零的一个数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。</li>
</ul>
<h3 id="异常机制"><a href="#异常机制" class="headerlink" title="异常机制"></a>异常机制</h3><p>Throwable</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Throwable 是 Java 语言中所有错误与异常的超类。Throwable 包含两个子类：Error（错误）和 Exception（异常），它们通常用于指示发生了异常情况。Throwable 包含了其线程创建时线程执行堆栈的快照，它提供了 printStackTrace() 等接口用于获取堆栈跟踪数据等信息。</span><br></pre></td></tr></table></figure>
<p>Error（错误）</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error 类及其子类：程序中无法处理的错误，表示运行应用程序中出现了严重的错误。此类错误一般表示代码运行时 JVM 出现问题。通常有 Virtual MachineError（虚拟机运行错误）、NoClassDefFoundError（类定义错误）等。比如 OutOfMemoryError：内存不足错误；StackOverflowError：栈溢出错误。此类错误发生时，JVM 将终止线程。这些错误是不受检异常，非代码性错误。因此，当此类错误发生时，应用程序不应该去处理此类错误。按照Java惯例，我们是不应该实现任何新的Error子类的！</span><br></pre></td></tr></table></figure>
<p>Exception（异常）</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常。</span><br><span class="line"></span><br><span class="line">运行时异常都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。</span><br><span class="line"></span><br><span class="line">非运行时异常 （编译异常）是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</span><br></pre></td></tr></table></figure>
<p>可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可查异常（编译器要求必须处置的异常）：正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</span><br><span class="line"></span><br><span class="line">不可查异常(编译器不要求强制处置的异常)包括运行时异常（RuntimeException与其子类）和错误（Error）</span><br></pre></td></tr></table></figure>

<p>异常关键字</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try – 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。</span><br><span class="line">catch – 用于捕获异常。catch用来捕获try语句块中发生的异常。</span><br><span class="line">finally – finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。</span><br><span class="line">throw – 用于抛出异常。throws – 用在方法签名中，用于声明该方法可能抛出的异常。</span><br></pre></td></tr></table></figure>

<h3 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h3><p>反射的作用：通过反射，可获取Class类对象以及类中的成员变量、方法、构造方法等</p>
<p>Class类对象的获取：在类加载的时候，jvm会创建一个class对象，class对象是可以说是反射中最常用的，获取class对象的方式的主要有三种：</p>
<ul>
<li>根据类名获取 User.class</li>
<li>根据对象获取 user.getClass()</li>
<li>根据全限定类名获取 Class.forName(“com.test.User”)</li>
</ul>
<p>Class类的方法</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">forName() 获取Class对象的一个引用，如果类还没被加载就需要加载。该方法一般用来加载这个类</span><br><span class="line">getClass() 获取Class对象的一个引用，返回表示该对象的实际类型的Class引用</span><br><span class="line">getName() 取全限定的类名(包括包名)，即类的完整名字</span><br><span class="line">getSimpleName() 获取类名(不包括包名)</span><br><span class="line">getCanonicalName() 获取全限定的类名(包括包名)</span><br><span class="line">isInterface() 判断Class对象是否是表示一个接口</span><br><span class="line">getInterfaces() 返回Class对象数组，表示Class对象所引用的类所实现的所有接口。</span><br><span class="line">getSuperclass() 返回Class对象，表示Class对象所引用的类所继承的直接基类。应用该方法可在运行时发现一个对象完整的继承结构</span><br><span class="line">newInstance() 返回一个Oject对象，是实现“虚拟构造器”的一种途径。使用该方法创建的类，必须带有无参的构造器</span><br><span class="line">getFields() 获得某个类的所有的公共（public）的字段，包括继承自父类的所有公共字段。 类似的还有getMethods和getConstructors</span><br><span class="line">getDeclaredFields 获得某个类的自己声明的字段，即包括public、private和proteced，默认但是不包括父类声明的任何字段。类似的还有getDeclaredMethods和getDeclaredConstructors</span><br></pre></td></tr></table></figure>
<p>Constructor类：Constructor对象是通过Class类中的方法获取的</p>
<p>Field类：提供有关类或接口的单个字段的信息，以及对它的动态访问权限</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set(Object obj, Object value) 将指定对象变量上此 Field 对象表示的字段设置为指定的新值</span><br><span class="line">get(Object obj) 返回指定对象上此 Field 表示的字段的值</span><br><span class="line">getType() 返回一个 Class 对象，它标识了此Field 对象所表示字段的声明类型</span><br><span class="line">isEnumConstant() 如果此字段表示枚举类型的元素则返回 true；否则返回 false</span><br><span class="line">toGenericString() 返回一个描述此 Field（包括其一般类型）的字符串</span><br><span class="line">getName() 返回此 Field 对象表示的字段的名称</span><br><span class="line">getDeclaringClass() 返回表示类或接口的 Class 对象，该类或接口声明由此 Field 对象表示的字段</span><br><span class="line">setAccessible(boolean flag) 将此对象的 accessible 标志设置为指示的布尔值,即设置其可访问性</span><br></pre></td></tr></table></figure>

<p>Method类：提供关于类或接口上单独某个方法（以及如何访问该方法）的信息，所反映的方法可能是类方法或实例方法（包括抽象方法）</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">invoke(Object obj, Object... args) 对带有指定参数的指定对象调用由此 Method 对象表示的底层方法 </span><br><span class="line">getName() 以 String 形式返回此 Method 对象表示的方法名称，即返回方法的名称</span><br></pre></td></tr></table></figure>

<h3 id="SPI机制"><a href="#SPI机制" class="headerlink" title="SPI机制"></a>SPI机制</h3><p>SPI机制是一种基于接口的服务发现机制。它允许在应用程序中定义接口，然后允许第三方供应商为这些接口提供实现，并通过在类路径上的配置文件中声明服务提供者。这种机制可以实现模块化和可插拔的架构，使得应用程序能够在运行时动态地加载和使用不同的实现。</p>

      
    </div>
    <footer>
      
        
        
  
  <div class="tags">
    <a href="/tags/java/">java</a>
  </div>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


</div></div>
    <aside id="sidebar" class="alignright">
  

  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/java/">java</a><small>1</small></li>
  
    <li><a href="/tags/%E7%AE%97%E6%B3%95/">算法</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2023 comin-lin
  
</div>
<div class="clearfix"></div></footer>
  
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/jquery.imagesloaded.min.js"></script>


<script src="/js/gallery.js"></script>





</body>
</html>
