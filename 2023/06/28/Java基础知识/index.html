

  <!DOCTYPE html>
  <html lang="zh-CN">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="renderer" content="webkit">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta name="description" content= >
  <meta name="keywords" content=hexo,theme,MiHoYo >

  <head>
    <title>
      Java基础知识 [ comin-lin&#39;s blog ]
    </title>
  <meta name="generator" content="Hexo 6.3.0"></head>

  <body>

    <link rel="stylesheet" href="/css/header.css">
<div class="header">
  <div class="logo">
    <span class="pull-left">
      <a id="site-name" href="/">
        comin-lin&#39;s blog
      </a>
    </span>
  </div>
  <ul class="nav-list">
    
      <li>
        <a href="/">
          首页
        </a>
      </li>
      
  </ul>
</div>

      <!--<link rel="stylesheet" href="/css/top-header.css">
<div id="top-bar" class="fixed">

  <a class="goto-top" href="#"></a>
  <ul class="bar-list bar-list-1">
    
      <li>
        <p>
          <a href="/">
            <text class="bar-text bar-p1">
              首页
            </text>
            <text class="bar-text bar-p2"></text>
          </a>
          <text class="bar-p3">/</text>
        </p>
      </li>
      
  </ul>
</div>-->

        <div id="content-outer">
          <div class="content-inner">
            <link rel="stylesheet" href="/css/post.css">
<div class="posts">
  <a href="/index.html"><i class="fa fa-home
replay-btn" aria-hidden="true"></i></a>
  <div class="post-title">
    <p>
      Java基础知识
    </p>
    <hr>
  </div>
  <div class="post-content">
    <h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="https://www.pdai.tech/">https://www.pdai.tech/</a></p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>java中的八个基本类型和大小（单位：比特）</p>
<ul>
<li>boolean&#x2F;1</li>
<li>byte&#x2F;8</li>
<li>char&#x2F;16</li>
<li>short&#x2F;16</li>
<li>int&#x2F;32</li>
<li>float&#x2F;32</li>
<li>long&#x2F;64</li>
<li>double&#x2F;64</li>
</ul>
<p>基本类型有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p>
<h3 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h3><p>new Integer(123) 与 Integer.valueOf(123) 的区别：</p>
<ul>
<li>new Integer(123) 每次都会新建一个对象</li>
<li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用</li>
</ul>
<p>valueOf会先判断值是否在缓存池中，如果存在直接返回缓存池中的内容</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h6 id="String不可变"><a href="#String不可变" class="headerlink" title="String不可变"></a>String不可变</h6><ul>
<li>String声明为final类，无法被继承</li>
<li>String内部使用final修饰的char数组存储数据，意味着该数组初始化后不能再引用其他数组。并且String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</li>
</ul>
<h6 id="不可变的好处"><a href="#不可变的好处" class="headerlink" title="不可变的好处"></a>不可变的好处</h6><ul>
<li>可以缓存 hash 值：String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</li>
<li>String Pool 的需要：如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</li>
<li>安全性：String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。</li>
<li>线程安全：String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</li>
</ul>
<h3 id="String-StringBuffer-和-StringBuilder-的区别"><a href="#String-StringBuffer-和-StringBuilder-的区别" class="headerlink" title="String, StringBuffer 和 StringBuilder 的区别"></a>String, StringBuffer 和 StringBuilder 的区别</h3><ul>
<li>可变性：String 不可变，StringBuffer 和 StringBuilder 可变</li>
<li>线程安全：String 不可变，因此是线程安全的，StringBuilder 不是线程安全的，StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li>
</ul>
<h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><ul>
<li>参数传递：Java 的参数是以值传递的形式传入方法中，而不是引用传递。</li>
<li>float 与 double：1.1字面量属于double类型，不能直接float f&#x3D;1.1，需要float f&#x3D;1.1f。Java不能隐式执行向下转型，因为这会使得精度降低</li>
<li>隐式类型转换：字面量1是int类型，它比short类型精度要高，因此不能隐式地将 int 类型下转型为 short 类型。但是使用 +&#x3D; 运算符可以执行隐式类型转换，s1+&#x3D;1等价于s1&#x3D;(short)(s1+1)</li>
<li>switch：switch 不支持 long，是因为 switch 的设计初衷是对那些只有少数的几个值进行等值判断，如果值过于复杂，那么还是用 if 比较合适</li>
</ul>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>如果没有泛型，要实现不同类型的加法，每种类型都需要重载一个add方法，通过泛型可复用为一个方法：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static &lt;T extends Number&gt; double add(T a, T b) &#123;</span><br><span class="line">    System.out.println(a + &quot;+&quot; + b + &quot;=&quot; + (a.doubleValue() + b.doubleValue()));</span><br><span class="line">    return a.doubleValue() + b.doubleValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型类</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//创建一个使用了泛型的实例：Data&lt;String&gt; data=new Data();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Data&lt;T&gt;&#123;  //声明该类存在泛型T，T可以用其他任何合法标识符或字母指定，如Type等</span><br><span class="line">	private T val;</span><br><span class="line">	public T getVal() &#123; //返回泛型T，T的具体类型由外部决定</span><br><span class="line">		return val;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setVal(T val) &#123;</span><br><span class="line">		this.val=val;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//多元泛型</span><br><span class="line"></span><br><span class="line">class Notepad&lt;K,V&gt;&#123;       // 此处指定了两个泛型类型  </span><br><span class="line">    private K key ;     // 此变量的类型由外部决定  </span><br><span class="line">    private V value ;   // 此变量的类型由外部决定  </span><br><span class="line">    public K getKey()&#123;  </span><br><span class="line">        return this.key ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public V getValue()&#123;  </span><br><span class="line">        return this.value ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public void setKey(K key)&#123;  </span><br><span class="line">        this.key = key ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public void setValue(V value)&#123;  </span><br><span class="line">        this.value = value ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>泛型接口</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">//通过子类实例化对象i = new InfoImpl&lt;String&gt;(&quot;tom&quot;) ;</span><br><span class="line"></span><br><span class="line">interface Info&lt;T&gt;&#123;        // 在接口上定义泛型  </span><br><span class="line">    public T getVar() ; // 定义抽象方法，抽象方法的返回值就是泛型类型  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">class InfoImpl&lt;T&gt; implements Info&lt;T&gt;&#123;   // 定义泛型接口的子类  </span><br><span class="line">    private T var ;             // 定义属性  </span><br><span class="line">    public InfoImpl(T var)&#123;     // 通过构造方法设置属性内容  </span><br><span class="line">        this.setVar(var) ;    </span><br><span class="line">    &#125;  </span><br><span class="line">    public void setVar(T var)&#123;  </span><br><span class="line">        this.var = var ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public T getVar()&#123;  </span><br><span class="line">        return this.var ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>泛型方法</p>
<p>定义泛型方法时，必须在返回值前边加一个<T>，来声明这是一个泛型方法，持有一个泛型T</p>
<p>例如：public <T> void methodName(T parameter)</p>
<p>泛型数组</p>
<p>List<?>[] list = new ArrayList<?>[10]; &#x2F;&#x2F;这里?是通配符，不能修改为其他符号</p>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>作用有以下四方面</p>
<ul>
<li>生成文档，通过代码里标识的元数据生成javadoc文档。</li>
<li>编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。</li>
<li>编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。</li>
<li>运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。</li>
</ul>
<p>注解分类</p>
<ul>
<li>Java自带的标准注解，包括@Override、@Deprecated和@SuppressWarnings，分别用于标明重写某个方法、标明某个类或方法过时、标明要忽略的警告，用这些注解标明后编译器就会进行检查。</li>
<li>元注解，元注解是用于定义注解的注解，包括@Retention、@Target、@Inherited、@Documented，@Retention用于标明注解被保留的阶段，@Target用于标明注解使用的范围，@Inherited用于标明注解可继承，@Documented用于标明是否生成javadoc文档。</li>
<li>自定义注解，可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。</li>
</ul>
<p>内置注解 - @Override</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.METHOD) //用来修饰方法</span><br><span class="line">@Retention(RetentionPolicy.SOURCE) //源码级别保留 只在编译时有效，在编译后的class文件中便不再存在</span><br><span class="line">public @interface Override &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//作用：告诉编译器被修饰的方法是重写的父类的中的相同签名的方法，编译器会对此做出检查，若发现父类中不存在这个方法或是存在的方法签名不同，则会报错</span><br></pre></td></tr></table></figure>

<p>内置注解 - @Deprecated</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Documented //生成javadoc文档</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME) //运行时保留</span><br><span class="line">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;) //能够修饰构造方法、属性、局部变量、方法、包、参数、类型</span><br><span class="line">public @interface Deprecated &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//作用：告诉编译器被修饰的程序元素已被“废弃”，不再建议用户使用</span><br></pre></td></tr></table></figure>

<p>内置注解 - @SuppressWarnings</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;) // 能够修饰的程序元素包括类型、属性、方法、参数、构造器、局部变量</span><br><span class="line">@Retention(RetentionPolicy.SOURCE) //源码级别保留</span><br><span class="line">public @interface SuppressWarnings &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//作用：编译器忽略指定的警告信息，指定的信息由String[] 内容决定</span><br></pre></td></tr></table></figure>


<p>元注解 - @Target</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">描述注解的使用范围（即：被修饰的注解可以用在什么地方）</span><br><span class="line">取值范围定义在ElementType 枚举</span><br><span class="line"></span><br><span class="line">public enum ElementType &#123;</span><br><span class="line"> </span><br><span class="line">    TYPE, // 类、接口、枚举类</span><br><span class="line"> </span><br><span class="line">    FIELD, // 成员变量（包括：枚举常量）</span><br><span class="line"> </span><br><span class="line">    METHOD, // 成员方法</span><br><span class="line"> </span><br><span class="line">    PARAMETER, // 方法参数</span><br><span class="line"> </span><br><span class="line">    CONSTRUCTOR, // 构造方法</span><br><span class="line"> </span><br><span class="line">    LOCAL_VARIABLE, // 局部变量</span><br><span class="line"> </span><br><span class="line">    ANNOTATION_TYPE, // 注解类</span><br><span class="line"> </span><br><span class="line">    PACKAGE, // 可用于修饰：包</span><br><span class="line"> </span><br><span class="line">    TYPE_PARAMETER, // 类型参数，JDK 1.8 新增</span><br><span class="line"> </span><br><span class="line">    TYPE_USE // 使用类型的任何地方，JDK 1.8 新增</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>元注解 - @Retention &amp; @RetentionTarget</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">描述注解保留的时间范围（即：被描述的注解在它所修饰的类中可以被保留到何时）</span><br><span class="line">取值范围定义在RetentionPolicy枚举中</span><br><span class="line"></span><br><span class="line">public enum RetentionPolicy &#123;</span><br><span class="line"> </span><br><span class="line">    SOURCE,    // 源文件保留</span><br><span class="line">    CLASS,       // 编译期保留，默认值</span><br><span class="line">    RUNTIME   // 运行期保留，可通过反射去获取注解信息</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>元注解 - @Documented</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">描述在使用 javadoc 工具为类生成帮助文档时是否要保留其注解信息。</span><br></pre></td></tr></table></figure>

<p>元注解 - @Inherited</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">被它修饰的Annotation将具有继承性。如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解。</span><br></pre></td></tr></table></figure>

<p>元注解 - @Repeatable (Java8)</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用于标记某个注解可以在同一个元素上重复应用多次。在使用@Repeatable注解后，可以简化对同一元素多次应用同一个注解的语法。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>元注解 - @Native (Java8)</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用 @Native 注解修饰成员变量，则表示这个变量可以被本地代码引用，常常被代码生成工具使用</span><br><span class="line">当一个方法或代码被标记为@Native时，它的实现将由底层的本地语言（如C、C++）提供</span><br></pre></td></tr></table></figure>

<p>注解与反射接口</p>
<p>定义注解后，如何获取注解中的内容呢？反射包java.lang.reflect下的AnnotatedElement接口提供这些方法</p>
<p>AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的方法来访问Annotation信息</p>
<ul>
<li>boolean isAnnotationPresent(Class&lt;?extends Annotation&gt; annotationClass) 判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false</li>
<li><T extends Annotation> T getAnnotation(Class<T> annotationClass) 返回该程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。</li>
<li>Annotation[] getAnnotations() 返回该程序元素上存在的所有注解，若没有注解，返回长度为0的数组。</li>
<li><T extends Annotation> T[] getAnnotationsByType(Class<T> annotationClass) 返回一个指定类型的注解数组，包含指定元素上的所有匹配注解对象。</li>
<li><T extends Annotation> T getDeclaredAnnotation(Class<T> annotationClass) 返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注释。如果没有注释直接存在于此元素上，则返回null</li>
<li>Annotation[] getDeclaredAnnotations() 返回直接存在于此元素上的所有注解及注解对应的重复注解容器。与此接口中的其他方法不同，该方法将忽略继承的注解。如果没有注释直接存在于此元素上，则返回长度为零的一个数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。</li>
</ul>
<h3 id="异常机制"><a href="#异常机制" class="headerlink" title="异常机制"></a>异常机制</h3><p>Throwable</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Throwable 是 Java 语言中所有错误与异常的超类。Throwable 包含两个子类：Error（错误）和 Exception（异常），它们通常用于指示发生了异常情况。Throwable 包含了其线程创建时线程执行堆栈的快照，它提供了 printStackTrace() 等接口用于获取堆栈跟踪数据等信息。</span><br></pre></td></tr></table></figure>
<p>Error（错误）</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error 类及其子类：程序中无法处理的错误，表示运行应用程序中出现了严重的错误。此类错误一般表示代码运行时 JVM 出现问题。通常有 Virtual MachineError（虚拟机运行错误）、NoClassDefFoundError（类定义错误）等。比如 OutOfMemoryError：内存不足错误；StackOverflowError：栈溢出错误。此类错误发生时，JVM 将终止线程。这些错误是不受检异常，非代码性错误。因此，当此类错误发生时，应用程序不应该去处理此类错误。按照Java惯例，我们是不应该实现任何新的Error子类的！</span><br></pre></td></tr></table></figure>
<p>Exception（异常）</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常。</span><br><span class="line"></span><br><span class="line">运行时异常都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。</span><br><span class="line"></span><br><span class="line">非运行时异常 （编译异常）是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</span><br></pre></td></tr></table></figure>
<p>可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可查异常（编译器要求必须处置的异常）：正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</span><br><span class="line"></span><br><span class="line">不可查异常(编译器不要求强制处置的异常)包括运行时异常（RuntimeException与其子类）和错误（Error）</span><br></pre></td></tr></table></figure>

<p>异常关键字</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try – 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。</span><br><span class="line">catch – 用于捕获异常。catch用来捕获try语句块中发生的异常。</span><br><span class="line">finally – finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。</span><br><span class="line">throw – 用于抛出异常。throws – 用在方法签名中，用于声明该方法可能抛出的异常。</span><br></pre></td></tr></table></figure>

<h3 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h3><p>反射的作用：通过反射，可获取Class类对象以及类中的成员变量、方法、构造方法等</p>
<p>Class类对象的获取：在类加载的时候，jvm会创建一个class对象，class对象是可以说是反射中最常用的，获取class对象的方式的主要有三种：</p>
<ul>
<li>根据类名获取 User.class</li>
<li>根据对象获取 user.getClass()</li>
<li>根据全限定类名获取 Class.forName(“com.test.User”)</li>
</ul>
<p>Class类的方法</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">forName() 获取Class对象的一个引用，如果类还没被加载就需要加载。该方法一般用来加载这个类</span><br><span class="line">getClass() 获取Class对象的一个引用，返回表示该对象的实际类型的Class引用</span><br><span class="line">getName() 取全限定的类名(包括包名)，即类的完整名字</span><br><span class="line">getSimpleName() 获取类名(不包括包名)</span><br><span class="line">getCanonicalName() 获取全限定的类名(包括包名)</span><br><span class="line">isInterface() 判断Class对象是否是表示一个接口</span><br><span class="line">getInterfaces() 返回Class对象数组，表示Class对象所引用的类所实现的所有接口。</span><br><span class="line">getSuperclass() 返回Class对象，表示Class对象所引用的类所继承的直接基类。应用该方法可在运行时发现一个对象完整的继承结构</span><br><span class="line">newInstance() 返回一个Oject对象，是实现“虚拟构造器”的一种途径。使用该方法创建的类，必须带有无参的构造器</span><br><span class="line">getFields() 获得某个类的所有的公共（public）的字段，包括继承自父类的所有公共字段。 类似的还有getMethods和getConstructors</span><br><span class="line">getDeclaredFields 获得某个类的自己声明的字段，即包括public、private和proteced，默认但是不包括父类声明的任何字段。类似的还有getDeclaredMethods和getDeclaredConstructors</span><br></pre></td></tr></table></figure>
<p>Constructor类：Constructor对象是通过Class类中的方法获取的</p>
<p>Field类：提供有关类或接口的单个字段的信息，以及对它的动态访问权限</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set(Object obj, Object value) 将指定对象变量上此 Field 对象表示的字段设置为指定的新值</span><br><span class="line">get(Object obj) 返回指定对象上此 Field 表示的字段的值</span><br><span class="line">getType() 返回一个 Class 对象，它标识了此Field 对象所表示字段的声明类型</span><br><span class="line">isEnumConstant() 如果此字段表示枚举类型的元素则返回 true；否则返回 false</span><br><span class="line">toGenericString() 返回一个描述此 Field（包括其一般类型）的字符串</span><br><span class="line">getName() 返回此 Field 对象表示的字段的名称</span><br><span class="line">getDeclaringClass() 返回表示类或接口的 Class 对象，该类或接口声明由此 Field 对象表示的字段</span><br><span class="line">setAccessible(boolean flag) 将此对象的 accessible 标志设置为指示的布尔值,即设置其可访问性</span><br></pre></td></tr></table></figure>

<p>Method类：提供关于类或接口上单独某个方法（以及如何访问该方法）的信息，所反映的方法可能是类方法或实例方法（包括抽象方法）</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">invoke(Object obj, Object... args) 对带有指定参数的指定对象调用由此 Method 对象表示的底层方法 </span><br><span class="line">getName() 以 String 形式返回此 Method 对象表示的方法名称，即返回方法的名称</span><br></pre></td></tr></table></figure>

<h3 id="SPI机制"><a href="#SPI机制" class="headerlink" title="SPI机制"></a>SPI机制</h3><p>SPI机制是一种基于接口的服务发现机制。它允许在应用程序中定义接口，然后允许第三方供应商为这些接口提供实现，并通过在类路径上的配置文件中声明服务提供者。这种机制可以实现模块化和可插拔的架构，使得应用程序能够在运行时动态地加载和使用不同的实现。</p>
<h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><p>Java容器里只能放对象，对于基本类型(int, long, float, double等)，需要将其包装成对象类型后(Integer, Long, Float, Double等)才能放到容器里。很多时候拆包装和解包装能够自动完成。这虽然会导致额外的性能和空间开销，但简化了设计和编程</p>
<p>容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对(两个对象)的映射表</p>
<p>TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)</p>
<p>HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</p>
<p>LinkedHashSet：具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序</p>
<p>ArrayList：基于动态数组实现，支持随机访问</p>
<p>Vector：和 ArrayList 类似，但它是线程安全的</p>
<p>LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列</p>
<p>PriorityQueue：基于堆结构实现，可以用它来实现优先队列</p>
<p>TreeMap：基于红黑树实现</p>
<p>HashMap：基于哈希表实现</p>
<p>HashTable：和 HashMap 类似，但它是线程安全的，是遗留类，不应该去使用它</p>
<p>LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用(LRU)顺序</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>数组：一种连续存储线性结构，元素类型相同，大小相等</p>
<p>链表：n个节点离散分配，彼此通过指针相连，每个节点只有一个前驱节点，每个节点只有一个后续节点，首节点没有前驱节点，尾节点没有后续节点</p>
<p>哈希表：根据关键码值(Key value)直接进行访问的数据结构</p>
<p>栈和队列：栈为先进后出，队列先进先出</p>
<p>树：<br>1.二叉搜索树BST：左子树上所有结点的值均小于它的根结点的值，右子树上所有结点的值均大于它的根结点的值，对于一个节点，其左、右子树也分别为二叉搜索树<br>2.平衡二叉树AVL：左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树<br>3.红黑树：一种自平衡二叉查找树<br>4.哈夫曼树：一种带权路径长度最短的二叉树<br>5.字典树：又称前缀树、单词查找树或键树</p>
<p>图：</p>
<p>遍历方式：<br>DFS 深度优先搜索<br>BFS 广度优先搜索</p>
<p>最小生成树：<br>kruskal算法 对边的权重排序，选边并判断环（并查集实现），直到选完n-1条边<br>prim算法 选择任意点出发，每次选择到达价值最小的点，直到全中所有点</p>
<p>最短路径：<br>dijkstra算法 单源最短路径 从起点出发BFS，遍历其邻接点，更新到邻接点的最短距离<br>floyd算法 多源最短路径 枚举中转点k，对于每一点对i，j，如果i到j的距离大于先从i到k，再从k到j，则更新i与j之间的最短距离</p>
<p>拓扑排序：不断选取入度为0的点，加入拓扑排序的列表中，并将与其邻接的点的入度减1，直到得到完整的拓扑排序结果</p>
<p>AOE：AOE网是一个带权的有向无环图，在AOE网中，具有最大路径长度的路径称为关键路径，关键路径表示完成工程的最短工期<br>关键路径：在AOE网中从源点到汇点路径最长的路径</p>
<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>插入排序</p>
<pre><code>直接插入排序：
    思想：把n个待排序的元素看成为一个有序表和一个无序表。开始时有序表中只包含1个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，将它插入到有序表中的适当位置，使之成为新的有序表，重复n-1次可完成排序过程
    时间复杂度：平均o(n^2) 最好o(n) 最坏o(n^2) 
    稳定
    
希尔排序：
    思想：实质上是一种分组插入方法。对于n个待排序的数列，取一个小于n的整数gap(gap被称为步长)将待排序元素分成若干个组子序列，所有距离为gap的倍数的记录放在同一个组中；然后，对各组内的元素进行直接插入排序。 这一趟排序完成之后，每一个组的元素都是有序的。然后减小gap的值，并重复执行上述的分组和排序。重复这样的操作，当gap=1时，整个数列就是有序的
    时间复杂度：与增量(即，步长gap)的选取有关。当增量为1时，希尔排序退化成了直接插入排序，此时的时间复杂度为O(n^2)
    不稳定
    
</code></pre>
<p>选择排序</p>
<pre><code>直接选择排序：
    思想：在未排序的区间中选取最小元素放在最前面，再从剩余未排序的元素中继续寻找，直到所有元素均排序完毕
    时间复杂度：平均o(n^2) 最好o(n^2) 最坏o(n^2) 
    不稳定
    
堆排序：
    思想：把所有元素放入小顶堆再取出
    时间复杂度：o(logn)
    不稳定
</code></pre>
<p>交换排序</p>
<pre><code>冒泡排序：
    思想：遍历数组时不断如果相邻的两个元素前者小于后者，则交换位置，第一轮遍历结束后，最大元素将位于数组末尾，不断遍历直到数组有序
    时间复杂度：平均o(n^2) 最好o(n) 最坏o(n^2) 
    稳定
    
快速排序：
    思想：选择一个基准数，通过一趟排序将要排序的数据分割成独立的两部分；其中一部分的所有数据都比另外一部分的所有数据都要小。然后，再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列
    时间复杂度：平均o(logn) 最好o(logn) 最坏o(n^2)
    不稳定
</code></pre>
<p>归并排序：<br>    思想：从上往下的归并是不断将区间划分为两个小区间，递归进行排序<br>    时间复杂度：O(n*lgn)<br>    稳定</p>
<p>桶排序：<br>    思想：将数组分到有限数量的桶子里，再通过从每个桶取出元素完成排序<br>    时间复杂度：取决与对各个桶之间数据进行排序的时间复杂度。桶划分得越小，桶中的数据越少，排序所用的时间也会越少<br>    稳定</p>
<p>基数排序：<br>    思想：将整数按位数切割成不同的数字，然后按每个位数分别比较。 具体做法是: 将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。<br>    时间复杂度：o(d(r+n)) 其中r为关键字的基数，d为长度，n为关键字的个数<br>    稳定</p>
<h3 id="常用类库"><a href="#常用类库" class="headerlink" title="常用类库"></a>常用类库</h3><p>Apache Common包：是对JDK的拓展，包含了很多开源的工具，用于解决平时编程经常会遇到的问题，减少重复劳动。官网网址:<a target="_blank" rel="noopener" href="http://commons.apache.org/">http://commons.apache.org</a><br>    BeanUtils：针对Bean的一个工具集，常用来copyProperties<br>    Codec：编码和解码组件，提供常用的编码和解码方法，如DES、SHA1、MD5、Base64、URL和Soundx等<br>    Collections：一个集合组件，扩展了Java标准Collections API，对常用的集合操作进行了很好的封装、抽象和补充，在保证性能的同时大大简化代码</p>
<p>Google Guava包：包含了若干被Google的 Java项目广泛依赖 的核心库，例如：集合 [collections] 、缓存 [caching] 、原生类型支持 [primitives support] 、并发库 [concurrency libraries] 、通用注解 [common annotations] 、字符串处理 [string processing] 、I&#x2F;O 等等。 所有这些工具每天都在被Google的工程师应用在产品服务中</p>
<p>Hutool包：一个小而全的Java工具类库，通过静态方法封装，降低相关API的学习成本，提高工作效率</p>
<p>日志库：<br>    日志门面：一种设计模式，用于在应用程序中实现日志记录的抽象层 如：common-logging、slf4j<br>    日志系统：实际用于记录和管理日志消息的软件组件或库 如：Log4j、Logback、Log4j2</p>
<p>JSON库：<br>    FastJson: 阿里巴巴开发的 JSON 库，性能优秀<br>    Jackson: 社区十分活跃且更新速度很快<br>    Gson: 谷歌开发的 JSON 库，功能十分全面</p>
<p>Lombok工具库：一款非常实用Java工具，可用来帮助开发人员消除Java的冗长代码，尤其是对于简单的Java对象</p>
<p>MapStruct工具库：主要用于解决对象之间的拷贝问题，比如PO&#x2F;DTO&#x2F;VO&#x2F;QueryParam之间的转换问题。区别于BeanUtils这种通过反射，它通过编译器编译生成常规方法，将可以很大程度上提升效率</p>

  </div>
  
</div>
          </div>
        </div>

        <link rel="stylesheet" href="/css/footer.css">
<div class="bottom-outer">
  <div class="framework-info">
    <span>Power by</span>
    <a class="a1" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>
    <span class="footer-separator">|</span>
    <span>Theme by</span>
    <a class="a2" target="_blank" rel="noopener" href="https://github.com/redhat123456/hexo-theme-MiHoYo">MiHoYo</a>
  </div>
</div>

          
            <!-- scripts list from theme config.yml -->
            
              <script src="/js/MiHoYo.js"></script>
              
                

  </body>

  </html>