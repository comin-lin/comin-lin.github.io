<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  
  <title>Spring框架的IOC、AOP | comin-lin&#39;s blog</title>
  <meta name="author" content="comin-lin">
  
  <meta name="description" content="原文章https://javadoop.com/post/spring-ioc
https://javadoop.com/post/spring-aop-source 
IOCIOC最重要的两个地方，一个是创建Bean容器，一个是初始化Bean
启动Spring容器123public static ">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Spring框架的IOC、AOP"/>
  <meta property="og:site_name" content="comin-lin&#39;s blog"/>

  
    <meta property="og:image" content=""/>
  

  <link rel="shortcut icon" href="/favicon.png">
  
  
<link rel="stylesheet" href="/css/style.css">

  <!--[if lt IE 9]><script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script><![endif]-->
  

<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">comin-lin&#39;s blog</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article id="post-Spring框架的IOC、AOP" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2023-08-05T02:38:57.000Z"><a href="/2023/08/05/Spring%E6%A1%86%E6%9E%B6%E7%9A%84IOC%E3%80%81AOP/">2023-08-05</a></time>
      
      
  
    <h1 class="p-name title" itemprop="headline name">Spring框架的IOC、AOP</h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h1 id="原文章"><a href="#原文章" class="headerlink" title="原文章"></a>原文章</h1><p><a target="_blank" rel="noopener" href="https://javadoop.com/post/spring-ioc">https://javadoop.com/post/spring-ioc</a></p>
<p><a target="_blank" rel="noopener" href="https://javadoop.com/post/spring-aop-source">https://javadoop.com/post/spring-aop-source</a> </p>
<h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>IOC最重要的两个地方，一个是创建Bean容器，一个是初始化Bean</p>
<h6 id="启动Spring容器"><a href="#启动Spring容器" class="headerlink" title="启动Spring容器"></a>启动Spring容器</h6><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationfile.xml&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码利用配置文件applicationfile.xml启动了Spring容器</p>
<p>也可以使用其他方式启动Spring容器，下面是一张继承结构图<br><img src="/../images/1.png" alt="image">)<br>图中绿色标注的类也可以用来创建Spring容器：<br>FileSystemXmlApplicationContext 的构造函数需要一个 xml 配置文件在系统中的路径，其他和 ClassPathXmlApplicationContext 基本上一样</p>
<p>AnnotationConfigApplicationContext 是基于注解来使用的，它不需要配置文件，采用 java 配置类和各种注解来配置，是比较简单的方式</p>
<p>ApplicationContext 启动过程中，会负责创建实例 Bean，往各个 Bean 中注入依赖</p>
<h6 id="BeanFactory简介"><a href="#BeanFactory简介" class="headerlink" title="BeanFactory简介"></a>BeanFactory简介</h6><p>BeanFactory是生产 bean 的工厂，它负责生产和管理各个 bean 实例，前面说的 ApplicationContext 其实就是一个 BeanFactory</p>
<p>以下是和BeanFactory 接口相关的主要的继承结构：<br><img src="/../images/2.png" alt="image">)<br>其中比较重要的几个点</p>
<ul>
<li>ApplicationContext 继承了 ListableBeanFactory，这个 Listable 的意思就是，通过这个接口，我们可以获取多个 Bean，大家看源码会发现，最顶层 BeanFactory 接口的方法都是获取单个 Bean 的</li>
<li>ApplicationContext 继承了 HierarchicalBeanFactory，Hierarchical 单词本身已经能说明问题了，也就是说我们可以在应用中起多个 BeanFactory，然后可以将各个 BeanFactory 设置为父子关系</li>
<li>AutowireCapableBeanFactory 这个名字中的 Autowire 大家都非常熟悉，它就是用来自动装配 Bean 用的，但是仔细看上图，ApplicationContext 并没有继承它，不过不用担心，不使用继承，不代表不可以使用组合，如果你看到 ApplicationContext 接口定义中的最后一个方法 getAutowireCapableBeanFactory() 就知道了</li>
<li>ConfigurableListableBeanFactory 也是一个特殊的接口，看图，特殊之处在于它继承了第二层所有的三个接口，而 ApplicationContext 没有。这点之后会用到</li>
</ul>
<h6 id="启动过程分析"><a href="#启动过程分析" class="headerlink" title="启动过程分析"></a>启动过程分析</h6><p>ClassPathXmlApplicationContext 的构造方法</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class ClassPathXmlApplicationContext extends AbstractXmlApplicationContext &#123;</span><br><span class="line"></span><br><span class="line">  private Resource[] configResources;</span><br><span class="line"></span><br><span class="line">  // 如果已经有 ApplicationContext 并需要配置成父子关系，那么调用这个构造方法</span><br><span class="line">  public ClassPathXmlApplicationContext(ApplicationContext parent) &#123;</span><br><span class="line">    super(parent);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent)</span><br><span class="line">      throws BeansException &#123;</span><br><span class="line"></span><br><span class="line">    super(parent);</span><br><span class="line">	</span><br><span class="line">    // 根据提供的路径，处理成配置文件数组(以分号、逗号、空格、tab、换行符分割)</span><br><span class="line">    setConfigLocations(configLocations);</span><br><span class="line">	</span><br><span class="line">    if (refresh) &#123;</span><br><span class="line">      refresh(); // 核心方法</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>refresh方法既可以初始化ApplicationContext，也可以继续调用，重建ApplicationContext（将原来的 ApplicationContext 销毁，然后再重新执行一次初始化操作）</p>
<p>refresh方法源码如下</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">   // 上锁，防止在refresh方法结束前继续调用了多个refresh方法</span><br><span class="line">   synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line"></span><br><span class="line">      // 准备工作，记录容器的启动时间、标记“已启动”状态、处理配置文件中的占位符</span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      // 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，</span><br><span class="line">      // 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，</span><br><span class="line">      // 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)</span><br><span class="line">      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      // 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean</span><br><span class="line">      // 这块待会会展开说</span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">         // 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，</span><br><span class="line">         // 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】</span><br><span class="line"></span><br><span class="line">         // 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化</span><br><span class="line">         // 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line">         // 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法</span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         // 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别</span><br><span class="line">         // 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</span><br><span class="line">         // 两个方法分别在 Bean 初始化之前和初始化之后得到执行。注意，到这里 Bean 还没初始化</span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         // 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了</span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         // 初始化当前 ApplicationContext 的事件广播器，这里也不展开了</span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         // 从方法名就可以知道，典型的模板方法(钩子方法)，</span><br><span class="line">         // 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）</span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         // 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过</span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         // 重点，重点，重点</span><br><span class="line">         // 初始化所有的 singleton beans</span><br><span class="line">         //（lazy-init 的除外）</span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         // 最后，广播事件，ApplicationContext 初始化完成</span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      catch (BeansException ex) &#123;</span><br><span class="line">         if (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(&quot;Exception encountered during context initialization - &quot; +</span><br><span class="line">                  &quot;cancelling refresh attempt: &quot; + ex);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         // Destroy already created singletons to avoid dangling resources.</span><br><span class="line">         // 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源</span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         // Reset &#x27;active&#x27; flag.</span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">         // 把异常往外抛</span><br><span class="line">         throw ex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      finally &#123;</span><br><span class="line">         // Reset common introspection caches in Spring&#x27;s core, since we</span><br><span class="line">         // might not ever need metadata for singleton beans anymore...</span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="创建容器前的准备工作"><a href="#创建容器前的准备工作" class="headerlink" title="创建容器前的准备工作"></a>创建容器前的准备工作</h6><p>prepareRefresh()方法</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">protected void prepareRefresh() &#123;</span><br><span class="line">   // 记录启动时间，</span><br><span class="line">   // 将 active 属性设置为 true，closed 属性设置为 false，它们都是 AtomicBoolean 类型（原子布尔类型，提供了原子性操作的能力，保证了对布尔值的操作是原子的，实现线程安全）</span><br><span class="line">   this.startupDate = System.currentTimeMillis();</span><br><span class="line">   this.closed.set(false);</span><br><span class="line">   this.active.set(true);</span><br><span class="line">	</span><br><span class="line">   if (logger.isInfoEnabled()) &#123;</span><br><span class="line">      logger.info(&quot;Refreshing &quot; + this);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // Initialize any placeholder property sources in the context environment</span><br><span class="line">   initPropertySources();</span><br><span class="line"></span><br><span class="line">   // 校验 xml 配置文件</span><br><span class="line">   getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">   this.earlyApplicationEvents = new LinkedHashSet&lt;ApplicationEvent&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="创建-Bean-容器，加载并注册-Bean"><a href="#创建-Bean-容器，加载并注册-Bean" class="headerlink" title="创建 Bean 容器，加载并注册 Bean"></a>创建 Bean 容器，加载并注册 Bean</h6><p>obtainFreshBeanFactory()方法</p>
<p>这个方法是最重要的部分之一，这里将会初始化 BeanFactory、加载 Bean、注册 Bean 等等。</p>
<p>注意，Bean实例并未在这一步生成。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected ConfigurableListableBeanFactory obtainFreshBeanFactory() &#123;</span><br><span class="line">   // 关闭旧的 BeanFactory (如果有)，创建新的 BeanFactory，加载 Bean 定义、注册 Bean 等等</span><br><span class="line">   refreshBeanFactory();</span><br><span class="line"></span><br><span class="line">   // 返回刚刚创建的 BeanFactory</span><br><span class="line">   ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">   if (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(&quot;Bean factory for &quot; + getDisplayName() + &quot;: &quot; + beanFactory);</span><br><span class="line">   &#125;</span><br><span class="line">   return beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>obtainFreshBeanFactory方法调用了refreshBeanFactory方法（AbstractRefreshableApplicationContext.java 120行）</p>
<p>以下是refreshBeanFactory的源码</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected final void refreshBeanFactory() throws BeansException &#123;</span><br><span class="line">   // 如果 ApplicationContext 中已经加载过 BeanFactory 了，销毁所有 Bean，关闭 BeanFactory</span><br><span class="line">   // 注意，应用中 BeanFactory 本来就是可以多个的，这里可不是说应用全局是否有 BeanFactory，而是当前</span><br><span class="line">   // ApplicationContext 是否有 BeanFactory</span><br><span class="line">   if (hasBeanFactory()) &#123;</span><br><span class="line">      destroyBeans();</span><br><span class="line">      closeBeanFactory();</span><br><span class="line">   &#125;</span><br><span class="line">   try &#123;</span><br><span class="line">      // 初始化一个 DefaultListableBeanFactory，为什么用这个，我们马上说。</span><br><span class="line">      DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">      // 用于 BeanFactory 的序列化，我想不部分人应该都用不到</span><br><span class="line">      beanFactory.setSerializationId(getId());</span><br><span class="line"></span><br><span class="line">      // 下面这两个方法很重要，别跟丢了，具体细节之后说</span><br><span class="line">      // 设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用</span><br><span class="line">      customizeBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      // 加载 Bean 到 BeanFactory 中</span><br><span class="line">      loadBeanDefinitions(beanFactory);</span><br><span class="line">      synchronized (this.beanFactoryMonitor) &#123;</span><br><span class="line">         this.beanFactory = beanFactory;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   catch (IOException ex) &#123;</span><br><span class="line">      throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + getDisplayName(), ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ApplicationContext 继承自 BeanFactory，但是它不应该被理解为 BeanFactory 的实现类，而是说其内部持有一个实例化的 BeanFactory（DefaultListableBeanFactory）。以后所有的 BeanFactory 相关的操作其实是委托给这个实例来处理的。</p>
<p>为什么选择实例化 DefaultListableBeanFactory 呢？回过头看上面的那张图，可以发现ConfigurableListableBeanFactory 只有一个实现类 DefaultListableBeanFactory，而且实现类 DefaultListableBeanFactory 还通过实现右边的 AbstractAutowireCapableBeanFactory 通吃了右路。所以结论就是，最底下这个家伙 DefaultListableBeanFactory 基本上是最牛的 BeanFactory 了，这也是为什么这边会使用这个类来实例化的原因</p>
<p>想要在程序运行的时候动态往 Spring IOC 容器注册新的 bean，就会使用到DefaultListableBeanFactory</p>
<h6 id="bean的本质"><a href="#bean的本质" class="headerlink" title="bean的本质"></a>bean的本质</h6><p>BeanFactory 是 Bean 容器，那么 Bean 又是什么呢？Spring 的 Bean 在代码层面上而言其实是BeanDefinition的实例，定义的各个 Bean 会转换成一个个的 BeanDefinition实例 存在于 Spring 的 BeanFactory中</p>
<p>BeanDefinition 接口定义</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanDefinition extends AttributeAccessor, BeanMetadataElement &#123;</span><br><span class="line"></span><br><span class="line">   // 我们可以看到，默认只提供 sington 和 prototype 两种，</span><br><span class="line">   // 很多读者可能知道还有 request, session, globalSession, application, websocket 这几种，</span><br><span class="line">   // 不过，它们属于基于 web 的扩展。</span><br><span class="line">   String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;</span><br><span class="line">   String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;</span><br><span class="line"></span><br><span class="line">   // 比较不重要，直接跳过吧</span><br><span class="line">   int ROLE_APPLICATION = 0;</span><br><span class="line">   int ROLE_SUPPORT = 1;</span><br><span class="line">   int ROLE_INFRASTRUCTURE = 2;</span><br><span class="line"></span><br><span class="line">   // 设置父 Bean，这里涉及到 bean 继承，不是 java 继承。请参见附录的详细介绍</span><br><span class="line">   // 一句话就是：继承父 Bean 的配置信息而已</span><br><span class="line">   void setParentName(String parentName);</span><br><span class="line"></span><br><span class="line">   // 获取父 Bean</span><br><span class="line">   String getParentName();</span><br><span class="line"></span><br><span class="line">   // 设置 Bean 的类名称，将来是要通过反射来生成实例的</span><br><span class="line">   void setBeanClassName(String beanClassName);</span><br><span class="line"></span><br><span class="line">   // 获取 Bean 的类名称</span><br><span class="line">   String getBeanClassName();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   // 设置 bean 的 scope</span><br><span class="line">   void setScope(String scope);</span><br><span class="line"></span><br><span class="line">   String getScope();</span><br><span class="line"></span><br><span class="line">   // 设置是否懒加载</span><br><span class="line">   void setLazyInit(boolean lazyInit);</span><br><span class="line"></span><br><span class="line">   boolean isLazyInit();</span><br><span class="line"></span><br><span class="line">   // 设置该 Bean 依赖的所有的 Bean，注意，这里的依赖不是指属性依赖(如 @Autowire 标记的)，</span><br><span class="line">   // 是 depends-on=&quot;&quot; 属性设置的值。</span><br><span class="line">   void setDependsOn(String... dependsOn);</span><br><span class="line"></span><br><span class="line">   // 返回该 Bean 的所有依赖</span><br><span class="line">   String[] getDependsOn();</span><br><span class="line"></span><br><span class="line">   // 设置该 Bean 是否可以注入到其他 Bean 中，只对根据类型注入有效，</span><br><span class="line">   // 如果根据名称注入，即使这边设置了 false，也是可以的</span><br><span class="line">   void setAutowireCandidate(boolean autowireCandidate);</span><br><span class="line"></span><br><span class="line">   // 该 Bean 是否可以注入到其他 Bean 中</span><br><span class="line">   boolean isAutowireCandidate();</span><br><span class="line"></span><br><span class="line">   // 主要的。同一接口的多个实现，如果不指定名字的话，Spring 会优先选择设置 primary 为 true 的 bean</span><br><span class="line">   void setPrimary(boolean primary);</span><br><span class="line"></span><br><span class="line">   // 是否是 primary 的</span><br><span class="line">   boolean isPrimary();</span><br><span class="line"></span><br><span class="line">   // 如果该 Bean 采用工厂方法生成，指定工厂名称。对工厂不熟悉的读者，请参加附录</span><br><span class="line">   // 一句话就是：有些实例不是用反射生成的，而是用工厂模式生成的</span><br><span class="line">   void setFactoryBeanName(String factoryBeanName);</span><br><span class="line">   // 获取工厂名称</span><br><span class="line">   String getFactoryBeanName();</span><br><span class="line">   // 指定工厂类中的 工厂方法名称</span><br><span class="line">   void setFactoryMethodName(String factoryMethodName);</span><br><span class="line">   // 获取工厂类中的 工厂方法名称</span><br><span class="line">   String getFactoryMethodName();</span><br><span class="line"></span><br><span class="line">   // 构造器参数</span><br><span class="line">   ConstructorArgumentValues getConstructorArgumentValues();</span><br><span class="line"></span><br><span class="line">   // Bean 中的属性值，后面给 bean 注入属性值的时候会说到</span><br><span class="line">   MutablePropertyValues getPropertyValues();</span><br><span class="line"></span><br><span class="line">   // 是否 singleton</span><br><span class="line">   boolean isSingleton();</span><br><span class="line"></span><br><span class="line">   // 是否 prototype</span><br><span class="line">   boolean isPrototype();</span><br><span class="line"></span><br><span class="line">   // 如果这个 Bean 是被设置为 abstract，那么不能实例化，</span><br><span class="line">   // 常用于作为 父bean 用于继承，其实也很少用......</span><br><span class="line">   boolean isAbstract();</span><br><span class="line"></span><br><span class="line">   int getRole();</span><br><span class="line">   String getDescription();</span><br><span class="line">   String getResourceDescription();</span><br><span class="line">   BeanDefinition getOriginatingBeanDefinition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了 BeanDefinition 的概念以后，我们再往下看 refreshBeanFactory() 方法中的剩余部分：</p>
<p>customizeBeanFactory(beanFactory);</p>
<p>loadBeanDefinitions(beanFactory);</p>
<h6 id="customizeBeanFactory"><a href="#customizeBeanFactory" class="headerlink" title="customizeBeanFactory"></a>customizeBeanFactory</h6><p>customizeBeanFactory(beanFactory) 比较简单，就是配置是否允许 BeanDefinition 覆盖、是否允许循环引用</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) &#123;</span><br><span class="line">   if (this.allowBeanDefinitionOverriding != null) &#123;</span><br><span class="line">      // 是否允许 Bean 定义覆盖</span><br><span class="line">      beanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);</span><br><span class="line">   &#125;</span><br><span class="line">   if (this.allowCircularReferences != null) &#123;</span><br><span class="line">      // 是否允许 Bean 间的循环依赖</span><br><span class="line">      beanFactory.setAllowCircularReferences(this.allowCircularReferences);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="loadBeanDefinitions"><a href="#loadBeanDefinitions" class="headerlink" title="loadBeanDefinitions"></a>loadBeanDefinitions</h6><p>这个方法将根据配置，加载各个 Bean，然后放到 BeanFactory 中,读取配置的操作在 XmlBeanDefinitionReader 中，其负责加载配置、解析</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/** 我们可以看到，此方法将通过一个 XmlBeanDefinitionReader 实例来加载各个 Bean。*/</span><br><span class="line">@Override</span><br><span class="line">protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException &#123;</span><br><span class="line">   // 给这个 BeanFactory 实例化一个 XmlBeanDefinitionReader</span><br><span class="line">   XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">   // Configure the bean definition reader with this context&#x27;s</span><br><span class="line">   // resource loading environment.</span><br><span class="line">   beanDefinitionReader.setEnvironment(this.getEnvironment());</span><br><span class="line">   beanDefinitionReader.setResourceLoader(this);</span><br><span class="line">   beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));</span><br><span class="line"></span><br><span class="line">   // 初始化 BeanDefinitionReader，其实这个是提供给子类覆写的，</span><br><span class="line">   // 我看了一下，没有类覆写这个方法，我们暂且当做不重要吧</span><br><span class="line">   initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">   // 通过下面这个方法，一个配置文件将被转换为一颗 DOM 树</span><br><span class="line">   loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="注册-Bean"><a href="#注册-Bean" class="headerlink" title="注册 Bean"></a>注册 Bean</h6><p>BeanDefinitionReaderUtils 143行 别名注册</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void registerBeanDefinition(</span><br><span class="line">      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span><br><span class="line">      throws BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">   String beanName = definitionHolder.getBeanName();</span><br><span class="line">   // 注册这个 Bean</span><br><span class="line">   registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">   // 如果还有别名的话，也要根据别名全部注册一遍，不然根据别名就会找不到 Bean 了</span><br><span class="line">   // 这里是获取要注册的 bean 的别名数组</span><br><span class="line">   String[] aliases = definitionHolder.getAliases();</span><br><span class="line">   </span><br><span class="line">   // 如果别名数组不为空，则逐个将别名注册到 BeanDefinitionRegistry 中</span><br><span class="line">   if (aliases != null) &#123;</span><br><span class="line">      for (String alias : aliases) &#123;</span><br><span class="line">         // alias -&gt; beanName 保存它们的别名信息，这个很简单，用一个 map 保存一下就可以了，</span><br><span class="line">         // 获取的时候，会先将 alias 转换为 beanName，然后再查找</span><br><span class="line">         registry.registerAlias(beanName, alias);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DefaultListableBeanFactory 793行 注册Bean</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)</span><br><span class="line">      throws BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">   Assert.hasText(beanName, &quot;Bean name must not be empty&quot;);</span><br><span class="line">   Assert.notNull(beanDefinition, &quot;BeanDefinition must not be null&quot;);</span><br><span class="line"></span><br><span class="line">   if (beanDefinition instanceof AbstractBeanDefinition) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">         ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">      &#125;</span><br><span class="line">      catch (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">         throw new BeanDefinitionStoreException(...);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // old? 还记得 “允许 bean 覆盖” 这个配置吗？allowBeanDefinitionOverriding</span><br><span class="line">   BeanDefinition oldBeanDefinition;</span><br><span class="line"></span><br><span class="line">   // 之后会看到，所有的 Bean 注册后会放入这个 beanDefinitionMap 中</span><br><span class="line">   oldBeanDefinition = this.beanDefinitionMap.get(beanName);</span><br><span class="line"></span><br><span class="line">   // 处理重复名称的 Bean 定义的情况</span><br><span class="line">   if (oldBeanDefinition != null) &#123;</span><br><span class="line">      if (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">         // 如果不允许覆盖的话，抛异常</span><br><span class="line">         throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription()...</span><br><span class="line">      &#125;</span><br><span class="line">      else if (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">         // log...用框架定义的 Bean 覆盖用户自定义的 Bean </span><br><span class="line">      &#125;</span><br><span class="line">      else if (!beanDefinition.equals(oldBeanDefinition)) &#123;</span><br><span class="line">         // log...用新的 Bean 覆盖旧的 Bean</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">         // log...用同等的 Bean 覆盖旧的 Bean，这里指的是 equals 方法返回 true 的 Bean</span><br><span class="line">      &#125;</span><br><span class="line">      // 覆盖</span><br><span class="line">      this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line">      // 判断是否已经有其他的 Bean 开始初始化了.</span><br><span class="line">      // 注意，&quot;注册Bean&quot; 这个动作结束，Bean 依然还没有初始化，我们后面会有大篇幅说初始化过程，</span><br><span class="line">      // 在 Spring 容器启动的最后，会 预初始化 所有的 singleton beans</span><br><span class="line">      if (hasBeanCreationStarted()) &#123;</span><br><span class="line">         // Cannot modify startup-time collection elements anymore (for stable iteration)</span><br><span class="line">         synchronized (this.beanDefinitionMap) &#123;</span><br><span class="line">            this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">            List&lt;String&gt; updatedDefinitions = new ArrayList&lt;String&gt;(this.beanDefinitionNames.size() + 1);</span><br><span class="line">            updatedDefinitions.addAll(this.beanDefinitionNames);</span><br><span class="line">            updatedDefinitions.add(beanName);</span><br><span class="line">            this.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">            if (this.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">               Set&lt;String&gt; updatedSingletons = new LinkedHashSet&lt;String&gt;(this.manualSingletonNames);</span><br><span class="line">               updatedSingletons.remove(beanName);</span><br><span class="line">               this.manualSingletonNames = updatedSingletons;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">         // 最正常的应该是进到这个分支。</span><br><span class="line"></span><br><span class="line">         // 将 BeanDefinition 放到这个 map 中，这个 map 保存了所有的 BeanDefinition</span><br><span class="line">         this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">         // 这是个 ArrayList，所以会按照 bean 配置的顺序保存每一个注册的 Bean 的名字</span><br><span class="line">         this.beanDefinitionNames.add(beanName);</span><br><span class="line">         // 这是个 LinkedHashSet，代表的是手动注册的 singleton bean，</span><br><span class="line">         // 注意这里是 remove 方法，到这里的 Bean 当然不是手动注册的</span><br><span class="line">         // 手动指的是通过调用以下方法注册的 bean ：</span><br><span class="line">         //     registerSingleton(String beanName, Object singletonObject)</span><br><span class="line">         // 这不是重点，解释只是为了不让大家疑惑。Spring 会在后面&quot;手动&quot;注册一些 Bean，</span><br><span class="line">         // 如 &quot;environment&quot;、&quot;systemProperties&quot; 等 bean，我们自己也可以在运行时注册 Bean 到容器中的</span><br><span class="line">         this.manualSingletonNames.remove(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      // 这个不重要，在预初始化的时候会用到，不必管它。</span><br><span class="line">      this.frozenBeanDefinitionNames = null;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (oldBeanDefinition != null || containsSingleton(beanName)) &#123;</span><br><span class="line">      resetBeanDefinition(beanName);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从启动Spring容器到执行完注册bean，总结一下：到这里已经初始化了 Bean 容器，<bean /> 配置也相应的转换为了一个个 BeanDefinition，然后注册了各个 BeanDefinition 到注册中心，并且发送了注册事件。</p>
<h6 id="准备-Bean-容器-prepareBeanFactory"><a href="#准备-Bean-容器-prepareBeanFactory" class="headerlink" title="准备 Bean 容器: prepareBeanFactory"></a>准备 Bean 容器: prepareBeanFactory</h6><p>Spring 把我们在 xml 配置的 bean 都注册以后，会”手动”注册一些特殊的 bean</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Configure the factory&#x27;s standard context characteristics,</span><br><span class="line"> * such as the context&#x27;s ClassLoader and post-processors.</span><br><span class="line"> * @param beanFactory the BeanFactory to configure</span><br><span class="line"> */</span><br><span class="line">protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">   // 设置 BeanFactory 的类加载器，我们知道 BeanFactory 需要加载类，也就需要类加载器，</span><br><span class="line">   // 这里设置为加载当前 ApplicationContext 类的类加载器</span><br><span class="line">   beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line"></span><br><span class="line">   // 设置 BeanExpressionResolver</span><br><span class="line">   beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">   // </span><br><span class="line">   beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));</span><br><span class="line"></span><br><span class="line">   // 添加一个 BeanPostProcessor，这个 processor 比较简单：</span><br><span class="line">   // 实现了 Aware 接口的 beans 在初始化的时候，这个 processor 负责回调，</span><br><span class="line">   // 这个我们很常用，如我们会为了获取 ApplicationContext 而 implement ApplicationContextAware</span><br><span class="line">   // 注意：它不仅仅回调 ApplicationContextAware，</span><br><span class="line">   //   还会负责回调 EnvironmentAware、ResourceLoaderAware 等，看下源码就清楚了</span><br><span class="line">   beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));</span><br><span class="line"></span><br><span class="line">   // 下面几行的意思就是，如果某个 bean 依赖于以下几个接口的实现类，在自动装配的时候忽略它们，</span><br><span class="line">   // Spring 会通过其他方式来处理这些依赖。</span><br><span class="line">   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 下面几行就是为特殊的几个 bean 赋值，如果有 bean 依赖了以下几个，会注入这边相应的值，</span><br><span class="line">    * 之前我们说过，&quot;当前 ApplicationContext 持有一个 BeanFactory&quot;，这里解释了第一行。</span><br><span class="line">    * ApplicationContext 还继承了 ResourceLoader、ApplicationEventPublisher、MessageSource</span><br><span class="line">    * 所以对于这几个依赖，可以赋值为 this，注意 this 是一个 ApplicationContext</span><br><span class="line">    * 那这里怎么没看到为 MessageSource 赋值呢？那是因为 MessageSource 被注册成为了一个普通的 bean</span><br><span class="line">    */</span><br><span class="line">   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">   beanFactory.registerResolvableDependency(ResourceLoader.class, this);</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationContext.class, this);</span><br><span class="line"></span><br><span class="line">   // 这个 BeanPostProcessor 也很简单，在 bean 实例化后，如果是 ApplicationListener 的子类，</span><br><span class="line">   // 那么将其添加到 listener 列表中，可以理解成：注册 事件监听器</span><br><span class="line">   beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));</span><br><span class="line"></span><br><span class="line">   // 这里涉及到特殊的 bean，名为：loadTimeWeaver，这不是我们的重点，忽略它</span><br><span class="line">   // tips: ltw 是 AspectJ 的概念，指的是在运行期进行织入，这个和 Spring AOP 不一样，</span><br><span class="line">   //    感兴趣的读者请参考我写的关于 AspectJ 的另一篇文章 https://www.javadoop.com/post/aspectj</span><br><span class="line">   if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">      // Set a temporary ClassLoader for type matching.</span><br><span class="line">      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 从下面几行代码我们可以知道，Spring 往往很 &quot;智能&quot; 就是因为它会帮我们默认注册一些有用的 bean，</span><br><span class="line">    * 我们也可以选择覆盖</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">   // 如果没有定义 &quot;environment&quot; 这个 bean，那么 Spring 会 &quot;手动&quot; 注册一个</span><br><span class="line">   if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line">   // 如果没有定义 &quot;systemProperties&quot; 这个 bean，那么 Spring 会 &quot;手动&quot; 注册一个</span><br><span class="line">   if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">   &#125;</span><br><span class="line">   // 如果没有定义 &quot;systemEnvironment&quot; 这个 bean，那么 Spring 会 &quot;手动&quot; 注册一个</span><br><span class="line">   if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring 对一些特殊的 bean 进行了处理,初始化所有的 singleton beans</p>
<p>剩下的就是初始化 singleton beans 了，我们知道它们是单例的，如果没有设置懒加载，那么 Spring 会在接下来初始化所有的 singleton beans。</p>
<p>AbstractApplicationContext.java 834行</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 初始化剩余的 singleton beans</span><br><span class="line">protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line"></span><br><span class="line">   // 首先，初始化名字为 conversionService 的 Bean。本着送佛送到西的精神，我在附录中简单介绍了一下 ConversionService，因为这实在太实用了</span><br><span class="line">   // 什么，看代码这里没有初始化 Bean 啊！</span><br><span class="line">   // 注意了，初始化的动作包装在 beanFactory.getBean(...) 中，这里先不说细节，先往下看吧</span><br><span class="line">   if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">      beanFactory.setConversionService(</span><br><span class="line">            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // Register a default embedded value resolver if no bean post-processor</span><br><span class="line">   // (such as a PropertyPlaceholderConfigurer bean) registered any before:</span><br><span class="line">   // at this point, primarily for resolution in annotation attribute values.</span><br><span class="line">   if (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">      beanFactory.addEmbeddedValueResolver(new StringValueResolver() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public String resolveStringValue(String strVal) &#123;</span><br><span class="line">            return getEnvironment().resolvePlaceholders(strVal);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 先初始化 LoadTimeWeaverAware 类型的 Bean</span><br><span class="line">   // 之前也说过，这是 AspectJ 相关的内容，放心跳过吧</span><br><span class="line">   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);</span><br><span class="line">   for (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">      getBean(weaverAwareName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // Stop using the temporary ClassLoader for type matching.</span><br><span class="line">   beanFactory.setTempClassLoader(null);</span><br><span class="line"></span><br><span class="line">   // 没什么别的目的，因为到这一步的时候，Spring 已经开始预初始化 singleton beans 了，</span><br><span class="line">   // 肯定不希望这个时候还出现 bean 定义解析、加载、注册。</span><br><span class="line">   beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">   // 开始初始化</span><br><span class="line">   beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


</div></div>
    <aside id="sidebar" class="alignright">
  

  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/java/">java</a><small>1</small></li>
  
    <li><a href="/tags/%E7%AE%97%E6%B3%95/">算法</a><small>2</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2023 comin-lin
  
</div>
<div class="clearfix"></div></footer>
  
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/jquery.imagesloaded.min.js"></script>


<script src="/js/gallery.js"></script>





</body>
</html>
