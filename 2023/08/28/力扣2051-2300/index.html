<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  
  <title>力扣2051-2300 | comin-lin&#39;s blog</title>
  <meta name="author" content="comin-lin">
  
  <meta name="description" content="子数组最小乘积的最大值单调栈+前缀和使用单调栈预处理左边更小值和右边更小值出现的位置遍历数组，对于每个nums[i]计算出以nums[i]为最小值时的最长子数组的分数，维护最大值作为答案

最大相等频率哈希表+模拟+分类讨论遍历数组，使用一个哈希表统计每个元素及其出现次数，另一个哈希表统计频率以及该">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="力扣2051-2300"/>
  <meta property="og:site_name" content="comin-lin&#39;s blog"/>

  
    <meta property="og:image" content=""/>
  

  <link rel="shortcut icon" href="/favicon.png">
  
  
<link rel="stylesheet" href="/css/style.css">

  <!--[if lt IE 9]><script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script><![endif]-->
  

<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">comin-lin&#39;s blog</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article id="post-力扣2051-2300" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2023-08-28T02:49:56.000Z"><a href="/2023/08/28/%E5%8A%9B%E6%89%A32051-2300/">2023-08-28</a></time>
      
      
  
    <h1 class="p-name title" itemprop="headline name">力扣2051-2300</h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <ol start="1856">
<li><p>子数组最小乘积的最大值<br>单调栈+前缀和<br>使用单调栈预处理左边更小值和右边更小值出现的位置<br>遍历数组，对于每个nums[i]计算出以nums[i]为最小值时的最长子数组的分数，维护最大值作为答案</p>
</li>
<li><p>最大相等频率<br>哈希表+模拟+分类讨论<br>遍历数组，使用一个哈希表统计每个元素及其出现次数，另一个哈希表统计频率以及该频率出现的次数<br>如果频率只存在一种，如果频率为1或者出现次数为1则满足条件<br>如果频率只存在两种，如果其中一种是1且出现1次则满足条件，另外如果两个频率相差为1，且较大的频率出现次数为1，也满足条件<br>如果频率出现两种以上，不满足条件</p>
</li>
<li><p>树上最大得分和路径<br>DFS<br>bob到达0的路径只有一条，从bob出发进行dfs，得到bob经过每个节点的时间<br>alice从0出发，dfs枚举到达每个叶子节点的得分，维护最大得分作为答案</p>
</li>
<li><p>相似字符串组<br>并查集<br>数据量较小，枚举哪些字符串是相似的，使用并查集维护集合数量作为答案</p>
</li>
<li><p>统计所有可行路径<br>记忆化搜索dfs<br>枚举下一步可以到达的城市<br>注意每次到达finish都可以终止作为一条合法路径，也可以不终止继续行驶</p>
</li>
<li><p>最大子序列的分数<br>排序+优先队列<br>先把nums1和nums2绑定成二维数组data，再按照data[1]的值从大到小对二维数组排序<br>枚举nums2中的最小值为data[i][1]，使用优先队列维护最大的k个nums1的值，动态维护答案</p>
</li>
<li><p>邻位交换的最小次数<br>模拟<br>使用下一个排列算法得到目标妙数的序列，再模拟交换相邻位数字得到目标妙数，同时统计答案</p>
</li>
<li><p>最美子字符串的数目<br>前缀和+状态压缩<br>字符串只由前10个英文字母组成<br>使用10个二进制位的整数mask存储字母出现的奇偶情况前缀和，0代表偶数次，1代表奇数次<br>子字符串是连续的字符序列，若下标[left,right]的子字符串至多一个字母出现奇数次，那么有：<br>1.子字符串所有字母均出现偶数次：下标left处mask与下标right处mask相同<br>2.子字符串仅一个字母出现奇数次：下标left出mask与下标right处mask仅有一位不同<br>存储每一个前缀的字符串对应的mask出现的次数，对于每个mask状态枚举前面可以转移而来的前缀，如果出现过就统计次数加到答案中</p>
</li>
<li><p>到家的最少跳跃次数<br>BFS<br>注意每个位置最多可以经过两次，其中一次是前面的位置往后跳得到的，另一次是后面的位置往前跳得到的<br>题目限制不能连续后跳两次，BFS时应存储方向，避免连续后跳</p>
</li>
<li><p>最低加油次数<br>贪心+优先队列<br>判断每个加油站是否能到达，若可以则将该加油站的油量放入优先队列，若不能到达则从优先队列中取出最大的加油量进行使用<br>直到油量&gt;&#x3D;0或队列为空，若油量&gt;&#x3D;0说明该加油站仍可到达，反之无解</p>
</li>
<li><p>粉刷房子 III<br>三维动态规划<br>定义dp[i][j][k]表示[0,i]区间房子全部上色且下标为i的房子的颜色为j且[0,i]被划分为k个区间的最少花费</p>
</li>
<li><p>前往目标的最小代价<br>最短路径<br>建图，求start到target的最短路径<br>如果特殊路径的cost &gt; 曼哈顿距离，则记为曼哈顿距离<br>为 起点和终点 到 所有特殊点，以及 特殊路径的两端点 到 其他点，特殊路径的起点 到 特殊路径的终点 添加边</p>
</li>
<li><p>替换数组中的非互质数<br>栈<br>遍历数组，对于nums[i]，如果与栈顶元素满足gcd &gt; 1，不断将栈顶元素取出与nums[i]进行合并,nums[i]将变成lcm(nums[i],栈顶元素)<br>直到栈为空或者当前nums[i]无法再与栈顶元素合并，将nums[i]放入栈顶。最后栈中元素就是答案</p>
</li>
<li><p>绝对值表达式的最大值<br>数学<br>将目标表达式转化为关于i，j的函数|f(i)-f(j)|，对于f(i)可能的情况有以下四种：<br>arr1[i]+arr2[i]+i<br>arr1[i]+arr2[i]-i<br>arr1[i]-arr2[i]+i<br>arr1[i]-arr2[i]-i<br>求出四种可能的最大值作为答案</p>
</li>
<li><p>添加边使所有节点度数都为偶数<br>分类讨论<br>建图，统计度数为奇数的点的个数odd.size()，简称size<br>如果size为0，返回true<br>如果size为2，且这两个点没有边，可以连一条边后满足条件，返回true<br>如果size为2，且这两个点有边，如果能找到一个点i与这两个点都没有边，那么添加两条边后满足条件，返回true<br>如果size为4，将这四个点记为a，b，c，d：<br>如果a和b没有边 且 c和d没有边 分别添加边后满足条件，返回true<br>如果a和c没有边 且 b和d没有边 同上<br>如果a和d没有边 且 b和c没有边 同上<br>其他情况无法满足条件，返回false</p>
</li>
<li><p>英雄的力量<br>排序+数学 贡献法<br>选取与顺序无关，对数组进行排序<br>遍历数组，对于每个nums[i]，把nums[i]作为最大值，考虑对答案的贡献<br>推出计算式，对每个nums[i]计算贡献值，累加得到答案</p>
</li>
<li><p>将数组排序的最少替换次数<br>贪心+数学<br>倒序遍历数组，维护目前出现的最小值min<br>若nums[i]大于min，则将nums[i]进行拆解，拆解后最小值应尽可能大</p>
</li>
<li><p>摘水果<br>前缀和+枚举<br>枚举：<br>1.先向右走i步，再向左走（k-i）步的情况<br>2.先向左走i步，再向右走（k-i）步的情况<br>使用前缀和快速求出某个区间内的水果数量</p>
</li>
<li><p>查找给定哈希值的子串<br>数学+大数<br>对于子串[i,i+k-1]的哈希值，通过哈希表达式比较，发现可由[i+1,i+k-1+1]在 O(1) 时间内计算得出<br>倒序计算每个长度为k的哈希值，找到目标哈希值则返回答案<br>计算数字较大，可使用BigInteger防止溢出</p>
</li>
<li><p>使序列递增的最小交换次数<br>动态规划<br>只能交换相同下标的元素，题目保证有解<br>定义dp[i][0]表示到下标i为止让两个数组严格递增,且下标i不进行交换的最小交换次数<br>定义dp[i][1]表示到下标i为止让两个数组严格递增,且下标i进行交换的最小交换次数</p>
</li>
<li><p>使序列递增的最小交换次数<br>动态规划<br>定义dp[i][0]表示到下标i为止，下标i不进行交换的最小交换次数<br>定义dp[i][1]表示到下标i为止，下标i进行交换的最小交换次数</p>
</li>
<li><p>考场就座<br>枚举<br>使用有序集合TreeSet维护有人的座位，编号为n-1的座位需要特判<br>调用seat时会枚举每两个座位中间的位置，维护离左右有人位置最远的空位置作为答案</p>
</li>
<li><p>翻转对<br>归并排序+二分<br>进行归并排序分治处理区间，枚举右部分区间，在左部分区间进行二分查找满足条件的元素个数，累加答案</p>
</li>
<li><p>执行乘法运算的最大分数<br>动态规划<br>定义dp[i][j]表示在nums中取前i个数字和后j个数字能得到的最大分数<br>初始化：dp[0][0]&#x3D;0,dp[0][i]由dp[0][i-1]转移而来，dp[i][0]由dp[i-1][0]转移而来<br>状态转移：dp[i][j]由dp[i-1][j]和dp[i][j-1]转移而来<br>由于答案可能为负数，ans初始化为Integer.MIN_VALUE 枚举选择前i个，则从后面取m-i个，维护最大分数</p>
</li>
<li><p>使网格图至少有一条有效路径的最小代价<br>最短路径<br>使用dijkstra算法求出起点到终点的最短距离即为答案<br>对于一个格子在四个方向上的相邻格子，只有grid与对应方向相同时到达该相邻格子的距离为0，其他情况距离为1</p>
</li>
<li><p>统计同位异构字符串数目<br>组合计数+小费马定理求逆元<br>每个单词的排列是独立的，计算出每个单词的总排列数进行相乘得到答案<br>对于一个单词str[i] 长度为len 排列总数为(len的阶乘)&#x2F;(26个字母的出现个数的阶乘的累乘) 记分母为a，分子为b<br>现在需要计算(a&#x2F;b)%mod,对大数除法求余而言存在精度问题，使用小费马定理求逆元将(a&#x2F;b)%mod转化为a*pow(b,m-2)%mod<br>可以使用上述等式的前提有两个<br>1.mod是质数（本题中mod为1e97，是质数）<br>2.a不能被m整除（在计算a时，将a不断对m求余可满足这个条件）</p>
</li>
<li><p>整数拆分<br>数学+贪心<br>对于正整数n，拆分出来的正整数个数越多，乘积越大<br>由于k&gt;&#x3D;2，n为2或n为3时单独讨论<br>n&gt;&#x3D;4时，讨论n对3取余的余数mod：<br>mod为0，将n拆成 n&#x2F;3 个 3 得到最大乘积<br>mod为1，将n拆成(n-4)&#x2F;3 个 3 和 2 个 2 得到最大乘积<br>mod为2，将n拆成(n-2)&#x2F;3 个 3 和 1 个 2 得到最大乘积</p>
</li>
<li><p>好因子的最大数目<br>数学+贪心<br>本质上与 343. 整数拆分 大致相同，343这题要求至少拆为两个数，本题可以不拆<br>给定n，需要构造一个整数num，num可以分解为一些已去重的质因数a1,a2,a3….<br>设a1有b1个，a2有b2个，a3有b3个…. 需要满足b1+b2+b3….&#x3D;n<br>好因子由a1，a2，a3…分别取不同个数得来的，a1，a2，a3….具体取什么值并不重要，只需考虑如何把m拆成一些数b1，b2，b3….<br>因此答案就是求b1<em>b2</em>b3….的最大值，题目等价于拆m使得拆出来的数相乘得到最大值</p>
</li>
<li><p>使子数组元素和相等<br>分组+中位数贪心+裴蜀定理<br>假设数组不循环，对于子数组[i,i+k-1]，与子数组[i+1,i+k]的元素总和需要相等,则有：nums[i]&#x3D;nums[i+k]，整个数组被划分为k个组，组内元素值相等<br>但数组是循环数组，那么有周期n，n为数组长度，同时有周期k，由裴蜀定理可得数组必定有周期gcd(n,k)<br>因此将数组分为gcd(n,k)组。对于一组元素，要通过操作变成相等，有结论：变成中位数的操作次数最少，分组计算运算次数得到答案</p>
</li>
<li><p>N 次操作后的最大分数和<br>状态压缩+记忆化搜索<br>dfs(status,index,nums) status表示已选数字 index表示已选次数</p>
</li>
<li><p>优质数对的数目<br>等价转换+枚举<br>结论：bitCount(x|y)+bitCount(x&amp;y)&#x3D;bitCount(x)+bitCount(y)<br>优质数对(x,y)只计一次，因此数组中有多个x和多个y冗余，先对数组进行去重<br>使用map统计去重后的数组每个元素的bitCount以及出现次数<br>双重循环枚举bitCount1和bitCount2，满足相加&gt;&#x3D;k时根据乘法原理统计到答案中</p>
</li>
<li><p>使数组相似的最少操作次数<br>排序+贪心<br>题目保证有解 对数组进行排序 贪心地将nums中较小的数字变成target中较小的数字能得到最少操作次数<br>由于奇数和偶数不能相互转换，因此需要分为奇、偶两组进行计算<br>当奇偶性相同时nums[i]与target[i]最少差距为2<br>对于同奇偶的两个数字，先除4得到操作次数，如果对4求余为2，额外记录差距为2的个数cnt，注意cnt在奇偶两组是共享的，最后加上cnt&#x2F;2次</p>
</li>
<li><p>猜猜这个单词<br>启发式极小化极大算法猜测单词</p>
</li>
<li><p>从第一个节点出发到最后一个节点的受限路径数<br>最短路径+记忆化dfs<br>将节点映射到[0,n-1],使用dijkstra算法求出n-1到其他点的最短路径<br>从0开始dfs搜索到达n-1的受限路径数</p>
</li>
<li><p>将数组分成三个子数组的方案数<br>前缀和+二分<br>使用前缀和快速计算区间总和<br>将数组拆分为[0,i] [i+1,j] [j,n-1]<br>固定i，j的取值范围为[i+1,n-2]：<br>二分查找最小的j满足sum(0,i)&lt;&#x3D;sum(i+1,j)，记最小的j为min<br>二分查找最大的j满足sum(i+1,j)&lt;&#x3D;sum(j+1,n-1)，记最大的j为max<br>如果min和max都是合法的，那么ans+&#x3D;max-min+1</p>
</li>
<li><p>奇偶跳<br>预处理+记忆化dfs<br>使用TreeMap&lt;Integer,TreeSet<Integer>&gt; 存储数字和出现过的下标，得到每个下标的下一次奇数跳跃到达的位置和下一次偶数跳跃到达的位置<br>对每个下标进行dfs，判断最终能否到达数组末尾</p>
</li>
<li><p>打家劫舍 IV<br>二分<br>二分查找最小的窃取能力</p>
</li>
<li><p>第 K 条最小指令<br>动态规划+组合计数<br>V&gt;H，对于一个位置index，如果放V，则所有在index位置放H的字符串的字典序都比它小，比它小的字符串的总数有 （组合数：从h+v-1中取h-1个）<br>使用动态规划来计算组合数，dp[i][j]表示从i中取j个的组合数数量<br>根据k与dp值的大小依次确定每个位置放V还是放H</p>
</li>
<li><p>构建字典序最大的可行序列<br>dfs+回溯<br>数据量较小，按题意进行dfs+回溯，枚举每个位置填的数</p>
</li>
<li><p>两个线段获得的最多奖品<br>滑动窗口+动态规划<br>定义dp[i]表示下标i之前一条线段可获得的最多奖品数量<br>维护满足条件的一条线段[left,right]，每次得到这样一条线段时，用right-left+1+dp[left]来更新答案<br>同时dp[right+1]&#x3D;max(dp[right],right-left+1)</p>
</li>
<li><p>通过给定词典构造目标字符串的方案数<br>记忆化dfs<br>dfs(index,k)表示当前正在寻找target的index下标，当前words中被限制的起始位置为k<br>index&gt;&#x3D;target.length()时说明找到一种可行方案 k&gt;&#x3D;words[0].length()时说明当前状态无解</p>
</li>
<li><p>最近的房间<br>排序+有序列表<br>对房间面积从大到小排序，对查询按至少需要的面积从大到小排序<br>遍历排序后的查询，把所有满足面积&gt;&#x3D;当前minSize的房间的id放入有序列表TreeSet中<br>对每次查询，调用有序列表的floor和ceiling获取距离当前preferred最近的id，检查是否合法，填入本次查询的答案</p>
</li>
<li><p>并行课程 II<br>状态压缩+动态规划<br>对于每个状态i，先枚举状态valid（不包含任何i的前置课程），如果valid课程数&lt;&#x3D;k，dp[i]可由dp[i ^ valid] + 1转移得到<br>否则枚举valid的子集sub，dp[i]由最小的dp[i ^ sub] + 1转移得到</p>
</li>
<li><p>并行课程 III<br>记忆化dfs<br>dfs(i)表示完成课程i最少月份数，取最大的dfs(i)作为答案<br>对于一个课程i，如果没有前置课程，完成时间为time[i]<br>如果有前置课程，则完成时间为max(dfs(pre))+time[i]</p>
</li>
<li><p>使数组连续的最少操作数<br>去重排序+双指针<br>先对nums进行去重并排序，枚举以每个nums[i]为起点使数组连续的最少操作数<br>以nums[i]开头，nums[i]+all-1结尾时，使用指针p找出nums中满足值在该区间内的元素个数cnt，操作次数为all-cnt</p>
</li>
<li><p>检查是否有合法括号字符串路径<br>记忆化BFS+剪枝<br>容易想到BFS解法，存储到每个位置时括号的状态，令左括号值为1，右括号值为-1，可能合法的括号字符串始终有值&gt;&#x3D;0，到达终点时合法的字符串值&#x3D;&#x3D;0<br>剪枝：搜索到(i,j)位置时，若剩余格子数目小于当前左右括号之间的差值，后续不可能找到合法括号序列<br>使用三维数组cache来存储某状态是否已访问过，同一个下标(x,y)同一个字符串值val只访问一次，对应cache[x][y][val]</p>
</li>
<li><p>按位与为零的三元组<br>枚举<br>题目需要求nums[i]&amp;nums[j]&amp;nums[k]等于0的三元组个数，可以使用双重循环预处理每个nums[i]&amp;nums[j]的出现次数，存入哈希表中<br>再枚举nums[k]，从哈希表中获取key和value，若nums[k]&amp;key&#x3D;&#x3D;0，则ans+&#x3D;value</p>
</li>
<li><p>查找集群内的关键连接<br>tarjan算法<br>模板题</p>
</li>
<li><p>石子游戏 V<br>动态规划+前缀和<br>定义dp[i][j]表示在区间[i,j]的石子中Alice能得到的最大分数<br>初始化：所有dp[i][i]表示剩余一个石子，游戏结束，Alice得分为0，因此dp[i][i]初始化为0<br>对每个区间[i,j]枚举割点k，分割为[i,k] [k+1,j] 通过前缀和快速获取两部分的值a，b<br>如果a&lt;b dp[i][j]由a+dp[i,k]转移而来<br>如果a&gt;b dp[i][j]由b+dp[k+1][j]转移而来<br>如果a&#x3D;&#x3D;b Alice自行选择，dp[i][j]由max(a+dp[i,k],b+dp[k+1][j])转移而来</p>
</li>
<li><p>不同骰子序列的数目<br>动态规划<br>定义dp[i][j][k]表示满足条件，长度为i，倒数第二个元素为j，最后一个元素为k的序列数目<br>n为1时，返回6<br>初始化长度为2的序列数目，枚举j、k，若j!&#x3D;k且gcd(j,k)&#x3D;&#x3D;1，则初始化dp[2][j][k]为1<br>从长度3开始计算到长度n，对于每个长度，枚举后两个位置j、k，枚举上一个排列的后两个位置t、j，dp[i][j][k]由所有合法的dp[i-1][t][j]相加得到<br>最后累加所有合法的dp[n][j][k]得到答案</p>
</li>
</ol>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


</div></div>
    <aside id="sidebar" class="alignright">
  

  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/java/">java</a><small>1</small></li>
  
    <li><a href="/tags/%E7%AE%97%E6%B3%95/">算法</a><small>2</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2023 comin-lin
  
</div>
<div class="clearfix"></div></footer>
  
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/jquery.imagesloaded.min.js"></script>


<script src="/js/gallery.js"></script>





</body>
</html>
