

  <!DOCTYPE html>
  <html lang="zh-CN">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="renderer" content="webkit">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta name="description" content= >
  <meta name="keywords" content=hexo,theme,MiHoYo >

  <head>
    <title>
      力扣2051-2300 [ comin-lin&#39;s blog ]
    </title>
  <meta name="generator" content="Hexo 6.3.0"></head>

  <body>

    <link rel="stylesheet" href="/css/header.css">
<div class="header">
  <div class="logo">
    <span class="pull-left">
      <a id="site-name" href="/">
        comin-lin&#39;s blog
      </a>
    </span>
  </div>
  <ul class="nav-list">
    
      <li>
        <a href="/">
          首页
        </a>
      </li>
      
  </ul>
</div>

      <!--<link rel="stylesheet" href="/css/top-header.css">
<div id="top-bar" class="fixed">

  <a class="goto-top" href="#"></a>
  <ul class="bar-list bar-list-1">
    
      <li>
        <p>
          <a href="/">
            <text class="bar-text bar-p1">
              首页
            </text>
            <text class="bar-text bar-p2"></text>
          </a>
          <text class="bar-p3">/</text>
        </p>
      </li>
      
  </ul>
</div>-->

        <div id="content-outer">
          <div class="content-inner">
            <link rel="stylesheet" href="/css/post.css">
<div class="posts">
  <a href="/index.html"><i class="fa fa-home
replay-btn" aria-hidden="true"></i></a>
  <div class="post-title">
    <p>
      力扣2051-2300
    </p>
    <hr>
  </div>
  <div class="post-content">
    <p>1856.子数组最小乘积的最大值<br>单调栈+前缀和<br>使用单调栈预处理左边更小值和右边更小值出现的位置<br>遍历数组，对于每个nums[i]计算出以nums[i]为最小值时的最长子数组的分数，维护最大值作为答案</p>
<p>1224.最大相等频率<br>哈希表+模拟+分类讨论<br>遍历数组，使用一个哈希表统计每个元素及其出现次数，另一个哈希表统计频率以及该频率出现的次数<br>如果频率只存在一种，如果频率为1或者出现次数为1则满足条件<br>如果频率只存在两种，如果其中一种是1且出现1次则满足条件，另外如果两个频率相差为1，且较大的频率出现次数为1，也满足条件<br>如果频率出现两种以上，不满足条件</p>
<p>2467.树上最大得分和路径<br>DFS<br>bob到达0的路径只有一条，从bob出发进行dfs，得到bob经过每个节点的时间<br>alice从0出发，dfs枚举到达每个叶子节点的得分，维护最大得分作为答案</p>
<p>839.相似字符串组<br>并查集<br>数据量较小，枚举哪些字符串是相似的，使用并查集维护集合数量作为答案</p>
<p>1575.统计所有可行路径<br>记忆化搜索dfs<br>枚举下一步可以到达的城市<br>注意每次到达finish都可以终止作为一条合法路径，也可以不终止继续行驶</p>
<p>2542.最大子序列的分数<br>排序+优先队列<br>先把nums1和nums2绑定成二维数组data，再按照data[1]的值从大到小对二维数组排序<br>枚举nums2中的最小值为data[i][1]，使用优先队列维护最大的k个nums1的值，动态维护答案</p>
<p>1850.邻位交换的最小次数<br>模拟<br>使用下一个排列算法得到目标妙数的序列，再模拟交换相邻位数字得到目标妙数，同时统计答案</p>
<p>1915.最美子字符串的数目<br>前缀和+状态压缩<br>字符串只由前10个英文字母组成<br>使用10个二进制位的整数mask存储字母出现的奇偶情况前缀和，0代表偶数次，1代表奇数次<br>子字符串是连续的字符序列，若下标[left,right]的子字符串至多一个字母出现奇数次，那么有：<br>1.子字符串所有字母均出现偶数次：下标left处mask与下标right处mask相同<br>2.子字符串仅一个字母出现奇数次：下标left出mask与下标right处mask仅有一位不同<br>存储每一个前缀的字符串对应的mask出现的次数，对于每个mask状态枚举前面可以转移而来的前缀，如果出现过就统计次数加到答案中</p>
<p>1654.到家的最少跳跃次数<br>BFS<br>注意每个位置最多可以经过两次，其中一次是前面的位置往后跳得到的，另一次是后面的位置往前跳得到的<br>题目限制不能连续后跳两次，BFS时应存储方向，避免连续后跳</p>
<p>871.最低加油次数<br>贪心+优先队列<br>判断每个加油站是否能到达，若可以则将该加油站的油量放入优先队列，若不能到达则从优先队列中取出最大的加油量进行使用<br>直到油量&gt;&#x3D;0或队列为空，若油量&gt;&#x3D;0说明该加油站仍可到达，反之无解</p>
<p>1473.粉刷房子 III<br>三维动态规划<br>定义dp[i][j][k]表示[0,i]区间房子全部上色且下标为i的房子的颜色为j且[0,i]被划分为k个区间的最少花费</p>
<p>2662.前往目标的最小代价<br>最短路径<br>建图，求start到target的最短路径<br>如果特殊路径的cost &gt; 曼哈顿距离，则记为曼哈顿距离<br>为 起点和终点 到 所有特殊点，以及 特殊路径的两端点 到 其他点，特殊路径的起点 到 特殊路径的终点 添加边</p>
<p>2197.替换数组中的非互质数<br>栈<br>遍历数组，对于nums[i]，如果与栈顶元素满足gcd &gt; 1，不断将栈顶元素取出与nums[i]进行合并,nums[i]将变成lcm(nums[i],栈顶元素)<br>直到栈为空或者当前nums[i]无法再与栈顶元素合并，将nums[i]放入栈顶。最后栈中元素就是答案</p>
<p>1131.绝对值表达式的最大值<br>数学<br>将目标表达式转化为关于i，j的函数|f(i)-f(j)|，对于f(i)可能的情况有以下四种：<br>arr1[i]+arr2[i]+i<br>arr1[i]+arr2[i]-i<br>arr1[i]-arr2[i]+i<br>arr1[i]-arr2[i]-i<br>求出四种可能的最大值作为答案</p>
<p>2508.添加边使所有节点度数都为偶数<br>分类讨论<br>建图，统计度数为奇数的点的个数odd.size()，简称size<br>如果size为0，返回true<br>如果size为2，且这两个点没有边，可以连一条边后满足条件，返回true<br>如果size为2，且这两个点有边，如果能找到一个点i与这两个点都没有边，那么添加两条边后满足条件，返回true<br>如果size为4，将这四个点记为a，b，c，d：<br>如果a和b没有边 且 c和d没有边 分别添加边后满足条件，返回true<br>如果a和c没有边 且 b和d没有边 同上<br>如果a和d没有边 且 b和c没有边 同上<br>其他情况无法满足条件，返回false</p>
<p>2681.英雄的力量<br>排序+数学 贡献法<br>选取与顺序无关，对数组进行排序<br>遍历数组，对于每个nums[i]，把nums[i]作为最大值，考虑对答案的贡献<br>推出计算式，对每个nums[i]计算贡献值，累加得到答案</p>
<p>2366.将数组排序的最少替换次数<br>贪心+数学<br>倒序遍历数组，维护目前出现的最小值min<br>若nums[i]大于min，则将nums[i]进行拆解，拆解后最小值应尽可能大</p>
<p>2106.摘水果<br>前缀和+枚举<br>枚举：<br>情况1.先向右走i步，再向左走（k-i）步的情况<br>情况2.先向左走i步，再向右走（k-i）步的情况<br>使用前缀和快速求出某个区间内的水果数量</p>
<p>注意奖励区间的长度不是固定的！<br>比如k&#x3D;5，先向右0步，再向左5步，区间[0,5]长度为5<br>如果先向右3步，再向左2步，向左没能返回起点，区间[0,3]长度为3</p>
<p>为什么不能只枚举情况1？<br>只枚举先向右，会漏掉一些先向左得到更好奖励的情况</p>
<p>2156.查找给定哈希值的子串<br>数学+大数<br>对于子串[i,i+k-1]的哈希值，通过哈希表达式比较，发现可由[i+1,i+k-1+1]在 O(1) 时间内计算得出<br>倒序计算每个长度为k的哈希值，找到目标哈希值则返回答案<br>计算数字较大，可使用BigInteger防止溢出</p>
<p>801.使序列递增的最小交换次数<br>动态规划<br>只能交换相同下标的元素，题目保证有解<br>定义dp[i][0]表示到下标i为止让两个数组严格递增,且下标i不进行交换的最小交换次数<br>定义dp[i][1]表示到下标i为止让两个数组严格递增,且下标i进行交换的最小交换次数</p>
<p>855.考场就座<br>枚举<br>使用有序集合TreeSet维护有人的座位，编号为n-1的座位需要特判<br>调用seat时会枚举每两个座位中间的位置，维护离左右有人位置最远的空位置作为答案</p>
<p>493.翻转对<br>归并排序+二分<br>进行归并排序分治处理区间，枚举右部分区间，在左部分区间进行二分查找满足条件的元素个数，累加答案</p>
<p>1770.执行乘法运算的最大分数<br>动态规划<br>定义dp[i][j]表示在nums中取前i个数字和后j个数字能得到的最大分数<br>初始化：dp[0][0]&#x3D;0,dp[0][i]由dp[0][i-1]转移而来，dp[i][0]由dp[i-1][0]转移而来<br>状态转移：dp[i][j]由dp[i-1][j]和dp[i][j-1]转移而来<br>由于答案可能为负数，ans初始化为Integer.MIN_VALUE 枚举选择前i个，则从后面取m-i个，维护最大分数</p>
<p>1368.使网格图至少有一条有效路径的最小代价<br>最短路径<br>使用dijkstra算法求出起点到终点的最短距离即为答案<br>对于一个格子在四个方向上的相邻格子，只有grid与对应方向相同时到达该相邻格子的距离为0，其他情况距离为1</p>
<p>2514.统计同位异构字符串数目<br>组合计数+小费马定理求逆元<br>每个单词的排列是独立的，计算出每个单词的总排列数进行相乘得到答案<br>对于一个单词str[i] 长度为len 排列总数为(len的阶乘)&#x2F;(26个字母的出现个数的阶乘的累乘) 记分母为a，分子为b<br>现在需要计算(a&#x2F;b)%mod,对大数除法求余而言存在精度问题，使用小费马定理求逆元将(a&#x2F;b)%mod转化为a*pow(b,m-2)%mod<br>可以使用上述等式的前提有两个<br>1.mod是质数（本题中mod为1e97，是质数）<br>2.a不能被m整除（在计算a时，将a不断对m求余可满足这个条件）</p>
<p>343.整数拆分<br>数学+贪心<br>对于正整数n，拆分出来的正整数个数越多，乘积越大<br>由于k&gt;&#x3D;2，n为2或n为3时单独讨论<br>n&gt;&#x3D;4时，讨论n对3取余的余数mod：<br>mod为0，将n拆成 n&#x2F;3 个 3 得到最大乘积<br>mod为1，将n拆成(n-4)&#x2F;3 个 3 和 2 个 2 得到最大乘积<br>mod为2，将n拆成(n-2)&#x2F;3 个 3 和 1 个 2 得到最大乘积</p>
<p>1808.好因子的最大数目<br>数学+贪心<br>本质上与 343.整数拆分 大致相同，343这题要求至少拆为两个数，本题可以不拆<br>给定n，需要构造一个整数num，num可以分解为一些已去重的质因数a1,a2,a3….<br>设a1有b1个，a2有b2个，a3有b3个….需要满足b1+b2+b3….&#x3D;n<br>好因子由a1，a2，a3…分别取不同个数得来的，a1，a2，a3….具体取什么值并不重要，只需考虑如何把m拆成一些数b1，b2，b3….<br>因此答案就是求b1<em>b2</em>b3….的最大值，题目等价于拆m使得拆出来的数相乘得到最大值</p>
<p>2607.使子数组元素和相等<br>分组+中位数贪心+裴蜀定理<br>假设数组不循环，对于子数组[i,i+k-1]，与子数组[i+1,i+k]的元素总和需要相等,则有：nums[i]&#x3D;nums[i+k]，整个数组被划分为k个组，组内元素值相等<br>但数组是循环数组，那么有周期n，n为数组长度，同时有周期k，由裴蜀定理可得数组必定有周期gcd(n,k)<br>因此将数组分为gcd(n,k)组。对于一组元素，要通过操作变成相等，有结论：变成中位数的操作次数最少，分组计算运算次数得到答案</p>
<p>1799.N 次操作后的最大分数和<br>状态压缩+记忆化搜索<br>dfs(status,index,nums) status表示已选数字 index表示已选次数</p>
<p>2354.优质数对的数目<br>等价转换+枚举<br>结论：bitCount(x|y)+bitCount(x&amp;y)&#x3D;bitCount(x)+bitCount(y)<br>优质数对(x,y)只计一次，因此数组中有多个x和多个y冗余，先对数组进行去重<br>使用map统计去重后的数组每个元素的bitCount以及出现次数<br>双重循环枚举bitCount1和bitCount2，满足相加&gt;&#x3D;k时根据乘法原理统计到答案中</p>
<p>2449.使数组相似的最少操作次数<br>排序+贪心<br>题目保证有解 对数组进行排序 贪心地将nums中较小的数字变成target中较小的数字能得到最少操作次数<br>由于奇数和偶数不能相互转换，因此需要分为奇、偶两组进行计算<br>当奇偶性相同时nums[i]与target[i]最少差距为2<br>对于同奇偶的两个数字，先除4得到操作次数，如果对4求余为2，额外记录差距为2的个数cnt，注意cnt在奇偶两组是共享的，最后加上cnt&#x2F;2次</p>
<p>843.猜猜这个单词<br>启发式极小化极大算法猜测单词</p>
<p>1786.从第一个节点出发到最后一个节点的受限路径数<br>最短路径+记忆化dfs<br>将节点映射到[0,n-1],使用dijkstra算法求出n-1到其他点的最短路径<br>从0开始dfs搜索到达n-1的受限路径数</p>
<p>1712.将数组分成三个子数组的方案数<br>前缀和+二分<br>使用前缀和快速计算区间总和<br>将数组拆分为[0,i] [i+1,j] [j,n-1]<br>固定i，j的取值范围为[i+1,n-2]：<br>二分查找最小的j满足sum(0,i)&lt;&#x3D;sum(i+1,j)，记最小的j为min<br>二分查找最大的j满足sum(i+1,j)&lt;&#x3D;sum(j+1,n-1)，记最大的j为max<br>如果min和max都是合法的，那么ans+&#x3D;max-min+1</p>
<p>975.奇偶跳<br>预处理+记忆化dfs<br>使用TreeMap&lt;Integer,TreeSet<Integer>&gt; 存储数字和出现过的下标，得到每个下标的下一次奇数跳跃到达的位置和下一次偶数跳跃到达的位置<br>对每个下标进行dfs，判断最终能否到达数组末尾</p>
<p>2560.打家劫舍 IV<br>二分<br>二分查找最小的窃取能力</p>
<p>1643.第 K 条最小指令<br>动态规划+组合计数<br>V&gt;H，对于一个位置index，如果放V，则所有在index位置放H的字符串的字典序都比它小，比它小的字符串的总数有 （组合数：从h+v-1中取h-1个）<br>使用动态规划来计算组合数，dp[i][j]表示从i中取j个的组合数数量<br>根据k与dp值的大小依次确定每个位置放V还是放H</p>
<p>1718.构建字典序最大的可行序列<br>dfs+回溯<br>数据量较小，按题意进行dfs+回溯，枚举每个位置填的数</p>
<p>2555.两个线段获得的最多奖品<br>滑动窗口+动态规划<br>定义dp[i]表示下标i之前一条线段可获得的最多奖品数量<br>维护满足条件的一条线段[left,right]，每次得到这样一条线段时，用right-left+1+dp[left]来更新答案<br>同时dp[right+1]&#x3D;max(dp[right],right-left+1)</p>
<p>1639.通过给定词典构造目标字符串的方案数<br>记忆化dfs<br>dfs(index,k)表示当前正在寻找target的index下标，当前words中被限制的起始位置为k<br>index&gt;&#x3D;target.length()时说明找到一种可行方案 k&gt;&#x3D;words[0].length()时说明当前状态无解</p>
<p>1847.最近的房间<br>排序+有序列表<br>对房间面积从大到小排序，对查询按至少需要的面积从大到小排序<br>遍历排序后的查询，把所有满足面积&gt;&#x3D;当前minSize的房间的id放入有序列表TreeSet中<br>对每次查询，调用有序列表的floor和ceiling获取距离当前preferred最近的id，检查是否合法，填入本次查询的答案</p>
<p>1494.并行课程 II<br>状态压缩+动态规划<br>对于每个状态i，先枚举状态valid（不包含任何i的前置课程），如果valid课程数&lt;&#x3D;k，dp[i]可由dp[i ^ valid] + 1转移得到<br>否则枚举valid的子集sub，dp[i]由最小的dp[i ^ sub] + 1转移得到</p>
<p>2050.并行课程 III<br>记忆化dfs<br>dfs(i)表示完成课程i最少月份数，取最大的dfs(i)作为答案<br>对于一个课程i，如果没有前置课程，完成时间为time[i]<br>如果有前置课程，则完成时间为max(dfs(pre))+time[i]</p>
<p>2009.使数组连续的最少操作数<br>去重排序+双指针<br>先对nums进行去重并排序，枚举以每个nums[i]为起点使数组连续的最少操作数<br>以nums[i]开头，nums[i]+all-1结尾时，使用指针p找出nums中满足值在该区间内的元素个数cnt，操作次数为all-cnt</p>
<p>2267.检查是否有合法括号字符串路径<br>记忆化BFS+剪枝<br>容易想到BFS解法，存储到每个位置时括号的状态，令左括号值为1，右括号值为-1，可能合法的括号字符串始终有值&gt;&#x3D;0，到达终点时合法的字符串值&#x3D;&#x3D;0<br>剪枝：搜索到(i,j)位置时，若剩余格子数目小于当前左右括号之间的差值，后续不可能找到合法括号序列<br>使用三维数组cache来存储某状态是否已访问过，同一个下标(x,y)同一个字符串值val只访问一次，对应cache[x][y][val]</p>
<p>982.按位与为零的三元组<br>枚举<br>题目需要求nums[i]&amp;nums[j]&amp;nums[k]等于0的三元组个数，可以使用双重循环预处理每个nums[i]&amp;nums[j]的出现次数，存入哈希表中<br>再枚举nums[k]，从哈希表中获取key和value，若nums[k]&amp;key&#x3D;&#x3D;0，则ans+&#x3D;value</p>
<p>1192.查找集群内的关键连接<br>tarjan算法<br>模板题</p>
<p>1563.石子游戏 V<br>动态规划+前缀和<br>定义dp[i][j]表示在区间[i,j]的石子中Alice能得到的最大分数<br>初始化：所有dp[i][i]表示剩余一个石子，游戏结束，Alice得分为0，因此dp[i][i]初始化为0<br>对每个区间[i,j]枚举割点k，分割为[i,k] [k+1,j] 通过前缀和快速获取两部分的值a，b<br>如果a&lt;b dp[i][j]由a+dp[i,k]转移而来<br>如果a&gt;b dp[i][j]由b+dp[k+1][j]转移而来<br>如果a&#x3D;&#x3D;b Alice自行选择，dp[i][j]由max(a+dp[i,k],b+dp[k+1][j])转移而来</p>
<p>2318.不同骰子序列的数目<br>动态规划<br>定义dp[i][j][k]表示满足条件，长度为i，倒数第二个元素为j，最后一个元素为k的序列数目<br>n为1时，返回6<br>初始化长度为2的序列数目，枚举j、k，若j!&#x3D;k且gcd(j,k)&#x3D;&#x3D;1，则初始化dp[2][j][k]为1<br>从长度3开始计算到长度n，对于每个长度，枚举后两个位置j、k，枚举上一个排列的后两个位置t、j，dp[i][j][k]由所有合法的dp[i-1][t][j]相加得到<br>最后累加所有合法的dp[n][j][k]得到答案</p>
<p>2193.得到回文串的最少操作次数<br>贪心<br>数据量较小，可直接模拟交换<br>解决[left,right]区间变成回文串：对于每个s[left]，找到距离右侧最近的相同字符s[i]，将s[i]换到s[right]的位置，变成解决[left+1,right-1]子问题<br>如果没有找到这样的s[i]，说明s[i]出现奇数次，模拟将其换到字符串最中间，解决[left+1,right]子问题<br>注意奇数次的s[i]不能先模拟换到中间，这样做接下来解决[left+1,right-1]子问题时会再次移动该s[i]，产生额外开销<br>因此遇到奇数次s[i]先记录交换到中间所需要的次数，等解决所有问题，即解决[left+1,right]子问题后再将其换到字符串最中间</p>
<p>1383.最大的团队表现值<br>排序+优先队列<br>构造二维数组data同时存每个工程师的速度和效率，将data按效率从高到低排序<br>遍历data数组，优先队列存放速度最大的前k个工程师的速度，同时使用sum维护优先队列中的速度之和<br>对于每个i，当data[i][1]为最低效率时，更新ans&#x3D;max(ans,sum*data[i][1])</p>
<p>2751.机器人碰撞<br>排序+栈模拟<br>对pos进行排序，使用栈进行模拟碰撞</p>
<p>2412.完成所有交易的初始最少钱数<br>思维<br>将交易分成loss亏损，earn盈利两组，有两种情况钱可能最少：<br>1.进行所有亏损的交易，其中能得到最大cashback的这笔交易的cashback还没得到时<br>2.进行所有亏损的交易，再进行盈利交易中最大cost的这笔交易，且对应的cashback还没得到时<br>取两种情况钱最少的情况就是需要的初始最少钱数</p>
<p>1049.最后一块石头的重量 II<br>动态规划 01背包<br>将题目转化为：一个数组nums，元素和为sum，现在需要取出一部分元素与另一部分元素取差，求差的最小值<br>要得到差的最小值，分出来的两部分值需要尽可能接近target&#x3D;sum&#x2F;2<br>定义dp[i][j]表示从前i个元素中取出一些元素，在元素和不超过j的情况下能得到的最大元素和<br>最后dp[n][target]就是最接近target的元素和，另一部分为sum-dp[n][target]，求两部分的差的绝对值作为答案</p>
<p>630.课程表 III<br>贪心+优先队列<br>对课程按截止时间从小到大排序，优先完成截止时间早的课程<br>使用优先队列保存完成的每个课程的持续时间duration，同时维护优先队列中所有课程需要的时间总和allTime<br>当完成课程i（duration_i,lastDay_i）后，allTime &gt; lastDay_i ，则需要从优先队列中取消掉占用时间最大的课程<br>最后优先队列中课程的数量就是答案</p>
<p>2402.会议室 III<br>优先队列+双堆模拟<br>使用两个优先队列分别保存空闲房间和使用中的房间的编号，模拟安排会议，记录每个房间的使用次数</p>
<p>2444.统计定界子数组的数目<br>枚举<br>遍历数组，维护上一个minK,maxK的位置preMin,preMax以及上一个超出[minK,maxK]范围的元素位置preUnValid<br>对于下标i，如果当前下标元素合法且preMin,preMax都出现过，则对答案的贡献为min(preMin,preMax)-preUnValid<br>如果下标i元素非法，重置preMin,preMax为-1，且更新preUnValid&#x3D;i</p>
<p>1976.到达目的地的方案数<br>最短路+优先队列<br>使用dijkstra算法计算到达终点的最短距离，同时维护以最短路径到达每个节点的方案数<br>注意：new PriorityQueue&lt;&gt;((o1,o2)-&gt;Long.compare(dis[o1],dis[o2]))<br>当修改了 dis 数组中的值时，优先队列中的元素不会及时更改顺序<br>在修改dis[v]值后，应remove(v)再add(v)</p>
<p>899.有序队列<br>思维<br>当k&#x3D;1时，可以不断改变字符串的首字符，将s复制一份，枚举每种情况，取字典序最小的作为答案<br>当k&gt;1时，可以得到任意顺序的字符串s，对s中的字符排序，得到最小字典序的字符串作为答案<br>原因：当k&gt;1时，可以选择字符串 s 中的任意两个相邻字母交换它们的顺序，重复这个过程直到得到任意顺序的字符串</p>
<p>778.水位上升的泳池中游泳<br>二分+BFS<br>将题目转化为：一条路径的开销是该路径经过的格子中的最大值，求到达终点的所有路径中的最小开销<br>二分查找最小开销，BFS判断能否到达终点</p>
<p>172.阶乘后的零<br>数学<br>每一个0都是由2因子和5因子组合得到，因此需要找到所有乘数中的2和5因子的个数，记为a，b<br>阶乘后的零个数就是min(a,b)个，由于5的因子永远少于2的因子的个数，因此统计因子5的个数即可</p>
<p>793.阶乘函数后 K 个零<br>二分+数学<br>二分查找阶乘后零的个数&gt;&#x3D;k+1的最小数，记为a<br>二分查找阶乘后零的个数&gt;&#x3D;k的最小数，记为b<br>答案为a-b</p>
<p>1970.你能穿过矩阵的最后一天<br>二分+BFS<br>二分查找能从矩阵第一行到达矩阵最后一行的最后一天</p>
<p>2430.对字母串可执行的最大删除数<br>动态规划<br>预处理出s的每个后缀之间的最长公共前缀长度<br>定义dp[i]表示[i,n-1]子串可执行的最大删除数，dp[0]作为答案</p>
<p>2812.找出最安全路径<br>二分+BFS<br>二分查找最大的安全系数</p>
<p>2749.得到整数零需要执行的最少操作数<br>枚举<br>枚举操作次数i，i最少为0，最多为60<br>对于操作次数i，问题转化为target&#x3D;num1-i*num2是否可以拆分为i个2^t(t可取[0,60])<br>如果target&lt;i 即使每个t都取最小的0，也无法完成拆分<br>否则获取target对应的二进制中1的数量count，如果i&gt;&#x3D;count则一定可以拆分，返回i<br>为什么i&gt;&#x3D;count时一定可以拆分？因为一个2^t 可以拆分为两个2^(t-1) 当i大于count时可以多拆分几次凑出i个2^t</p>
<p>2376.统计特殊整数（数位dp）<br>dfs+记忆化搜索<br>提交记录：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-special-integers/submissions/467426645/">https://leetcode.cn/problems/count-special-integers/submissions/467426645/</a></p>
<p>2842.统计一个字符串的 k 子序列美丽值最大的数目<br>贪心+组合数<br>统计字母出现次数，优先选择出现次数最大的字母组成子序列能得到最大美丽值<br>对于出现次数为key次的字符，有value个，如果value&gt;k 需要从value中取k个，否则可以全选<br>若全选 一共value种字符，每种字符都要选一个，而每种字符一共有key个 根据乘法原理 对答案的贡献为pow(key,value)<br>若从value中选取k个 对答案的贡献为pow(key,k) * comb(value,k) 其中comb函数用来求组合数</p>
<p>1937.扣分后的最大得分<br>动态规划<br>定义dp[i][j]表示到下标为i的行为止且下标为i的行选择下标为j的格子的最大得分<br>dp[i][j]由dp[i-1][j’]得到，分类讨论j’与j的关系<br>当j’&lt;&#x3D;j 时，Math.abs(j-j’) &#x3D; j-j’ 此时dp[i][j]&#x3D;max(dp[i-1][j’]-Math.abs(j-j’))&#x3D;max(dp[i-1][j’]+j’)-j<br>当j’&gt;j 时，Math.abs(j-j’)&#x3D;j’-j 同理dp[i][j]&#x3D;max(dp[i-1][j’]-j’)+j</p>
<p>1906.查询差绝对值的最小值<br>前缀和<br>注意到1 &lt;&#x3D; nums[i] &lt;&#x3D; 100，使用pre[][101]记录每个下标位置每个数字的个数<br>对于查询[left,right]，通过pre数组可以获取该区间内每个数字的个数，差绝对值的最小值只可能出现在相邻的数字之间<br>使用num维护上一个出现过的数字，当j出现的次数不为0时，res&#x3D;min(res,j-num)，最后res即为本次查询的答案</p>
<p>2088.统计农场中肥沃金字塔的数目<br>动态规划<br>定义dp[i][j]表示以格子(i,j)为顶部的最大金字塔高度<br>先考虑正金字塔的计算：从矩阵最后一行最后一列开始倒着遍历每个格子(i,j)<br>对于一个格子(i,j)如果是肥沃的，且(i+1,j-1)、(i+1,j)、(i+1,j+1)都是肥沃的，那么dp[i][j]&#x3D;min(dp下方三个格子)+1<br>最后累加所有dp值得到所有正金字塔的数量，上下翻转矩阵，再计算一遍dp，得到倒金字塔的数量，正、倒金字塔数量加起来作为答案</p>
<p>2768.黑格子的数目<br>哈希表<br>对于一个黑格子，记录受影响的四个块的左上角下标，存入哈希表中<br>遍历所有受影响的块，对每个块记录黑格子的数量</p>
<p>2781.最长合法子字符串的长度<br>滑动窗口<br>forbidden中的字符串长度最多为10<br>使用滑动窗口枚举最长合法字符串<br>对于某个子串，遍历前10个字符和后10个字符，使用哈希表快速检查是否合法</p>
<p>2616.最小化数对的最大差值<br>排序+二分<br>对数组排序后二分查找最大差值的最小值</p>
<p>2746.字符串连接删减字母<br>记忆化dfs<br>定义dfs(index,left,right)表示：<br>从下标index开始直到连接完毕，之前字符串的首字符为left，尾字符为right对答案的总贡献<br>答案：dfs(1,words[0][0],words[0][-1])+len(words[0])</p>
<p>1944.队列中可以看到的人数<br>倒序遍历+单调栈<br>倒序遍历队列，使用高度单调递减栈（存放下标）维护右侧可以看到的人<br>对于下标i，栈顶元素top，如果h[i]&lt;&#x3D;h[top]，i看不到top右侧的人，跳出循环<br>如果h[i]&gt;h[top]，则i左侧的人也看不到top及top右侧的人，将top出栈</p>
<p>2209.用地毯覆盖后的最少白色砖块<br>动态规划<br>定义dp[i][j] 表示使用i条地毯，覆盖到下标为j的砖块时所剩余的最少白色砖数<br>使用0条地毯的情况：dp[0][i]&#x3D;dp[0][i-1]+floor.charAt(i)-‘0’;<br>当j&lt;i<em>carpetLen时，dp[i][j]&#x3D;0，可以完全覆盖<br>当j&gt;&#x3D;i</em>carpetLen时，dp[i][j]&#x3D;Math.min(dp[i][j-1]+floor.charAt(j)-‘0’,dp[i-1][j-carpetLen]);<br>上述转移式中，dp[i][j-1]+floor.charAt(j)-‘0’表示对于下标j不铺地毯，后者表示在下标j铺一条地毯，且地毯末尾在下标j</p>
<p>1172.餐盘栈<br>模拟+有序集合<br>使用两个TreeSet分别维护非满栈的下标、非空栈的下标，模拟操作</p>
<p>2584.分割数组使乘积互质<br>质因数分解<br>遍历数组，对每一个元素进行质因数分解，同时记录某个质因数最晚出现的下标<br>遍历[0,n-1]，如果对于[0,i]出现过的质因数的最晚出现下标均&lt;&#x3D;i，则i为答案</p>
<p>2709.最大公约数遍历<br>质因数分解+并查集<br>特判：出现元素1时，当且仅当数组长度为1时返回true<br>对每个nums[i]进行质因数分解，假设x为nums[i]的质因数，则合并nums[i]与x，以及nums[i]与nums[i]&#x2F;x<br>通过并查集判断所有nums[i]是否位于同一个集合中，若是返回true</p>
<p>1483.树节点的第 K 个祖先<br>树上倍增（动态规划）<br>定义dp[i][j]表示节点i的第2^j个祖先节点<br>初始化：当j&#x3D;0时，dp[i][0]表示节点i的第一个祖先，也就是parent[i]<br>状态转移：枚举祖先2^j，再枚举节点，对于节点i：i的第2^(j+1)个祖先是i的第2^j个祖先的第2^j个祖先<br>表达式：dp[i][j+1]&#x3D;dp[ dp[i][j] ][j]<br>查询祖先：查询第k个祖先时，将k拆分为2的幂相加，例如当k&#x3D;13时，拆为1+4+8：<br>从当前节点跳到第1个祖先，接着从这个祖先跳到这个祖先的第4个祖先，最后从现在的祖先跳到现在祖先的第8个祖先完成查询<br>没有祖先时用-1表示，状态转移时没有祖先的状态将继续转移</p>
<p>1601.最多可达成的换楼请求数目<br>状态压缩+dfs+回溯<br>数据量较小，且每一个请求都是相互独立的，枚举每个请求是否被满足，最后判断状态是否合法，若合法则更新最多同时满足请求的数目</p>
<p>2872.可以被 K 整除连通块的最大数目<br>dfs+思维<br>对于某个节点i，如果i及其所有子节点之和sum满足sum%k&#x3D;&#x3D;0，则可以将节点i与其父节点连接的边删除<br>由于是无向树，每个节点都可以认为是根节点，为方便计算，认为0节点是根节点进行dfs得到答案</p>
<p>2561.重排水果<br>哈希表+排序+思维<br>首先用map统计两个果篮中所有元素值及其出现个数，如果某个元素的出现次数v为奇数，则无法使两个果篮在重排后相等，返回-1<br>否则，一定存在交换方案。<br>对map中所有元素v除以2，得到在满足题目条件的情况下其中一个果篮的元素值及其个数，再将map与第一个果篮进行比较<br>从而得出哪些元素需要从第二个果篮换到第一个果篮，哪些元素需要从第一个果篮换到第二个果篮，分别存入to1、to2<br>对o1和o2排序，o1最小的元素与o2最大的元素进行交换，或者以最小值为中介，通过2*min成本进行交换，统计成本得到答案</p>
<p>312.戳气球<br>记忆化搜索+逆向思维<br>逆向思考，考虑在区间里填充气球，最后填满整个区间。为计算方便，补充下标-1和下标n位置，记其元素值为1<br>定义dfs(int left,int right)表示将开区间(left,right)填满最多得到的硬币数<br>对于dfs(left,right)枚举先填充的位置mid，则得到的硬币为nums[left]+nums[mid]+nums[right]+dfs(left,mid)+dfs(mid,right)<br>返回所有可能的mid中得到硬币最多的作为结果，记忆化dfs函数可以优化时间复杂度</p>
<p>1547.切棍子的最小成本<br>记忆化搜索<br>为cuts添加左侧0和右侧n，存入list<br>定义dfs(left,right)表示将list中下标left到下标right切割开的最小成本<br>枚举中间点i，i的范围为[left+1,right-1]，切割成本为list.get(right)-list.get(left)+dfs(left,i)+dfs(i,right)<br>注意当left+1&gt;&#x3D;right时，无需切割，切割成本为0</p>
<p>对数组执行操作使平方和最大<br>等价转换<br>选择两个互不相同的下标 i 和 j ，同时 将 nums[i] 更新为 (nums[i] AND nums[j]) 且将 nums[j] 更新为 (nums[i] OR nums[j])：<br>等价于把一个数的 0 和另一个数的同一个比特位上的 1 交换。统计每个比特位上1的个数，尽可能凑出1个数最多的k个数将其平方和相加得到答案</p>
<p>2732.找到矩阵中的好子集<br>枚举+思维<br>枚举好子集中的元素个数<br>好子集中元素个数为1的情况：如果出现某一行i全为0，则[i]是好子集，返回答案<br>好子集中元素个数为2的情况：如果行i，行j每一列相加&lt;&#x3D;1，则[i,j]是好子集，返回答案<br>好子集中元素个数为3的情况：每列相加之和&lt;&#x3D;1,那么可以去掉其中一行，变成元素个数为2的情况<br>又由于列最多为5，可以证明好子集中元素个数&gt;&#x3D;4可以转化为好子集中元素个数为0或1或2的情况<br>因此只需考虑1和2，都没找到答案则返回空列表</p>
<p>2763.所有子数组中不平衡数字之和<br>枚举+哈希计数<br>固定子数组左端点i，枚举右端点j（j&gt;&#x3D;i+1，因为长度为1的子数组没有不平衡数字）<br>每新增一个元素num，子数组的不平衡度count+1<br>如果子数组中存在num-1，则count–，如果存在num+1，则count–<br>累加所有子数组的不平衡度count得到答案</p>
<p>2659.将数组清空<br>树状数组<br>使用指针p标记当前数组的第一个元素，问题转化为用指针p从小到大依次遍历数组中的所有元素<br>使用树状数组维护某个区间已删除的元素个数count，指针p移动到p2时需要减去count<br>当p2&gt;&#x3D;p时，将p移动到p2；当p2&lt;p时，p先移动到数组边界n，到达1，再从1移动到p2</p>
<p>最长相邻不相等子序列 II<br>后缀dp<br>使用动态规划枚举选哪个可解决本题。由于最后需要得到子序列，因此定义dp[i]表示从[i,n-1]中选择满足条件的最长子序列的长度<br>同时使用from[i]来记录dp[i]是由下标from[i]转移得到的</p>
<p>找出满足差值条件的下标 II<br>双指针<br>需要找到两个下标[i,j]，设 j &gt;&#x3D; i，则 abs(i - j) &gt;&#x3D; indexDifference  等价于 j - indexDifference &gt;&#x3D; i<br>枚举j，维护所有满足i &lt;&#x3D; j - indexDifference的nums[i]可能的最大值和最小值，设对应下标分别为maxIndex和minIndex<br>如果出现abs(nums[maxIndex]-nums[j])&gt;&#x3D;valueDifference或abs(nums[minIndex]-nums[j])&gt;&#x3D;valueDifference说明找到满足条件的两个下标，直接返回答案</p>
<p>972.相等的有理数<br>模拟<br>将String转化为double，判断两个数之差是否小于0.0000000001</p>
<p>1970.你能穿过矩阵的最后一天<br>二分+BFS<br>二分枚举答案，BFS判断是否可行</p>
<p>使数组变美的最小增量运算数<br>dp<br>定义dp[i][j]表示到下标j位置，让下标i-2+j的元素&gt;&#x3D;k的最小增量运算数<br>初始化：dp[2][0<del>2]&#x3D;nums[0</del>2]&gt;&#x3D;k?0:k-nums[0~2]<br>状态转移：dp[i][0]&#x3D;dp[i-1][1];<br>            dp[i][1]&#x3D;dp[i-1][2];<br>            dp[i][2]&#x3D;(nums[i]&gt;&#x3D;k?0:k-nums[i])+Math.min(dp[i-1][0],Math.min(dp[i-1][1],dp[i-1][2]));<br>答案：Math.min(dp[n-1][0],Math.min(dp[n-1][1],dp[n-1][2]))			</p>
<p>1654.到家的最少跳跃次数<br>BFS<br>如何判断无解？<br>a&#x3D;&#x3D;b 最多跳到x处，大于x时无解<br>a&gt;b 最多跳到x+b处，大于x+b时无解<br>a&lt;b 最多跳到max(max(forbidden)+a+b,x)处，具体证明见官方题解</p>
<p>968.监控二叉树<br>树形dp<br>定义状态0，1，2：<br>状态0：当前节点安装相机的时候，需要的最少相机数<br>状态1： 当前节点不安装相机，但是能被覆盖到的时候，需要的最少相机数<br>状态2：当前节点不安装相机，也不能被左右孩子覆盖到的时候，需要的最少相机数(最后由父节点来覆盖它)<br>对于每个节点<br>如果它处于状态0，它的左右孩子可以安装也可以不安装，甚至可以不被覆盖：<br> dp[0] &#x3D; Math.min(left[0], Math.min(left[1], left[2])) + Math.min(right[0], Math.min(right[1], right[2])) + 1;<br>如果它处于状态1，它的左右孩子必有一个需要安装：<br>dp[1] &#x3D; Math.min(left[0] + Math.min(right[0], right[1]), right[0] + Math.min(left[0], left[1]));<br>如果它处于状态2，说明它的左右孩子都不安装，但是其左右孩子被它们的孩子覆盖：<br>dp[2] &#x3D; left[1] + right[1];<br>最后返回根节点得到的dp数组中Math.min(dp[0], dp[1])</p>
<p>1955.统计特殊子序列的数目<br>动态规划<br>定义dp[i][0]表示前i个数 得到 由正整数个 0 组成的子序列的个数 记为【0】子序列<br>定义dp[i][1]表示前i个数 得到 由正整数个 0 紧接着正整数个 1 组成的子序列的个数 记为【1】子序列<br>定义dp[i][2]表示前i个数 得到 由正整数个 0 紧接着正整数个 1，最后正整数个 2 组成的子序列的个数 记为【2】子序列<br>状态转移：<br>num为0时，这个0可以与前面的所有【0】子序列组合形成【0】子序列，也可以单独成为【0】子序列，现在【0】子序列个数dp[i][0]&#x3D;dp[i-1][0]+dp[i-1][0]+1 其余子序列数量不变<br>num为1时，这个1可以与前面的所有【1】子序列组合形成【1】子序列，也可以单独和前面所有【0】子序列组合形成【1】子序列，现在【1】子序列个数dp[i][1]&#x3D;dp[i-1][1]+dp[i-1][1]+dp[i-1][0] 其余子序列数量不变<br>num为2时，这个2可以与前面的所有【2】子序列组合形成【2】子序列，也可以单独和前面所有【1】子序列组合形成【2】子序列，现在【2】子序列个数dp[i][2]&#x3D;dp[i-1][2]+dp[i-1][2]+dp[i-1][1] 其余子序列数量不变<br>答案：dp[n][2]</p>
<p>2003.每棵子树内缺失的最小基因值<br>DFS<br>由于nums[i]互不相同，那么树中最多只有一个节点值为1<br>当树中没有节点值为1的节点时，整棵树都缺少基因1，返回全1数组<br>当树中找到节点值为1的节点，记该节点为x，x的所有子节点c肯定缺少基因1，ans[c]&#x3D;1<br>对x进行dfs，遍历所有子节点c，之后可以得到ans[x]<br>再不断对x的父节点进行dfs，直到根节点（每个节点最多遍历一次）</p>
<p>2746.字符串连接删减字母<br>dp<br>定义dp[k][i][j]表示合并到下标k为止，合并后的字符串首字母为’a’+i，尾字母为’a’+j时的最小长度<br>所有dp初始为最大值，dp[0][words[0].charAt(0)-‘a’][words[0].charAt(words[0].length()-1)-‘a’]&#x3D;words[0].length()<br>状态转移：枚举k，记words[k]长度为len，第一个字母为fir，最后一个字母为las，则<br>枚举所有i，j<br>dp[k][fir][j]&#x3D;Math.min(dp[k][fir][j],dp[k-1][i][j]+(las&#x3D;&#x3D;i?len-1:len));<br>dp[k][i][las]&#x3D;Math.min(dp[k][i][las],dp[k-1][i][j]+(fir&#x3D;&#x3D;j?len-1:len));<br>答案：取最小的dp[n-1][i][j]</p>
<p>2246.相邻字符不同的最长路径<br>DFS<br>对于每个节点x，dfs找到左子树能到达的最长路径和右子树能到达的最长路径，更新答案<br>由于需要从父节点出发向左右子树进行dfs，因此可以认为该图是有向图，只有父节点指向孩子节点的边<br>本题与树的直径十分类似，只是多了一个相邻节点的条件限制<br>注意：在dfs(i)时，不论孩子节点v是否满足s[i]&#x3D;&#x3D;s[v]都要进行dfs(v)，因为答案可能是以v为根节点的路径</p>
<p>1444.切披萨的方案数<br>记忆化DFS+二维前缀和<br>枚举每次列切割的位置，或者行切割的位置，使用二维前缀和快速判断切割是否合法（即包含苹果）</p>
<p>798.得分最高的最小轮调<br>差分<br>对于元素 x，当所在下标大于或等于x时，元素x会加1分<br>因此x计1分的下标范围是[x,n−1]，有n−x个下标计分<br>元素x不计分的下标范围是 [0,x−1]，有x个下标不计分<br>假设x的初始下标为i，当论调k时，x将位于下标index &#x3D; (i-k+n)%n<br>如果此时x计分，则有index&gt;&#x3D;x 等价于k &lt;&#x3D; (i-x+n)%n 得到计分k的上限<br>由于计分的下标只有n-x个，从而得到计分k的下限k &gt;&#x3D; (i+1)%n<br>得到了某个元素计分时k的范围[low,high]，遍历所有元素：<br>使用差分数组diff 为diff[low]+&#x3D;1 diff[high+1]-&#x3D;1<br>最后还原差分数组，可以得到计分次数最多的k，这个k就是答案</p>
<p>1039.多边形三角剖分的最低得分<br>记忆化dfs<br>定义dfs(i,j)表示从顶点i到顶点j得到三角形的最低分数<br>枚举点k 得到dfs(i,j)&#x3D;min(dfs(i, k) + dfs(k, j) + v[i] * v[j] * v[k])</p>
<p>2076.处理含限制条件的好友请求<br>并查集<br>对于每一个请求{p,q}，先得到find(p)和find(q)<br>如果find(p)&#x3D;find(q) 已经在同一个集合中 ans[i]&#x3D;true<br>否则，枚举所有限制条件{a,b} 得到find(a)和find(b)<br>因为限制条件规定a和b不能在同一个集合中，如果将p，q合并会导致任意一对{a,b}被合并，即：<br>find(p)&#x3D;&#x3D;find(a)&amp;&amp;find(q)&#x3D;&#x3D;find(b)或者find(p)&#x3D;&#x3D;find(b)&amp;&amp;find(q)&#x3D;&#x3D;find(a)，那么p，q不能成为朋友<br>反之，可以合并p，q同时ans[i]&#x3D;true</p>
<p>1579.保证图可完全遍历<br>并查集<br>考虑选择最少的边数量count，使得两人都可完全遍历图<br>使用并查集来维护可到达的顶点集合，parent为公共边，parentA，parentB分别代表两人单独边<br>先遍历公共边{v1,v2} 若find(v1)!&#x3D;find(v2)则选中这条边，否则不选<br>令parentA和parentB都复制parent中的数据，分别遍历单独边，如果不在同一个集合中则继续选择<br>判断两人是否分别可以完全遍历，即parentA和parentB中父节点只有一个，如果不满足返回-1<br>否则可以完全遍历，设全部边个数为m，答案为m-count</p>
<p>2411.按位或最大的最小子数组长度<br>dp<br>定义dp[index]表示 位index的1 出现的最小下标<br>从后往前遍历nums 对于下标i的元素：<br>取所有出现过的dp[index]的最大值就是最远的1所在位置，由此计算得到ans[i]</p>
<p>898.子数组按位或操作<br>哈希集合<br>创建HashSet<Integer> ans存储所有可能的值，答案为ans.size()<br>创建HashSet<Integer> pre表示以上一个下标为结尾的子数组的所有结果，初始化pre.add(0)<br>对于每个下标i，创建HashSet<Integer> now,遍历pre中所有元素ele，向now添加nums[i]|ele<br>再把nums[i]放入now中，接着将now中所有元素放入ans中，并将pre标记为now</p>
<p>1439.有序矩阵中的第 k 个最小数组和<br>暴力<br>存储上一行为止可以得到的数组和pre，对于pre中的所有元素ele，都添加ele+本行元素mat[i][j]到now中<br>由于只有正整数，因此只需保留最小的k个元素，取出前k小的元素重新赋给pre，最后pre.get(k-1)就是答案</p>
<p>1673.找出最具竞争力的子序列<br>贪心+单调栈<br>等价于删除nums.length-k个元素，使剩下的元素按顺序形成的数字最小<br>使用单调栈预处理rightFloor数组，表示每个元素右边比其小的元素出现的下标，如果没有则为-1<br>遍历数组，如果rightFloor[i]!&#x3D;-1即右边有更小的元素且n-rightFloor[i]&gt;&#x3D;k即右边仍可选出超过k长度的子序列，那么nums[i]不选<br>否则选择nums[i]，记入答案数组中<br>题目 402.移掉 K 位数字 与本题类似</p>
<p>910.最小差值 II<br>排序+贪心<br>元素顺序不影响答案，先对数组进行排序<br>考虑对整个数组全部增加或全部减少的情况，答案初始化为nums[n-1]-nums[0]<br>为了得到最大值和最小值的最小差值，枚举某个点i，[0,i]全部增加，[i+1,n]全部减少<br>对于这样的点i：<br>最大值max有两种可能：nums[i]+k 和 nums[n-1]-k<br>最小值min有两种可能：nums[0]+k 和 nums[i+1]-k<br>维护ans&#x3D;Math.min(ans,max-min)得到答案</p>
<p>959.由斜杠划分区域<br>dfs<br>将n<em>n的格子看成3n</em>3n的格子，也就是每个格子看成由9个小格子形成<br>对于两种斜杠，分别填充3个小格子<br>dfs查找联通分块得到答案</p>
<p>2382.删除操作后的最大子段和<br>倒序回答 + 并查集<br>删除不好做，添加比较好做。不妨倒着思考，删除变成了添加<br>添加时进行合并，维护最大字段和</p>
<p>2290.到达角落需要移除障碍物的最小数目<br>Dijkstra最短路<br>把障碍物看成花费1可到达的位置，使用Dijkstra计算到达角落的最短距离</p>
<p>906.超级回文数<br>暴力枚举<br>边界数字的长度最大为18，则其平方根长度最大为9，由于平方根是回文，则回文的左半部分长度最大为4<br>枚举回文的左半部分[1,10000]，构造回文，再平方后判断是否为超级回文数，注意剪枝跳过超出边界的枚举</p>
<p>1879.两个数组最小的异或值之和<br>记忆化DFS<br>定义dfs(index,mask)表示从nums1的index下标开始计算，nums2的已选择情况为mask时两个数组最小的异或值之和<br>枚举nums1[index]与nums2中哪个元素进行异或运算：ret&#x3D;Math.min(ret,(nums1[index]^nums2[i])+dfs(index+1,mask|(1&lt;&lt;i)))<br>注意异或运算和加法的优先级，异或运算需要添加括号</p>
<p>1906.查询差绝对值的最小值<br>前缀和<br>数组中的元素范围较小，对每个数字统计前缀和<br>对于查询[left,right] 使用前缀和计算出该区间内不同数字出现的次数，维护差绝对值的最小值作为答案</p>
<p>1610.可见点的最大数目<br>数学：求极角几何题</p>
<p>2812.找出最安全路径<br>二分+BFS</p>
<p>2662.前往目标的最小代价<br>Dijkstra最短路<br>把起点、终点和所有特殊路径的终点看成是图上的点，求最短路径</p>
<p>2616.最小化数对的最大差值<br>二分<br>二分查找最大差值</p>
<p>1515.服务中心的最佳位置<br>机器学习<br>使用梯度下降法求解</p>
<p>2218.从栈中取出 K 个硬币的最大面值和<br>分组背包</p>
<p>2102.序列顺序查询<br>对顶堆<br>维护一个大顶堆和一个小顶堆，大顶堆的元素都小于小顶堆的元素</p>
<p>2122.还原原数组<br>枚举<br>暴力枚举index，判断在nums[0]与nums[index]配对情况下是否合法</p>
<p>2584.分割数组使乘积互质<br>质因数分解<br>记录每一个质因数最后出现的位置，遍历数组，对当前数字进行质因数分解，用index表示[0,i]中的质因数最后出现的位置，当i&#x3D;&#x3D;index时，i就是答案</p>
<p>1036.逃离大迷宫<br>BFS<br>在网格中，要知道点s与点t是否连通<br>由于障碍物数量比较少，问题转化为判断点s和点t是否被障碍物及网格边界完全包围<br>判断某个点是否被边界及障碍物完全包围，可以从该点出发进行BFS判断能到达的网格数<br>障碍物最多n个，可以用BFS能否到达至少n*(n-1)&#x2F;2个格子来判断某个点是否被包围<br>如果BFS能访问超过1e5格子，认为没有被包围<br>对点s和点t分别进行BFS，如果都没有被包围返回true，反之返回false</p>
<p>786.第 K 个最小的素数分数<br>模拟<br>双循环构造分数并排序</p>
<p>1862.向下取整数对和<br>前缀和<br>对于表达式floor(nums[i] &#x2F; nums[j])，固定nums[j]，有多个nums[i]使得该表达式值相同，枚举这样的nums[i]的个数<br>使用前缀和快速得到个数进行统计</p>
<p>1691.堆叠长方体的最大高度<br>贪心+排序+dp<br>把每个长方体最长的一条边作为高度才能得到最大高度<br>定义h[i]表示以下标为i的长方体作为堆叠后的顶部时能够得到的最大高度<br>h[i]由h[j]转移而来：h[i]&#x3D;max(h[j]+height[i]) 为长方体排序后双重循环枚举i和j<br>最后答案为max(h[i])</p>
<p>2709.最大公约数遍历<br>质因数分解+并查集<br>gcd(nums[i], nums[j]) &gt; 1等价于nums[i]和nums[j]存在相同的质因数<br>对每个nums元素进行分解质因数，将质因数与该元素合并<br>最后使用并查集判断所有nums元素是否位于同一连通分量<br>注意需要特判nums元素中有1的情况</p>
<p>2454.下一个更大元素 IV<br>双单调栈<br>从左往右遍历 nums，用（递减）单调栈stack记录元素，如果 x&#x3D;nums[i]比stack的栈顶大，则x是栈顶的下个更大元素，弹出栈顶。最后把x入栈（实际入栈的是其下标i）<br>把弹出的元素加到另一个栈stack2中（注意保持原始顺序，即按下标顺序，下标小的优先入栈），后续循环时，如果y&#x3D;nums[j]比stack2的栈顶大，则y栈顶的下下个更大元素，记录答案，弹出栈顶</p>
<p>2768.黑格子的数目<br>哈希表<br>对于一个位于(x,y)的黑格子而言，它可能位于四个块中：<br>以(x-1,y-1)为左上角的块<br>以(x,y-1)为左上角的块<br>以(x-1,y)为左上角的块<br>以(x,y)为左上角的块<br>将这些可能受影响的块（的左上角）放入哈希表中<br>所有的块减去受影响的块得到ans[0]<br>遍历受影响的块，分别统计每个块中有多少个黑格子</p>
<p>2065.最大化一张图中的路径价值<br>暴力dfs<br>分析题目数据发现合法路径最多递归10次，直接暴力dfs获取答案</p>
<p>2045.到达目的地的第二短时间<br>动态边权+最短路径dijkstra<br>红绿灯切换问题：本质是动态边权<br>假设在T时间到达节点i，红绿灯切换时间为change，则有：<br>当 T&#x2F;change 为偶数时 处于绿灯时间不需要等待，边权为0<br>当 T&#x2F;change 为奇数时 处于红灯时间，等待时间为change - (T%change)，该值也就是边权<br>将节点编号映射为[0,n-1]，跑最短路径算法求解<br>题目要求第二短时间，因此使用dijkstra算法时，引入一个dis2数组，来维护节点0到节点i的次短路径，最后答案就是节点0到节点n-1的次短路径，也就是dis2[n-1] </p>
<p>2835.使子序列的和等于目标的最少操作次数<br>贪心<br>缺少哪一位就从高位分解获取，注意已有的低位也可以凑出当前需要的位</p>
<p>834.树中距离之和<br>换根dfs<br>先通过dfs计算出节点root到所有节点的距离ans[root]<br>考虑从节点root转移到其子节点child：<br>对于child及其子树上的节点，距离更近了，记子树的所有节点数量为size<br>对于其他节点，距离更远了，这部分节点数量为n-size<br>可以得到转移方程：ans[child]&#x3D;ans[root] + (n-size) - size<br>根据转移方程得到所有答案</p>
<p>1081.不同字符的最小子序列<br>贪心<br>统计每个字符的数量，使用ans构造答案，使用visit数组判断某个字符是否已经在ans中。遍历字符串，对于每个ch：<br>如果ans中的最后一个字符last&gt;ch而且右边还有字符last，那么把last从ans中删除，不断重复此过程，直到last不再大于ch或ans为空<br>此时再把ch放入ans中。遍历完字符串得到的ans就是答案</p>
<p>891.子序列宽度之和<br>排序+贡献法+数学<br>由于元素顺序对答案无影响，可对数组排序，计算每个元素对答案的贡献<br>对于一个元素num：<br>在某个序列中它作为最小值时，对答案的贡献为-num，作为最大值时，对答案的贡献为num<br>那么只要找出它作为最小值&#x2F;最大值时的序列总数，就可以得到num对答案的总贡献<br>假设num位于排序后数组的下标index，其左边有index个元素，这index个元素都有选&#x2F;不选两种状态，因此num作为最大值时的子序列个数为2^index，同理可得作为最小值时的子序列个数为2^(n-1-index)<br>遍历所有num累加贡献得到答案</p>
<p>1915.最美子字符串的数目<br>状态压缩+前缀哈希<br>固定子字符串右端点，枚举有多少个满足条件的左端点<br>使用二进制数压缩字符串中每一个字符出现的奇偶次数状态<br>使用哈希表记录前缀的字符状态及其出现次数<br>对于每一个右端点的状态status，在前缀哈希表中的preStatus 只要满足与status的二进制表示最多有1位不同，那么preStatus就是符合条件的左端点，将其出现个数计入答案</p>
<p>2732.找到矩阵中的好子集<br>分类讨论+思维<br>结论：如果一个子集是好子集，那么该子集的元素个数不超过2。<br>如果存在元素个数为1的好子集，等价于存在一行元素全为0矩阵<br>如果存在元素个数为2的好子集，这两行的每一列元素之和都为1<br>如果存在元素个数为3的好子集，这三行的每一列元素之和不超过1，必然可以去掉其中一行转化为元素个数为2的好子集<br>可以理解为答案好子集中的元素个数如果大于2，可以去掉一些行转化为2的情况，因此只需要考虑好子集的元素个数为1或2</p>
<p>952.按公因数计算最大组件大小<br>质因数分解+并查集<br>对每个元素进行质因数分解，再与质因数合并，统计最大的联通分量大小作为答案<br>例如元素ele存在质因数v，需要merge(ele,v)以及merge(ele,ele&#x2F;v)<br>注意：1不能与其他数字合并，因此当ele!&#x3D;v时才可以进行合并</p>
<p>1498.满足条件的子序列数目<br>排序+二分查找+快速幂<br>由于考虑的是子序列，那么元素顺序不影响答案，先对数组进行排序<br>固定最小值，记最小值下标为left，二分查找满足条件的最大值可以出现的最大下标right<br>区间(left,right]的元素个数有count&#x3D;right-left个，这些元素每个都有选择&#x2F;不选两种情况，因此固定这个最小值对答案的贡献是pow(2,count)<br>统计每个最小值对答案的贡献即可</p>
<p>2132.用邮票贴满网格图<br>二维前缀和+二维差分<br>如果一个区域的前缀和为0，说明可以放下邮票，贪心地放置邮票，并记录在差分数组中<br>最后遍历每个空格，通过差分数组还原该空格放置的邮票层数，如果为0返回false</p>
<p>260.只出现一次的数字 III<br>位运算<br>设答案为a，b<br>整个数组异或可以得到x &#x3D; a ^ b<br>x不为0，因为a不可能等于b，如果a等于b那么a就出现了两次与题目矛盾<br>寻找x的最低位1的位置，记为index，a和b在index位上的结果一定是一个为1，一个为0<br>将整个数组分为两类：index位为1的元素&#x2F;index位为0的元素<br>分别将这两类元素进行异或，就得到了a和b</p>
<p>2866.美丽塔 II<br>枚举+预处理+单调栈<br>枚举山峰的位置，假设山峰位于下标i<br>那么区间[0,i]是非递减的，[i+1,n-1]是非递增的<br>设pre[i]为[0,i]非递减的最大和，suf[i+1]为[i+1,n-1]非递增的最大和<br>此时高度和为pre[i]+suf[i+1]<br>为了获取pre和suf数组，可以用单调栈来实现<br>单调栈获取pre的思路（获取suf数组同理）：<br>index入栈，<br>当栈顶 &gt; maxHeight[index]时不断出栈，<br>直到栈顶 &lt;&#x3D; maxHeight[index]<br>此时得到pre[index] &#x3D; pre[栈顶] + [栈顶+1,index] * maxHeight[index],注意需要特判此时栈顶为空的情况</p>
<p>1743.从相邻元素对还原数组<br>哈希表+dfs<br>通过哈希表可以获取到任意的只有一个相邻元素的值，把这个值作为数组头部<br>根据相邻元素进行dfs直到还原全部数组</p>
<p>1738.找出第 K 大的异或坐标值<br>二维前缀和思想+排序<br>类似二维前缀和获取二维异或和数组，每次计算后放入list，对list排序后取出第k大即为答案</p>
<p>365.水壶问题<br>记忆化BFS<br>两个水壶 记水量为a b 每一次都有以下的操作：<br>装满a<br>装满b<br>倒空a<br>倒空b<br>a倒入b<br>b倒入a<br>使用long变量记录搜索状态避免重复搜索</p>

  </div>
  
</div>
          </div>
        </div>

        <link rel="stylesheet" href="/css/footer.css">
<div class="bottom-outer">
  <div class="framework-info">
  </div>
</div>

          
            <!-- scripts list from theme config.yml -->
            
              <script src="/js/MiHoYo.js"></script>
              
                

  </body>

  </html>