<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  
  <title>comin-lin&#39;s blog</title>
  <meta name="author" content="comin-lin">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="comin-lin&#39;s blog"/>

  
    <meta property="og:image" content=""/>
  

  <link rel="shortcut icon" href="/favicon.png">
  
  
<link rel="stylesheet" href="/css/style.css">

  <!--[if lt IE 9]><script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script><![endif]-->
  

<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">comin-lin&#39;s blog</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article id="post-java核心技术卷1笔记" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2023-12-08T06:08:23.000Z"><a href="/2023/12/08/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B71%E7%AC%94%E8%AE%B0/">2023-12-08</a></time>
      
      
  
    <h1 class="title"><a href="/2023/12/08/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B71%E7%AC%94%E8%AE%B0/">java核心技术卷1笔记</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h3 id="java核心技术卷I"><a href="#java核心技术卷I" class="headerlink" title="java核心技术卷I"></a>java核心技术卷I</h3><ul>
<li>第一章 Java 程序设计概述</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">在java设计者编写的 &quot;白皮书&quot; 中，有如下 11 个关键术语：</span><br><span class="line"></span><br><span class="line">1.简单性 </span><br><span class="line">Java 语法是 C++ 语法的一个“ 纯净” 版本</span><br><span class="line"></span><br><span class="line">2.面向对象 </span><br><span class="line">面向对象设计是一种程序设计技术，它将重点放在教椐（即对象）和对象的接口上</span><br><span class="line"></span><br><span class="line">3.分布式</span><br><span class="line">Java 有一个丰富的例程库，用于处理 HTTP 和 FTP 之类的 TCP/IP 协议，Java 应用程序能够通过 URL 打开和访问网络上的对象</span><br><span class="line"></span><br><span class="line">4.健壮性</span><br><span class="line">Java 编译器能够检测许多在其他语言中仅在运行时才能够检测出来的问题</span><br><span class="line"></span><br><span class="line">5.安全性</span><br><span class="line">从一开始，Java 就设计成能够防范各种攻击，默认情况下，Java程序在一个受限的环境——“沙箱”中运行</span><br><span class="line"></span><br><span class="line">6.体系结构中立</span><br><span class="line">编译器生成一个体系结构中立的目标文件格式，这是一种编译过的代码， 只要有Java运行时系统，这些编译后的代码可以在许多处理器上运行</span><br><span class="line"></span><br><span class="line">7.可移植性</span><br><span class="line">在 Java 中，数据类型具有固定的大小， 这消除了代码移植时令人头痛的主要问题</span><br><span class="line"></span><br><span class="line">8.解释型</span><br><span class="line">Java 解释器可以在任何移植了解释器的机器上执行 Java 字节码</span><br><span class="line"></span><br><span class="line">9.高性能</span><br><span class="line">字节码可以（在运行时刻）动态地翻译成对应运行这个应用的特定 CPU 的机器码</span><br><span class="line"></span><br><span class="line">10.多线程</span><br><span class="line">多线程可以带来更好的交互响应和实时行为</span><br><span class="line"></span><br><span class="line">11.动态性</span><br><span class="line">Java 与 C/C++ 相比更加具有动态性，它能够适应不断发展的环境。库中可以自由地添加新方法和实例变量， 而对客户端却没有任何影响</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">applet</span><br><span class="line">在网页中运行的 Java 程序称为 applet。如今applet已经很少使用</span><br></pre></td></tr></table></figure>

<ul>
<li>第二章 Java 程序设计环境</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">使用命令行工具编译并运行 Java 程序：</span><br><span class="line">javac Hello.java </span><br><span class="line">java Hello</span><br><span class="line"></span><br><span class="line">javac 程序是一个Java编译器，它将Hello.java编译成Hello.class</span><br><span class="line">java  程序启动Java虚拟机，虚拟机执行编译器放在class文件中的字节码</span><br></pre></td></tr></table></figure>

<ul>
<li>第三章 Java 的基本程序设计结构</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">数据类型</span><br><span class="line"></span><br><span class="line">Java 是一种强类型语言。这就意味着必须为每一个变量声明一种类型</span><br><span class="line">在java中，一共有8种基本类型，其中有 4 种整型、2 种浮点类型，1种用于表示 Unicode 编码的字符单元的字符类型 char 和 1 种用于表示真值的 boolean 类型</span><br><span class="line"></span><br><span class="line">四种整形按存储大小排序：byte 1字节 &lt; short 2字节 &lt; int 4字节 &lt; long 8字节</span><br><span class="line">在 Java 中， 整型的范围与运行 Java 代码的机器无关，这就解决了软件从一个平台移植到另一个平台，或者在同一个平台中的不同操作系统之间进行移植给程序员带来的诸多问题。</span><br><span class="line"></span><br><span class="line">两种浮点类型：float 4字节 &lt; double 8字节</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">变量</span><br><span class="line">在java中，变量名对大小写敏感，且不能使用 Java 保留字作为变量名</span><br><span class="line"></span><br><span class="line">常量</span><br><span class="line">在 Java 中， 利用关键字 final 指示常量。常量只能被赋值一次。一旦被赋值之后，就不能够再更改了。习惯上常量名使用全大写</span><br><span class="line"></span><br><span class="line">运算符</span><br><span class="line">在 Java 中，使用算术运算符 +、-、 *、/ 表示加、减、 乘、除运算</span><br><span class="line">位运算符：&amp; (&quot;and&quot;) | (&quot;or&quot;) ^ (&quot;xor&quot;) ~ (&quot;not&quot;) &lt;&lt; 左移 &gt;&gt; 右移</span><br><span class="line"></span><br><span class="line">枚举类型</span><br><span class="line">声明枚举类型 enum Size&#123;type1,type2&#125;;</span><br><span class="line">使用枚举类型 Size s=Size.type1;</span><br><span class="line"></span><br><span class="line">字符串</span><br><span class="line">从概念上讲， Java 字符串就是 Unicode 字符序列，使用String类表示</span><br><span class="line">String 类没有提供用于修改字符串的方法，因此将 String 类对象称为不可变字符串，这么做有一个优点：编译器可以让字符串共享</span><br><span class="line"></span><br><span class="line">String 常用API</span><br><span class="line">char charAt (int index) 返回下标为index的字符</span><br><span class="line">int compareTo(String other) 按照字典顺序，如果字符串位于 other 之前，返回一个负数，大于则返回正数，相同返回0</span><br><span class="line">boolean equals(0bject other) 如果字符串与 other 相等， 返回 true</span><br><span class="line">boolean startsWith(String prefix) 字符串如果以prefix开头返回true</span><br><span class="line">boolean endsWith(String suffix ) 字符串如果以suffx结尾返回true</span><br><span class="line">int indexOf(String str) 在字符串中寻找str第一次出现的位置，如果不存在str则返回-1</span><br><span class="line">String replace(CharSequence oldString,CharSequence newString) 返回一个新字符串。这个字符串用 newString 代替原始字符串中所有的 oldString。可以用 String 或 StringBuilder 对象作为 CharSequence 参数</span><br><span class="line">String substring(int beginlndex, int endlndex ) 截取子串，前开后闭[beginIndex,endIndex)</span><br><span class="line">String toLowerCase() 将大写字母改为小写</span><br><span class="line">String toUpperCase() 将小写字母改为大写</span><br><span class="line">String trim() 删除字符串首尾的空格</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">构建字符串</span><br><span class="line">使用 StringBuilder类来构建字符串比字符串拼接效率更高</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入/输出</span><br><span class="line">在java中，想通过控制台进行输入，首先需要构造一个 Scanner 对象，并与“标准输入流” System.in 关联</span><br><span class="line">Scanner的nextLine方法读入一行字符串，可包含空格</span><br><span class="line">在java中，使用System.out进行输出</span><br><span class="line"></span><br><span class="line">大数值</span><br><span class="line">如果基本的整数和浮点数精度不能够满足需求，那么可以使用java.math包中的两个很有用的类：Biglnteger 和 BigDecimal</span><br><span class="line"></span><br><span class="line">BigInteger 常用API</span><br><span class="line">add 加</span><br><span class="line">substract 减</span><br><span class="line">multiply 乘</span><br><span class="line">divide 除</span><br><span class="line">mod 求余</span><br><span class="line">compareTo 比较大小</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">数组</span><br><span class="line">静态初始化 int[] arr=&#123;1,2,3&#125;;</span><br><span class="line">动态初始化 int[] arr=new int[3];</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第四章 对象与类</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类之间的关系</span><br><span class="line">•依赖（“uses-a”） 如果一个类的方法操纵另一个类的对象，我们就说一个类依赖于另一个类</span><br><span class="line">•聚合（“has-a”） 聚合关系意味着类A的属性中包含类B</span><br><span class="line">•继承（“is-a”） 类 A 扩展类 B，得到了从类B继承过来的方法</span><br></pre></td></tr></table></figure>
</li>
<li><p>第五章 继承</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用final关键字修饰的类无法被继承</span><br><span class="line">使用protected关键字修饰的属性或方法，其他类无法访问，子类可以访问</span><br><span class="line"></span><br><span class="line">Object：所有类的超类</span><br></pre></td></tr></table></figure>
</li>
<li><p>第六章 接口、lambda表达式与内部类</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">接口：对类的一组需求描述</span><br><span class="line">一个类可以实现（implement)—个或多个接口</span><br><span class="line">接口中的所有方法自动地属于 public</span><br><span class="line"></span><br><span class="line">lambda表达式：是一个可传递的代码块</span><br><span class="line"></span><br><span class="line">方法引用：使用 类名::方法名 的形式来引用方法</span><br><span class="line"></span><br><span class="line">构造器引用：使用 类名::new 的形式来引用构造器</span><br><span class="line"></span><br><span class="line">内部类：是定义在另一个类中的类</span><br><span class="line">内部类的作用：</span><br><span class="line">内部类方法可以访问该类定义所在的作用域中的数据， 包括私有的数据</span><br><span class="line">内部类可以对同一个包中的其他类隐藏起来</span><br><span class="line">当想要定义一个回调函数且不想编写大量代码时，使用匿名（anonymous)内部类比较便捷</span><br></pre></td></tr></table></figure>
</li>
<li><p>第七章 异常、断言和日志</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>第八章 泛型程序设计</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>第九章 集合</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>第十章 图形程序设计</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>第十一章 事件处理</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>第十二章 Swing用户界面组件</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>第十三章 部署Java应用程序</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>第十四章 并发</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-vue" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2023-10-22T04:49:50.000Z"><a href="/2023/10/22/vue/">2023-10-22</a></time>
      
      
  
    <h1 class="title"><a href="/2023/10/22/vue/">vue</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h3 id="vue3引入element-plus、router"><a href="#vue3引入element-plus、router" class="headerlink" title="vue3引入element-plus、router"></a>vue3引入element-plus、router</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main.js</span><br><span class="line"></span><br><span class="line">import &#123; createApp &#125; from &#x27;vue&#x27;</span><br><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line">import router from &#x27;./router&#x27;;</span><br><span class="line">import ElementPlus from &#x27;element-plus&#x27;;</span><br><span class="line">import &#x27;element-plus/theme-chalk/index.css&#x27;;</span><br><span class="line">const app = createApp(App);</span><br><span class="line">app.use(router);</span><br><span class="line">app.use(ElementPlus);</span><br><span class="line">app.mount(&#x27;#app&#x27;);</span><br></pre></td></tr></table></figure>

<h3 id="vue3编写路由配置-src-x2F-router-js"><a href="#vue3编写路由配置-src-x2F-router-js" class="headerlink" title="vue3编写路由配置 src&#x2F;router.js"></a>vue3编写路由配置 src&#x2F;router.js</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">router.js</span><br><span class="line"></span><br><span class="line">import &#123; createRouter, createWebHistory &#125; from &#x27;vue-router&#x27;;</span><br><span class="line">import MyHome from &#x27;./components/MyHome.vue&#x27;;</span><br><span class="line">import MyLogin from &#x27;./components/MyLogin.vue&#x27;;</span><br><span class="line">import http from &#x27;./api/ajax_config.js&#x27;</span><br><span class="line">import MyUser from &#x27;./components/MyUser.vue&#x27;</span><br><span class="line">const routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/&#x27;,</span><br><span class="line">    name: &#x27;MyHome&#x27;,</span><br><span class="line">    component: MyHome,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: &#x27;user&#x27;,</span><br><span class="line">        component: MyUser,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/login&#x27;,</span><br><span class="line">    name: &#x27;MyLogin&#x27;,</span><br><span class="line">    component: MyLogin</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">const router = createRouter(&#123;</span><br><span class="line">  history: createWebHistory(),</span><br><span class="line">  routes</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//路由守卫</span><br><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  // 如果目标路由是 &#x27;/login&#x27;，直接进行路由跳转</span><br><span class="line">  if (to.path === &#x27;/login&#x27;) &#123;</span><br><span class="line">    next();</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  // 否则发送 Axios 请求 判断是否登录</span><br><span class="line">  http.get(&#x27;/user/loginStatus&#x27;)</span><br><span class="line">    .then(response =&gt; &#123;</span><br><span class="line">      // console.log(response.data.code);</span><br><span class="line">      if (response.data.code === 200) &#123;</span><br><span class="line">        // 已登录，继续访问目标路由</span><br><span class="line">        next();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // 未登录，跳转到登录页</span><br><span class="line">        next(&#x27;/login&#x27;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(error =&gt; &#123;</span><br><span class="line">      console.error(error);</span><br><span class="line">      next(false); // 取消路由跳转</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">export default router;</span><br></pre></td></tr></table></figure>

<h3 id="vue3使用代理解决跨域请求问题"><a href="#vue3使用代理解决跨域请求问题" class="headerlink" title="vue3使用代理解决跨域请求问题"></a>vue3使用代理解决跨域请求问题</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vue.config.js</span><br><span class="line"></span><br><span class="line">const &#123; defineConfig &#125; = require(&#x27;@vue/cli-service&#x27;)</span><br><span class="line">module.exports = defineConfig(&#123;</span><br><span class="line">  transpileDependencies: true,</span><br><span class="line">  lintOnSave: false, // 关闭eslint校验</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    proxy: &#123;</span><br><span class="line">      &#x27;/api&#x27;: &#123;</span><br><span class="line">        target: &#x27;http://127.0.0.1:8081/&#x27;,// 后端接口</span><br><span class="line">        changeOrigin: true, // 是否跨域</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          &#x27;/api&#x27;: &#x27;&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="vue3封装axios-请求基础路径，请求拦截器添加token"><a href="#vue3封装axios-请求基础路径，请求拦截器添加token" class="headerlink" title="vue3封装axios(请求基础路径，请求拦截器添加token)"></a>vue3封装axios(请求基础路径，请求拦截器添加token)</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">ajax_config.js</span><br><span class="line"></span><br><span class="line">import axios from &#x27;axios&#x27;;</span><br><span class="line"></span><br><span class="line">// 创建自定义的 Axios 实例 http</span><br><span class="line">const http = axios.create(&#123;</span><br><span class="line">  // 设置基本的请求配置，如 baseURL</span><br><span class="line">  baseURL: &#x27;/api&#x27;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 添加请求拦截器</span><br><span class="line">http.interceptors.request.use(</span><br><span class="line">  function(config) &#123;</span><br><span class="line">    // 在请求发送前设置请求头的 Token</span><br><span class="line">    const token = localStorage.getItem(&#x27;token&#x27;);</span><br><span class="line">    config.headers[&#x27;token&#x27;] = `$&#123;token&#125;`;</span><br><span class="line">    return config;</span><br><span class="line">  &#125;,</span><br><span class="line">  function(error) &#123;</span><br><span class="line">    return Promise.reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">export default http;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">其他组件引入</span><br><span class="line">import http from &#x27;./api/ajax_config.js&#x27;</span><br><span class="line">其他组件使用</span><br><span class="line">http.get(&#x27;/user/loginStatus&#x27;)</span><br><span class="line">    .then(response =&gt; &#123;</span><br><span class="line">      // console.log(response.data.code);</span><br><span class="line">      if (response.data.code === 200) &#123;</span><br><span class="line">        // 已登录，继续访问目标路由</span><br><span class="line">        next();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // 未登录，跳转到登录页</span><br><span class="line">        next(&#x27;/login&#x27;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(error =&gt; &#123;</span><br><span class="line">      console.error(error);</span><br><span class="line">      next(false); // 取消路由跳转</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="vue3组件写法"><a href="#vue3组件写法" class="headerlink" title="vue3组件写法"></a>vue3组件写法</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">vue3兼容大部分vue2语法</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;;</span><br><span class="line">import &#123; ElMessage &#125; from &#x27;element-plus&#x27;; //显示消息的组件</span><br><span class="line">//使用vue3语法编写用户管理组件</span><br><span class="line">export default &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    //控制 添加用户弹窗是否展示 的变量</span><br><span class="line">    const addUserDialogVisible = ref(false);</span><br><span class="line">    //展示 添加用户 弹窗</span><br><span class="line">    const showAddUserDialog = () =&gt; &#123;</span><br><span class="line">      addUserDialogVisible.value = true;</span><br><span class="line">    &#125;;</span><br><span class="line">    //添加用户表单</span><br><span class="line">    const addUserForm = ref(&#123;</span><br><span class="line">      username: &#x27;&#x27;,</span><br><span class="line">      password: &#x27;&#x27;,</span><br><span class="line">      roleId: &#x27;&#x27;</span><br><span class="line">    &#125;);</span><br><span class="line">    //重设 添加用户 弹窗表单</span><br><span class="line">    const resetAddUserForm = () =&gt;&#123;</span><br><span class="line">      addUserForm.value.username=&#x27;&#x27;;</span><br><span class="line">      addUserForm.value.password=&#x27;&#x27;;</span><br><span class="line">      addUserForm.value.roleId=&#x27;&#x27;;</span><br><span class="line">    &#125;;</span><br><span class="line">    //添加用户</span><br><span class="line">    const addUser = () =&gt;&#123;</span><br><span class="line">      addUserDialogVisible.value = false;</span><br><span class="line">      ElMessage.success(&#x27;添加成功！&#x27;);</span><br><span class="line">    &#125;;</span><br><span class="line">    //添加用户表单规则 使用this.$refs.form.validate((valid) =&gt; &#123; 时进行表单验证</span><br><span class="line">    const addUserFormRules = ref(&#123;</span><br><span class="line">      username: [</span><br><span class="line">        &#123; required: true, message: &#x27;请输入用户名&#x27;, trigger: &#x27;blur&#x27; &#125;</span><br><span class="line">      ],</span><br><span class="line">      password: [</span><br><span class="line">        &#123; required: true, message: &#x27;请输入密码&#x27;, trigger: &#x27;blur&#x27; &#125;</span><br><span class="line">      ],</span><br><span class="line">      roleId: [</span><br><span class="line">        &#123; required: true, message: &#x27;请选择角色&#x27;, trigger: &#x27;change&#x27; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;);</span><br><span class="line">    //用户数据</span><br><span class="line">    const userList=ref([</span><br><span class="line">      &#123; id: 1, username: &#x27;admin&#x27;, password: &#x27;123456&#x27;, roleId: 1 &#125;,</span><br><span class="line">      &#123; id: 2, username: &#x27;user1&#x27;, password: &#x27;abcdef&#x27;, roleId: 2 &#125;</span><br><span class="line">    ]);</span><br><span class="line">    //roleId转化为中文</span><br><span class="line">    const getRoleName = (roleId)=&gt;&#123;</span><br><span class="line">      if (roleId === 1) &#123;</span><br><span class="line">        return &#x27;超级管理员&#x27;;</span><br><span class="line">      &#125; else if (roleId === 2) &#123;</span><br><span class="line">        return &#x27;楼栋管理员&#x27;;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return &#x27;null&#x27;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    return &#123;</span><br><span class="line">      addUserDialogVisible,</span><br><span class="line">      showAddUserDialog,</span><br><span class="line">      addUserForm,</span><br><span class="line">      resetAddUserForm,</span><br><span class="line">      addUser,</span><br><span class="line">      addUserFormRules,</span><br><span class="line">      userList,</span><br><span class="line">      getRoleName</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-力扣2051-2300" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2023-08-28T02:49:56.000Z"><a href="/2023/08/28/%E5%8A%9B%E6%89%A32051-2300/">2023-08-28</a></time>
      
      
  
    <h1 class="title"><a href="/2023/08/28/%E5%8A%9B%E6%89%A32051-2300/">力扣2051-2300</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <ol start="1856">
<li><p>子数组最小乘积的最大值<br>单调栈+前缀和<br>使用单调栈预处理左边更小值和右边更小值出现的位置<br>遍历数组，对于每个nums[i]计算出以nums[i]为最小值时的最长子数组的分数，维护最大值作为答案</p>
</li>
<li><p>最大相等频率<br>哈希表+模拟+分类讨论<br>遍历数组，使用一个哈希表统计每个元素及其出现次数，另一个哈希表统计频率以及该频率出现的次数<br>如果频率只存在一种，如果频率为1或者出现次数为1则满足条件<br>如果频率只存在两种，如果其中一种是1且出现1次则满足条件，另外如果两个频率相差为1，且较大的频率出现次数为1，也满足条件<br>如果频率出现两种以上，不满足条件</p>
</li>
<li><p>树上最大得分和路径<br>DFS<br>bob到达0的路径只有一条，从bob出发进行dfs，得到bob经过每个节点的时间<br>alice从0出发，dfs枚举到达每个叶子节点的得分，维护最大得分作为答案</p>
</li>
<li><p>相似字符串组<br>并查集<br>数据量较小，枚举哪些字符串是相似的，使用并查集维护集合数量作为答案</p>
</li>
<li><p>统计所有可行路径<br>记忆化搜索dfs<br>枚举下一步可以到达的城市<br>注意每次到达finish都可以终止作为一条合法路径，也可以不终止继续行驶</p>
</li>
<li><p>最大子序列的分数<br>排序+优先队列<br>先把nums1和nums2绑定成二维数组data，再按照data[1]的值从大到小对二维数组排序<br>枚举nums2中的最小值为data[i][1]，使用优先队列维护最大的k个nums1的值，动态维护答案</p>
</li>
<li><p>邻位交换的最小次数<br>模拟<br>使用下一个排列算法得到目标妙数的序列，再模拟交换相邻位数字得到目标妙数，同时统计答案</p>
</li>
<li><p>最美子字符串的数目<br>前缀和+状态压缩<br>字符串只由前10个英文字母组成<br>使用10个二进制位的整数mask存储字母出现的奇偶情况前缀和，0代表偶数次，1代表奇数次<br>子字符串是连续的字符序列，若下标[left,right]的子字符串至多一个字母出现奇数次，那么有：<br>1.子字符串所有字母均出现偶数次：下标left处mask与下标right处mask相同<br>2.子字符串仅一个字母出现奇数次：下标left出mask与下标right处mask仅有一位不同<br>存储每一个前缀的字符串对应的mask出现的次数，对于每个mask状态枚举前面可以转移而来的前缀，如果出现过就统计次数加到答案中</p>
</li>
<li><p>到家的最少跳跃次数<br>BFS<br>注意每个位置最多可以经过两次，其中一次是前面的位置往后跳得到的，另一次是后面的位置往前跳得到的<br>题目限制不能连续后跳两次，BFS时应存储方向，避免连续后跳</p>
</li>
<li><p>最低加油次数<br>贪心+优先队列<br>判断每个加油站是否能到达，若可以则将该加油站的油量放入优先队列，若不能到达则从优先队列中取出最大的加油量进行使用<br>直到油量&gt;&#x3D;0或队列为空，若油量&gt;&#x3D;0说明该加油站仍可到达，反之无解</p>
</li>
<li><p>粉刷房子 III<br>三维动态规划<br>定义dp[i][j][k]表示[0,i]区间房子全部上色且下标为i的房子的颜色为j且[0,i]被划分为k个区间的最少花费</p>
</li>
<li><p>前往目标的最小代价<br>最短路径<br>建图，求start到target的最短路径<br>如果特殊路径的cost &gt; 曼哈顿距离，则记为曼哈顿距离<br>为 起点和终点 到 所有特殊点，以及 特殊路径的两端点 到 其他点，特殊路径的起点 到 特殊路径的终点 添加边</p>
</li>
<li><p>替换数组中的非互质数<br>栈<br>遍历数组，对于nums[i]，如果与栈顶元素满足gcd &gt; 1，不断将栈顶元素取出与nums[i]进行合并,nums[i]将变成lcm(nums[i],栈顶元素)<br>直到栈为空或者当前nums[i]无法再与栈顶元素合并，将nums[i]放入栈顶。最后栈中元素就是答案</p>
</li>
<li><p>绝对值表达式的最大值<br>数学<br>将目标表达式转化为关于i，j的函数|f(i)-f(j)|，对于f(i)可能的情况有以下四种：<br>arr1[i]+arr2[i]+i<br>arr1[i]+arr2[i]-i<br>arr1[i]-arr2[i]+i<br>arr1[i]-arr2[i]-i<br>求出四种可能的最大值作为答案</p>
</li>
<li><p>添加边使所有节点度数都为偶数<br>分类讨论<br>建图，统计度数为奇数的点的个数odd.size()，简称size<br>如果size为0，返回true<br>如果size为2，且这两个点没有边，可以连一条边后满足条件，返回true<br>如果size为2，且这两个点有边，如果能找到一个点i与这两个点都没有边，那么添加两条边后满足条件，返回true<br>如果size为4，将这四个点记为a，b，c，d：<br>如果a和b没有边 且 c和d没有边 分别添加边后满足条件，返回true<br>如果a和c没有边 且 b和d没有边 同上<br>如果a和d没有边 且 b和c没有边 同上<br>其他情况无法满足条件，返回false</p>
</li>
<li><p>英雄的力量<br>排序+数学 贡献法<br>选取与顺序无关，对数组进行排序<br>遍历数组，对于每个nums[i]，把nums[i]作为最大值，考虑对答案的贡献<br>推出计算式，对每个nums[i]计算贡献值，累加得到答案</p>
</li>
<li><p>将数组排序的最少替换次数<br>贪心+数学<br>倒序遍历数组，维护目前出现的最小值min<br>若nums[i]大于min，则将nums[i]进行拆解，拆解后最小值应尽可能大</p>
</li>
<li><p>摘水果<br>前缀和+枚举<br>枚举：<br>1.先向右走i步，再向左走（k-i）步的情况<br>2.先向左走i步，再向右走（k-i）步的情况<br>使用前缀和快速求出某个区间内的水果数量</p>
</li>
<li><p>查找给定哈希值的子串<br>数学+大数<br>对于子串[i,i+k-1]的哈希值，通过哈希表达式比较，发现可由[i+1,i+k-1+1]在 O(1) 时间内计算得出<br>倒序计算每个长度为k的哈希值，找到目标哈希值则返回答案<br>计算数字较大，可使用BigInteger防止溢出</p>
</li>
<li><p>使序列递增的最小交换次数<br>动态规划<br>只能交换相同下标的元素，题目保证有解<br>定义dp[i][0]表示到下标i为止让两个数组严格递增,且下标i不进行交换的最小交换次数<br>定义dp[i][1]表示到下标i为止让两个数组严格递增,且下标i进行交换的最小交换次数</p>
</li>
<li><p>使序列递增的最小交换次数<br>动态规划<br>定义dp[i][0]表示到下标i为止，下标i不进行交换的最小交换次数<br>定义dp[i][1]表示到下标i为止，下标i进行交换的最小交换次数</p>
</li>
<li><p>考场就座<br>枚举<br>使用有序集合TreeSet维护有人的座位，编号为n-1的座位需要特判<br>调用seat时会枚举每两个座位中间的位置，维护离左右有人位置最远的空位置作为答案</p>
</li>
<li><p>翻转对<br>归并排序+二分<br>进行归并排序分治处理区间，枚举右部分区间，在左部分区间进行二分查找满足条件的元素个数，累加答案</p>
</li>
<li><p>执行乘法运算的最大分数<br>动态规划<br>定义dp[i][j]表示在nums中取前i个数字和后j个数字能得到的最大分数<br>初始化：dp[0][0]&#x3D;0,dp[0][i]由dp[0][i-1]转移而来，dp[i][0]由dp[i-1][0]转移而来<br>状态转移：dp[i][j]由dp[i-1][j]和dp[i][j-1]转移而来<br>由于答案可能为负数，ans初始化为Integer.MIN_VALUE 枚举选择前i个，则从后面取m-i个，维护最大分数</p>
</li>
<li><p>使网格图至少有一条有效路径的最小代价<br>最短路径<br>使用dijkstra算法求出起点到终点的最短距离即为答案<br>对于一个格子在四个方向上的相邻格子，只有grid与对应方向相同时到达该相邻格子的距离为0，其他情况距离为1</p>
</li>
<li><p>统计同位异构字符串数目<br>组合计数+小费马定理求逆元<br>每个单词的排列是独立的，计算出每个单词的总排列数进行相乘得到答案<br>对于一个单词str[i] 长度为len 排列总数为(len的阶乘)&#x2F;(26个字母的出现个数的阶乘的累乘) 记分母为a，分子为b<br>现在需要计算(a&#x2F;b)%mod,对大数除法求余而言存在精度问题，使用小费马定理求逆元将(a&#x2F;b)%mod转化为a*pow(b,m-2)%mod<br>可以使用上述等式的前提有两个<br>1.mod是质数（本题中mod为1e97，是质数）<br>2.a不能被m整除（在计算a时，将a不断对m求余可满足这个条件）</p>
</li>
<li><p>整数拆分<br>数学+贪心<br>对于正整数n，拆分出来的正整数个数越多，乘积越大<br>由于k&gt;&#x3D;2，n为2或n为3时单独讨论<br>n&gt;&#x3D;4时，讨论n对3取余的余数mod：<br>mod为0，将n拆成 n&#x2F;3 个 3 得到最大乘积<br>mod为1，将n拆成(n-4)&#x2F;3 个 3 和 2 个 2 得到最大乘积<br>mod为2，将n拆成(n-2)&#x2F;3 个 3 和 1 个 2 得到最大乘积</p>
</li>
<li><p>好因子的最大数目<br>数学+贪心<br>本质上与 343. 整数拆分 大致相同，343这题要求至少拆为两个数，本题可以不拆<br>给定n，需要构造一个整数num，num可以分解为一些已去重的质因数a1,a2,a3….<br>设a1有b1个，a2有b2个，a3有b3个…. 需要满足b1+b2+b3….&#x3D;n<br>好因子由a1，a2，a3…分别取不同个数得来的，a1，a2，a3….具体取什么值并不重要，只需考虑如何把m拆成一些数b1，b2，b3….<br>因此答案就是求b1<em>b2</em>b3….的最大值，题目等价于拆m使得拆出来的数相乘得到最大值</p>
</li>
<li><p>使子数组元素和相等<br>分组+中位数贪心+裴蜀定理<br>假设数组不循环，对于子数组[i,i+k-1]，与子数组[i+1,i+k]的元素总和需要相等,则有：nums[i]&#x3D;nums[i+k]，整个数组被划分为k个组，组内元素值相等<br>但数组是循环数组，那么有周期n，n为数组长度，同时有周期k，由裴蜀定理可得数组必定有周期gcd(n,k)<br>因此将数组分为gcd(n,k)组。对于一组元素，要通过操作变成相等，有结论：变成中位数的操作次数最少，分组计算运算次数得到答案</p>
</li>
<li><p>N 次操作后的最大分数和<br>状态压缩+记忆化搜索<br>dfs(status,index,nums) status表示已选数字 index表示已选次数</p>
</li>
<li><p>优质数对的数目<br>等价转换+枚举<br>结论：bitCount(x|y)+bitCount(x&amp;y)&#x3D;bitCount(x)+bitCount(y)<br>优质数对(x,y)只计一次，因此数组中有多个x和多个y冗余，先对数组进行去重<br>使用map统计去重后的数组每个元素的bitCount以及出现次数<br>双重循环枚举bitCount1和bitCount2，满足相加&gt;&#x3D;k时根据乘法原理统计到答案中</p>
</li>
<li><p>使数组相似的最少操作次数<br>排序+贪心<br>题目保证有解 对数组进行排序 贪心地将nums中较小的数字变成target中较小的数字能得到最少操作次数<br>由于奇数和偶数不能相互转换，因此需要分为奇、偶两组进行计算<br>当奇偶性相同时nums[i]与target[i]最少差距为2<br>对于同奇偶的两个数字，先除4得到操作次数，如果对4求余为2，额外记录差距为2的个数cnt，注意cnt在奇偶两组是共享的，最后加上cnt&#x2F;2次</p>
</li>
<li><p>猜猜这个单词<br>启发式极小化极大算法猜测单词</p>
</li>
<li><p>从第一个节点出发到最后一个节点的受限路径数<br>最短路径+记忆化dfs<br>将节点映射到[0,n-1],使用dijkstra算法求出n-1到其他点的最短路径<br>从0开始dfs搜索到达n-1的受限路径数</p>
</li>
<li><p>将数组分成三个子数组的方案数<br>前缀和+二分<br>使用前缀和快速计算区间总和<br>将数组拆分为[0,i] [i+1,j] [j,n-1]<br>固定i，j的取值范围为[i+1,n-2]：<br>二分查找最小的j满足sum(0,i)&lt;&#x3D;sum(i+1,j)，记最小的j为min<br>二分查找最大的j满足sum(i+1,j)&lt;&#x3D;sum(j+1,n-1)，记最大的j为max<br>如果min和max都是合法的，那么ans+&#x3D;max-min+1</p>
</li>
<li><p>奇偶跳<br>预处理+记忆化dfs<br>使用TreeMap&lt;Integer,TreeSet<Integer>&gt; 存储数字和出现过的下标，得到每个下标的下一次奇数跳跃到达的位置和下一次偶数跳跃到达的位置<br>对每个下标进行dfs，判断最终能否到达数组末尾</p>
</li>
<li><p>打家劫舍 IV<br>二分<br>二分查找最小的窃取能力</p>
</li>
<li><p>第 K 条最小指令<br>动态规划+组合计数<br>V&gt;H，对于一个位置index，如果放V，则所有在index位置放H的字符串的字典序都比它小，比它小的字符串的总数有 （组合数：从h+v-1中取h-1个）<br>使用动态规划来计算组合数，dp[i][j]表示从i中取j个的组合数数量<br>根据k与dp值的大小依次确定每个位置放V还是放H</p>
</li>
<li><p>构建字典序最大的可行序列<br>dfs+回溯<br>数据量较小，按题意进行dfs+回溯，枚举每个位置填的数</p>
</li>
<li><p>两个线段获得的最多奖品<br>滑动窗口+动态规划<br>定义dp[i]表示下标i之前一条线段可获得的最多奖品数量<br>维护满足条件的一条线段[left,right]，每次得到这样一条线段时，用right-left+1+dp[left]来更新答案<br>同时dp[right+1]&#x3D;max(dp[right],right-left+1)</p>
</li>
<li><p>通过给定词典构造目标字符串的方案数<br>记忆化dfs<br>dfs(index,k)表示当前正在寻找target的index下标，当前words中被限制的起始位置为k<br>index&gt;&#x3D;target.length()时说明找到一种可行方案 k&gt;&#x3D;words[0].length()时说明当前状态无解</p>
</li>
<li><p>最近的房间<br>排序+有序列表<br>对房间面积从大到小排序，对查询按至少需要的面积从大到小排序<br>遍历排序后的查询，把所有满足面积&gt;&#x3D;当前minSize的房间的id放入有序列表TreeSet中<br>对每次查询，调用有序列表的floor和ceiling获取距离当前preferred最近的id，检查是否合法，填入本次查询的答案</p>
</li>
<li><p>并行课程 II<br>状态压缩+动态规划<br>对于每个状态i，先枚举状态valid（不包含任何i的前置课程），如果valid课程数&lt;&#x3D;k，dp[i]可由dp[i ^ valid] + 1转移得到<br>否则枚举valid的子集sub，dp[i]由最小的dp[i ^ sub] + 1转移得到</p>
</li>
<li><p>并行课程 III<br>记忆化dfs<br>dfs(i)表示完成课程i最少月份数，取最大的dfs(i)作为答案<br>对于一个课程i，如果没有前置课程，完成时间为time[i]<br>如果有前置课程，则完成时间为max(dfs(pre))+time[i]</p>
</li>
<li><p>使数组连续的最少操作数<br>去重排序+双指针<br>先对nums进行去重并排序，枚举以每个nums[i]为起点使数组连续的最少操作数<br>以nums[i]开头，nums[i]+all-1结尾时，使用指针p找出nums中满足值在该区间内的元素个数cnt，操作次数为all-cnt</p>
</li>
<li><p>检查是否有合法括号字符串路径<br>记忆化BFS+剪枝<br>容易想到BFS解法，存储到每个位置时括号的状态，令左括号值为1，右括号值为-1，可能合法的括号字符串始终有值&gt;&#x3D;0，到达终点时合法的字符串值&#x3D;&#x3D;0<br>剪枝：搜索到(i,j)位置时，若剩余格子数目小于当前左右括号之间的差值，后续不可能找到合法括号序列<br>使用三维数组cache来存储某状态是否已访问过，同一个下标(x,y)同一个字符串值val只访问一次，对应cache[x][y][val]</p>
</li>
<li><p>按位与为零的三元组<br>枚举<br>题目需要求nums[i]&amp;nums[j]&amp;nums[k]等于0的三元组个数，可以使用双重循环预处理每个nums[i]&amp;nums[j]的出现次数，存入哈希表中<br>再枚举nums[k]，从哈希表中获取key和value，若nums[k]&amp;key&#x3D;&#x3D;0，则ans+&#x3D;value</p>
</li>
<li><p>查找集群内的关键连接<br>tarjan算法<br>模板题</p>
</li>
<li><p>石子游戏 V<br>动态规划+前缀和<br>定义dp[i][j]表示在区间[i,j]的石子中Alice能得到的最大分数<br>初始化：所有dp[i][i]表示剩余一个石子，游戏结束，Alice得分为0，因此dp[i][i]初始化为0<br>对每个区间[i,j]枚举割点k，分割为[i,k] [k+1,j] 通过前缀和快速获取两部分的值a，b<br>如果a&lt;b dp[i][j]由a+dp[i,k]转移而来<br>如果a&gt;b dp[i][j]由b+dp[k+1][j]转移而来<br>如果a&#x3D;&#x3D;b Alice自行选择，dp[i][j]由max(a+dp[i,k],b+dp[k+1][j])转移而来</p>
</li>
<li><p>不同骰子序列的数目<br>动态规划<br>定义dp[i][j][k]表示满足条件，长度为i，倒数第二个元素为j，最后一个元素为k的序列数目<br>n为1时，返回6<br>初始化长度为2的序列数目，枚举j、k，若j!&#x3D;k且gcd(j,k)&#x3D;&#x3D;1，则初始化dp[2][j][k]为1<br>从长度3开始计算到长度n，对于每个长度，枚举后两个位置j、k，枚举上一个排列的后两个位置t、j，dp[i][j][k]由所有合法的dp[i-1][t][j]相加得到<br>最后累加所有合法的dp[n][j][k]得到答案</p>
</li>
<li><p>得到回文串的最少操作次数<br>贪心<br>数据量较小，可直接模拟交换<br>解决[left,right]区间变成回文串：对于每个s[left]，找到距离右侧最近的相同字符s[i]，将s[i]换到s[right]的位置，变成解决[left+1,right-1]子问题<br>如果没有找到这样的s[i]，说明s[i]出现奇数次，模拟将其换到字符串最中间，解决[left+1,right]子问题<br>注意奇数次的s[i]不能先模拟换到中间，这样做接下来解决[left+1,right-1]子问题时会再次移动该s[i]，产生额外开销<br>因此遇到奇数次s[i]先记录交换到中间所需要的次数，等解决所有问题，即解决[left+1,right]子问题后再将其换到字符串最中间</p>
</li>
<li><p>最大的团队表现值<br>排序+优先队列<br>构造二维数组data同时存每个工程师的速度和效率，将data按效率从高到低排序<br>遍历data数组，优先队列存放速度最大的前k个工程师的速度，同时使用sum维护优先队列中的速度之和<br>对于每个i，当data[i][1]为最低效率时，更新ans&#x3D;max(ans,sum*data[i][1])</p>
</li>
<li><p>机器人碰撞<br>排序+栈模拟<br>对pos进行排序，使用栈进行模拟碰撞</p>
</li>
<li><p>完成所有交易的初始最少钱数<br>思维<br>将交易分成loss亏损，earn盈利两组，有两种情况钱可能最少：<br>1.进行所有亏损的交易，其中能得到最大cashback的这笔交易的cashback还没得到时<br>2.进行所有亏损的交易，再进行盈利交易中最大cost的这笔交易，且对应的cashback还没得到时<br>取两种情况钱最少的情况就是需要的初始最少钱数</p>
</li>
<li><p>最后一块石头的重量 II<br>动态规划 01背包<br>将题目转化为：一个数组nums，元素和为sum，现在需要取出一部分元素与另一部分元素取差，求差的最小值<br>要得到差的最小值，分出来的两部分值需要尽可能接近target&#x3D;sum&#x2F;2<br>定义dp[i][j]表示从前i个元素中取出一些元素，在元素和不超过j的情况下能得到的最大元素和<br>最后dp[n][target]就是最接近target的元素和，另一部分为sum-dp[n][target]，求两部分的差的绝对值作为答案</p>
</li>
<li><p>课程表 III<br>贪心+优先队列<br>对课程按截止时间从小到大排序，优先完成截止时间早的课程<br>使用优先队列保存完成的每个课程的持续时间duration，同时维护优先队列中所有课程需要的时间总和allTime<br>当完成课程i（duration_i,lastDay_i）后，allTime &gt; lastDay_i ，则需要从优先队列中取消掉占用时间最大的课程<br>最后优先队列中课程的数量就是答案</p>
</li>
<li><p>会议室 III<br>优先队列+双堆模拟<br>使用两个优先队列分别保存空闲房间和使用中的房间的编号，模拟安排会议，记录每个房间的使用次数</p>
</li>
<li><p>统计定界子数组的数目<br>枚举<br>遍历数组，维护上一个minK,maxK的位置preMin,preMax以及上一个超出[minK,maxK]范围的元素位置preUnValid<br>对于下标i，如果当前下标元素合法且preMin,preMax都出现过，则对答案的贡献为min(preMin,preMax)-preUnValid<br>如果下标i元素非法，重置preMin,preMax为-1，且更新preUnValid&#x3D;i</p>
</li>
<li><p>到达目的地的方案数<br>最短路+优先队列<br>使用dijkstra算法计算到达终点的最短距离，同时维护以最短路径到达每个节点的方案数<br>注意：new PriorityQueue&lt;&gt;((o1,o2)-&gt;Long.compare(dis[o1],dis[o2]))<br>当修改了 dis 数组中的值时，优先队列中的元素不会及时更改顺序<br>在修改dis[v]值后，应remove(v)再add(v)</p>
</li>
<li><p>有序队列<br>思维<br>当k&#x3D;1时，可以不断改变字符串的首字符，将s复制一份，枚举每种情况，取字典序最小的作为答案<br>当k&gt;1时，可以得到任意顺序的字符串s，对s中的字符排序，得到最小字典序的字符串作为答案<br>原因：当k&gt;1时，可以选择字符串 s 中的任意两个相邻字母交换它们的顺序，重复这个过程直到得到任意顺序的字符串</p>
</li>
<li><p>水位上升的泳池中游泳<br>二分+BFS<br>将题目转化为：一条路径的开销是该路径经过的格子中的最大值，求到达终点的所有路径中的最小开销<br>二分查找最小开销，BFS判断能否到达终点</p>
</li>
<li><p>阶乘后的零<br>数学<br>每一个0都是由2因子和5因子组合得到，因此需要找到所有乘数中的2和5因子的个数，记为a，b<br>阶乘后的零个数就是min(a,b)个，由于5的因子永远少于2的因子的个数，因此统计因子5的个数即可</p>
</li>
<li><p>阶乘函数后 K 个零<br>二分+数学<br>二分查找阶乘后零的个数&gt;&#x3D;k+1的最小数，记为a<br>二分查找阶乘后零的个数&gt;&#x3D;k的最小数，记为b<br>答案为a-b</p>
</li>
<li><p>你能穿过矩阵的最后一天<br>二分+BFS<br>二分查找能从矩阵第一行到达矩阵最后一行的最后一天</p>
</li>
<li><p>对字母串可执行的最大删除数<br>动态规划<br>预处理出s的每个后缀之间的最长公共前缀长度<br>定义dp[i]表示[i,n-1]子串可执行的最大删除数，dp[0]作为答案</p>
</li>
<li><p>找出最安全路径<br>二分+BFS<br>二分查找最大的安全系数</p>
</li>
<li><p>得到整数零需要执行的最少操作数<br>枚举<br>枚举操作次数i，i最少为0，最多为60<br>对于操作次数i，问题转化为target&#x3D;num1-i*num2是否可以拆分为i个2^t(t可取[0,60])<br>如果target&lt;i 即使每个t都取最小的0，也无法完成拆分<br>否则获取target对应的二进制中1的数量count，如果i&gt;&#x3D;count则一定可以拆分，返回i<br>为什么i&gt;&#x3D;count时一定可以拆分？因为一个2^t 可以拆分为两个2^(t-1) 当i大于count时可以多拆分几次凑出i个2^t</p>
</li>
<li><p>统计特殊整数（数位dp）<br>dfs+记忆化搜索<br>提交记录：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-special-integers/submissions/467426645/">https://leetcode.cn/problems/count-special-integers/submissions/467426645/</a></p>
</li>
<li><p>统计一个字符串的 k 子序列美丽值最大的数目<br>贪心+组合数<br>统计字母出现次数，优先选择出现次数最大的字母组成子序列能得到最大美丽值<br>对于出现次数为key次的字符，有value个，如果value&gt;k 需要从value中取k个，否则可以全选<br>若全选 一共value种字符，每种字符都要选一个，而每种字符一共有key个 根据乘法原理 对答案的贡献为pow(key,value)<br>若从value中选取k个 对答案的贡献为pow(key,k) * comb(value,k) 其中comb函数用来求组合数</p>
</li>
<li><p>扣分后的最大得分<br>动态规划<br>定义dp[i][j]表示到下标为i的行为止且下标为i的行选择下标为j的格子的最大得分<br>dp[i][j]由dp[i-1][j’]得到，分类讨论j’与j的关系<br>当j’&lt;&#x3D;j 时，Math.abs(j-j’) &#x3D; j-j’ 此时dp[i][j]&#x3D;max(dp[i-1][j’]-Math.abs(j-j’))&#x3D;max(dp[i-1][j’]+j’)-j<br>当j’&gt;j 时，Math.abs(j-j’)&#x3D;j’-j 同理dp[i][j]&#x3D;max(dp[i-1][j’]-j’)+j</p>
</li>
<li><p>查询差绝对值的最小值<br>前缀和<br>注意到1 &lt;&#x3D; nums[i] &lt;&#x3D; 100，使用pre[][101]记录每个下标位置每个数字的个数<br>对于查询[left,right]，通过pre数组可以获取该区间内每个数字的个数，差绝对值的最小值只可能出现在相邻的数字之间<br>使用num维护上一个出现过的数字，当j出现的次数不为0时，res&#x3D;min(res,j-num)，最后res即为本次查询的答案</p>
</li>
<li><p>统计农场中肥沃金字塔的数目<br>动态规划<br>定义dp[i][j]表示以格子(i,j)为顶部的最大金字塔高度<br>先考虑正金字塔的计算：从矩阵最后一行最后一列开始倒着遍历每个格子(i,j)<br>对于一个格子(i,j)如果是肥沃的，且(i+1,j-1)、(i+1,j)、(i+1,j+1)都是肥沃的，那么dp[i][j]&#x3D;min(dp下方三个格子)+1<br>最后累加所有dp值得到所有正金字塔的数量，上下翻转矩阵，再计算一遍dp，得到倒金字塔的数量，正、倒金字塔数量加起来作为答案</p>
</li>
<li><p>黑格子的数目<br>哈希表<br>对于一个黑格子，记录受影响的四个块的左上角下标，存入哈希表中<br>遍历所有受影响的块，对每个块记录黑格子的数量</p>
</li>
<li><p>最长合法子字符串的长度<br>滑动窗口<br>forbidden中的字符串长度最多为10<br>使用滑动窗口枚举最长合法字符串<br>对于某个子串，遍历前10个字符和后10个字符，使用哈希表快速检查是否合法</p>
</li>
<li><p>最小化数对的最大差值<br>排序+二分<br>对数组排序后二分查找最大差值的最小值</p>
</li>
<li><p>字符串连接删减字母<br>记忆化dfs<br>定义dfs(index,left,right)表示：<br>从下标index开始直到连接完毕，之前字符串的首字符为left，尾字符为right对答案的总贡献<br>答案：dfs(1,words[0][0],words[0][-1])+len(words[0])</p>
</li>
<li><p>队列中可以看到的人数<br>倒序遍历+单调栈<br>倒序遍历队列，使用高度单调递减栈（存放下标）维护右侧可以看到的人<br>对于下标i，栈顶元素top，如果h[i]&lt;&#x3D;h[top]，i看不到top右侧的人，跳出循环<br>如果h[i]&gt;h[top]，则i左侧的人也看不到top及top右侧的人，将top出栈</p>
</li>
<li><p>用地毯覆盖后的最少白色砖块<br>动态规划<br>定义dp[i][j] 表示使用i条地毯，覆盖到下标为j的砖块时所剩余的最少白色砖数<br>使用0条地毯的情况：dp[0][i]&#x3D;dp[0][i-1]+floor.charAt(i)-‘0’;<br>当j&lt;i<em>carpetLen时，dp[i][j]&#x3D;0，可以完全覆盖<br>当j&gt;&#x3D;i</em>carpetLen时，dp[i][j]&#x3D;Math.min(dp[i][j-1]+floor.charAt(j)-‘0’,dp[i-1][j-carpetLen]);<br>上述转移式中，dp[i][j-1]+floor.charAt(j)-‘0’表示对于下标j不铺地毯，后者表示在下标j铺一条地毯，且地毯末尾在下标j</p>
</li>
<li><p>餐盘栈<br>模拟+有序集合<br>使用两个TreeSet分别维护非满栈的下标、非空栈的下标，模拟操作</p>
</li>
<li><p>分割数组使乘积互质<br>质因数分解<br>遍历数组，对每一个元素进行质因数分解，同时记录某个质因数最晚出现的下标<br>遍历[0,n-1]，如果对于[0,i]出现过的质因数的最晚出现下标均&lt;&#x3D;i，则i为答案</p>
</li>
<li><p>最大公约数遍历<br>质因数分解+并查集<br>特判：出现元素1时，当且仅当数组长度为1时返回true<br>对每个nums[i]进行质因数分解，假设x为nums[i]的质因数，则合并nums[i]与x，以及nums[i]与nums[i]&#x2F;x<br>通过并查集判断所有nums[i]是否位于同一个集合中，若是返回true</p>
</li>
<li><p>树节点的第 K 个祖先<br>树上倍增（动态规划）<br>定义dp[i][j]表示节点i的第2^j个祖先节点<br>初始化：当j&#x3D;0时，dp[i][0]表示节点i的第一个祖先，也就是parent[i]<br>状态转移：枚举祖先2^j，再枚举节点，对于节点i：i的第2^(j+1)个祖先是i的第2^j个祖先的第2^j个祖先<br>表达式：dp[i][j+1]&#x3D;dp[ dp[i][j] ][j]<br>查询祖先：查询第k个祖先时，将k拆分为2的幂相加，例如当k&#x3D;13时，拆为1+4+8：<br>从当前节点跳到第1个祖先，接着从这个祖先跳到这个祖先的第4个祖先，最后从现在的祖先跳到现在祖先的第8个祖先完成查询<br>没有祖先时用-1表示，状态转移时没有祖先的状态将继续转移</p>
</li>
<li><p>最多可达成的换楼请求数目<br>状态压缩+dfs+回溯<br>数据量较小，且每一个请求都是相互独立的，枚举每个请求是否被满足，最后判断状态是否合法，若合法则更新最多同时满足请求的数目</p>
</li>
<li><p>可以被 K 整除连通块的最大数目<br>dfs+思维<br>对于某个节点i，如果i及其所有子节点之和sum满足sum%k&#x3D;&#x3D;0，则可以将节点i与其父节点连接的边删除<br>由于是无向树，每个节点都可以认为是根节点，为方便计算，认为0节点是根节点进行dfs得到答案</p>
</li>
<li><p>重排水果<br>哈希表+排序+思维<br>首先用map统计两个果篮中所有元素值及其出现个数，如果某个元素的出现次数v为奇数，则无法使两个果篮在重排后相等，返回-1<br>否则，一定存在交换方案。<br>对map中所有元素v除以2，得到在满足题目条件的情况下其中一个果篮的元素值及其个数，再将map与第一个果篮进行比较<br>从而得出哪些元素需要从第二个果篮换到第一个果篮，哪些元素需要从第一个果篮换到第二个果篮，分别存入to1、to2<br>对o1和o2排序，o1最小的元素与o2最大的元素进行交换，或者以最小值为中介，通过2*min成本进行交换，统计成本得到答案</p>
</li>
<li><p>戳气球<br>记忆化搜索+逆向思维<br>逆向思考，考虑在区间里填充气球，最后填满整个区间。为计算方便，补充下标-1和下标n位置，记其元素值为1<br>定义dfs(int left,int right)表示将开区间(left,right)填满最多得到的硬币数<br>对于dfs(left,right)枚举先填充的位置mid，则得到的硬币为nums[left]+nums[mid]+nums[right]+dfs(left,mid)+dfs(mid,right)<br>返回所有可能的mid中得到硬币最多的作为结果，记忆化dfs函数可以优化时间复杂度</p>
</li>
<li><p>切棍子的最小成本<br>记忆化搜索<br>为cuts添加左侧0和右侧n，存入list<br>定义dfs(left,right)表示将list中下标left到下标right切割开的最小成本<br>枚举中间点i，i的范围为[left+1,right-1]，切割成本为list.get(right)-list.get(left)+dfs(left,i)+dfs(i,right)<br>注意当left+1&gt;&#x3D;right时，无需切割，切割成本为0</p>
</li>
</ol>
<p>对数组执行操作使平方和最大<br>等价转换<br>选择两个互不相同的下标 i 和 j ，同时 将 nums[i] 更新为 (nums[i] AND nums[j]) 且将 nums[j] 更新为 (nums[i] OR nums[j])：<br>等价于把一个数的 0 和另一个数的同一个比特位上的 1 交换。统计每个比特位上1的个数，尽可能凑出1个数最多的k个数将其平方和相加得到答案</p>
<ol start="2732">
<li><p>找到矩阵中的好子集<br>枚举+思维<br>枚举好子集中的元素个数<br>好子集中元素个数为1的情况：如果出现某一行i全为0，则[i]是好子集，返回答案<br>好子集中元素个数为2的情况：如果行i，行j每一列相加&lt;&#x3D;1，则[i,j]是好子集，返回答案<br>好子集中元素个数为3的情况：每列相加之和&lt;&#x3D;1,那么可以去掉其中一行，变成元素个数为2的情况<br>又由于列最多为5，可以证明好子集中元素个数&gt;&#x3D;4可以转化为好子集中元素个数为0或1或2的情况<br>因此只需考虑1和2，都没找到答案则返回空列表</p>
</li>
<li><p>所有子数组中不平衡数字之和<br>枚举+哈希计数<br>固定子数组左端点i，枚举右端点j（j&gt;&#x3D;i+1，因为长度为1的子数组没有不平衡数字）<br>每新增一个元素num，子数组的不平衡度count+1<br>如果子数组中存在num-1，则count–，如果存在num+1，则count–<br>累加所有子数组的不平衡度count得到答案</p>
</li>
<li><p>将数组清空<br>树状数组<br>使用指针p标记当前数组的第一个元素，问题转化为用指针p从小到大依次遍历数组中的所有元素<br>使用树状数组维护某个区间已删除的元素个数count，指针p移动到p2时需要减去count<br>当p2&gt;&#x3D;p时，将p移动到p2；当p2&lt;p时，p先移动到数组边界n，到达1，再从1移动到p2</p>
</li>
</ol>
<p>最长相邻不相等子序列 II<br>后缀dp<br>使用动态规划枚举选哪个可解决本题。由于最后需要得到子序列，因此定义dp[i]表示从[i,n-1]中选择满足条件的最长子序列的长度<br>同时使用from[i]来记录dp[i]是由下标from[i]转移得到的</p>
<p>找出满足差值条件的下标 II<br>双指针<br>需要找到两个下标[i,j]，设 j &gt;&#x3D; i，则 abs(i - j) &gt;&#x3D; indexDifference  等价于 j - indexDifference &gt;&#x3D; i<br>枚举j，维护所有满足i &lt;&#x3D; j - indexDifference的nums[i]可能的最大值和最小值，设对应下标分别为maxIndex和minIndex<br>如果出现abs(nums[maxIndex]-nums[j])&gt;&#x3D;valueDifference或abs(nums[minIndex]-nums[j])&gt;&#x3D;valueDifference说明找到满足条件的两个下标，直接返回答案</p>
<ol start="972">
<li><p>相等的有理数<br>模拟<br>将String转化为double，判断两个数之差是否小于0.0000000001</p>
</li>
<li><p>你能穿过矩阵的最后一天<br>二分+BFS<br>二分枚举答案，BFS判断是否可行</p>
</li>
</ol>
<p>使数组变美的最小增量运算数<br>dp<br>定义dp[i][j]表示到下标j位置，让下标i-2+j的元素&gt;&#x3D;k的最小增量运算数<br>初始化：dp[2][0<del>2]&#x3D;nums[0</del>2]&gt;&#x3D;k?0:k-nums[0~2]<br>状态转移：dp[i][0]&#x3D;dp[i-1][1];<br>            dp[i][1]&#x3D;dp[i-1][2];<br>            dp[i][2]&#x3D;(nums[i]&gt;&#x3D;k?0:k-nums[i])+Math.min(dp[i-1][0],Math.min(dp[i-1][1],dp[i-1][2]));<br>答案：Math.min(dp[n-1][0],Math.min(dp[n-1][1],dp[n-1][2]))			</p>
<ol start="1654">
<li><p>到家的最少跳跃次数<br>BFS<br>如何判断无解？<br>a&#x3D;&#x3D;b 最多跳到x处，大于x时无解<br>a&gt;b 最多跳到x+b处，大于x+b时无解<br>a&lt;b 最多跳到max(max(forbidden)+a+b,x)处，具体证明见官方题解</p>
</li>
<li><p>监控二叉树<br>树形dp<br>定义状态0，1，2：<br>状态0：当前节点安装相机的时候，需要的最少相机数<br>状态1： 当前节点不安装相机，但是能被覆盖到的时候，需要的最少相机数<br>状态2：当前节点不安装相机，也不能被左右孩子覆盖到的时候，需要的最少相机数(最后由父节点来覆盖它)<br>对于每个节点<br>如果它处于状态0，它的左右孩子可以安装也可以不安装，甚至可以不被覆盖：<br> dp[0] &#x3D; Math.min(left[0], Math.min(left[1], left[2])) + Math.min(right[0], Math.min(right[1], right[2])) + 1;<br>如果它处于状态1，它的左右孩子必有一个需要安装：<br>dp[1] &#x3D; Math.min(left[0] + Math.min(right[0], right[1]), right[0] + Math.min(left[0], left[1]));<br>如果它处于状态2，说明它的左右孩子都不安装，但是其左右孩子被它们的孩子覆盖：<br>dp[2] &#x3D; left[1] + right[1];<br>最后返回根节点得到的dp数组中Math.min(dp[0], dp[1])</p>
</li>
<li><p>统计特殊子序列的数目<br>动态规划<br>定义dp[i][0]表示前i个数 得到 由正整数个 0 组成的子序列的个数 记为【0】子序列<br>定义dp[i][1]表示前i个数 得到 由正整数个 0 紧接着正整数个 1 组成的子序列的个数 记为【1】子序列<br>定义dp[i][2]表示前i个数 得到 由正整数个 0 紧接着正整数个 1，最后正整数个 2 组成的子序列的个数 记为【2】子序列<br>状态转移：<br>num为0时，这个0可以与前面的所有【0】子序列组合形成【0】子序列，也可以单独成为【0】子序列，现在【0】子序列个数dp[i][0]&#x3D;dp[i-1][0]+dp[i-1][0]+1 其余子序列数量不变<br>num为1时，这个1可以与前面的所有【1】子序列组合形成【1】子序列，也可以单独和前面所有【0】子序列组合形成【1】子序列，现在【1】子序列个数dp[i][1]&#x3D;dp[i-1][1]+dp[i-1][1]+dp[i-1][0] 其余子序列数量不变<br>num为2时，这个2可以与前面的所有【2】子序列组合形成【2】子序列，也可以单独和前面所有【1】子序列组合形成【2】子序列，现在【2】子序列个数dp[i][2]&#x3D;dp[i-1][2]+dp[i-1][2]+dp[i-1][1] 其余子序列数量不变<br>答案：dp[n][2]</p>
</li>
<li><p>每棵子树内缺失的最小基因值<br>DFS<br>由于nums[i]互不相同，那么树中最多只有一个节点值为1<br>当树中没有节点值为1的节点时，整棵树都缺少基因1，返回全1数组<br>当树中找到节点值为1的节点，记该节点为x，x的所有子节点c肯定缺少基因1，ans[c]&#x3D;1<br>对x进行dfs，遍历所有子节点c，之后可以得到ans[x]<br>再不断对x的父节点进行dfs，直到根节点（每个节点最多遍历一次）</p>
</li>
<li><p>字符串连接删减字母<br>dp<br>定义dp[k][i][j]表示合并到下标k为止，合并后的字符串首字母为’a’+i，尾字母为’a’+j时的最小长度<br>所有dp初始为最大值，dp[0][words[0].charAt(0)-‘a’][words[0].charAt(words[0].length()-1)-‘a’]&#x3D;words[0].length()<br>状态转移：枚举k，记words[k]长度为len，第一个字母为fir，最后一个字母为las，则<br>枚举所有i，j<br>dp[k][fir][j]&#x3D;Math.min(dp[k][fir][j],dp[k-1][i][j]+(las&#x3D;&#x3D;i?len-1:len));<br>dp[k][i][las]&#x3D;Math.min(dp[k][i][las],dp[k-1][i][j]+(fir&#x3D;&#x3D;j?len-1:len));<br>答案：取最小的dp[n-1][i][j]</p>
</li>
<li><p>相邻字符不同的最长路径<br>DFS<br>对于每个节点x，dfs找到左子树能到达的最长路径和右子树能到达的最长路径，更新答案<br>由于需要从父节点出发向左右子树进行dfs，因此可以认为该图是有向图，只有父节点指向孩子节点的边<br>本题与树的直径十分类似，只是多了一个相邻节点的条件限制<br>注意：在dfs(i)时，不论孩子节点v是否满足s[i]&#x3D;&#x3D;s[v]都要进行dfs(v)，因为答案可能是以v为根节点的路径</p>
</li>
<li><p>切披萨的方案数<br>记忆化DFS+二维前缀和<br>枚举每次列切割的位置，或者行切割的位置，使用二维前缀和快速判断切割是否合法（即包含苹果）</p>
</li>
<li><p>得分最高的最小轮调<br>差分<br>对于元素 x，当所在下标大于或等于x时，元素x会加1分<br>因此x计1分的下标范围是[x,n−1]，有n−x个下标计分<br>元素x不计分的下标范围是 [0,x−1]，有x个下标不计分<br>假设x的初始下标为i，当论调k时，x将位于下标index &#x3D; (i-k+n)%n<br>如果此时x计分，则有index&gt;&#x3D;x 等价于k &lt;&#x3D; (i-x+n)%n 得到计分k的上限<br>由于计分的下标只有n-x个，从而得到计分k的下限k &gt;&#x3D; (i+1)%n<br>得到了某个元素计分时k的范围[low,high]，遍历所有元素：<br>使用差分数组diff 为diff[low]+&#x3D;1 diff[high+1]-&#x3D;1<br>最后还原差分数组，可以得到计分次数最多的k，这个k就是答案</p>
</li>
<li><p>多边形三角剖分的最低得分<br>记忆化dfs<br>定义dfs(i,j)表示从顶点i到顶点j得到三角形的最低分数<br>枚举点k 得到dfs(i,j)&#x3D;min(dfs(i, k) + dfs(k, j) + v[i] * v[j] * v[k])</p>
</li>
<li><p>处理含限制条件的好友请求<br>并查集<br>对于每一个请求{p,q}，先得到find(p)和find(q)<br>如果find(p)&#x3D;find(q) 已经在同一个集合中 ans[i]&#x3D;true<br>否则，枚举所有限制条件{a,b} 得到find(a)和find(b)<br>因为限制条件规定a和b不能在同一个集合中，如果将p，q合并会导致任意一对{a,b}被合并，即：<br>find(p)&#x3D;&#x3D;find(a)&amp;&amp;find(q)&#x3D;&#x3D;find(b)或者find(p)&#x3D;&#x3D;find(b)&amp;&amp;find(q)&#x3D;&#x3D;find(a)，那么p，q不能成为朋友<br>反之，可以合并p，q同时ans[i]&#x3D;true</p>
</li>
<li><p>保证图可完全遍历<br>并查集<br>考虑选择最少的边数量count，使得两人都可完全遍历图<br>使用并查集来维护可到达的顶点集合，parent为公共边，parentA，parentB分别代表两人单独边<br>先遍历公共边{v1,v2} 若find(v1)!&#x3D;find(v2)则选中这条边，否则不选<br>令parentA和parentB都复制parent中的数据，分别遍历单独边，如果不在同一个集合中则继续选择<br>判断两人是否分别可以完全遍历，即parentA和parentB中父节点只有一个，如果不满足返回-1<br>否则可以完全遍历，设全部边个数为m，答案为m-count</p>
</li>
<li><p>按位或最大的最小子数组长度<br>dp<br>定义dp[index]表示 位index的1 出现的最小下标<br>从后往前遍历nums 对于下标i的元素：<br>取所有出现过的dp[index]的最大值就是最远的1所在位置，由此计算得到ans[i]</p>
</li>
<li><p>子数组按位或操作<br>哈希集合<br>创建HashSet<Integer> ans存储所有可能的值，答案为ans.size()<br>创建HashSet<Integer> pre表示以上一个下标为结尾的子数组的所有结果，初始化pre.add(0)<br>对于每个下标i，创建HashSet<Integer> now,遍历pre中所有元素ele，向now添加nums[i]|ele<br>再把nums[i]放入now中，接着将now中所有元素放入ans中，并将pre标记为now</p>
</li>
<li><p>有序矩阵中的第 k 个最小数组和<br>暴力<br>存储上一行为止可以得到的数组和pre，对于pre中的所有元素ele，都添加ele+本行元素mat[i][j]到now中<br>由于只有正整数，因此只需保留最小的k个元素，取出前k小的元素重新赋给pre，最后pre.get(k-1)就是答案</p>
</li>
<li><p>找出最具竞争力的子序列<br>贪心+单调栈<br>等价于删除nums.length-k个元素，使剩下的元素按顺序形成的数字最小<br>使用单调栈预处理rightFloor数组，表示每个元素右边比其小的元素出现的下标，如果没有则为-1<br>遍历数组，如果rightFloor[i]!&#x3D;-1即右边有更小的元素且n-rightFloor[i]&gt;&#x3D;k即右边仍可选出超过k长度的子序列，那么nums[i]不选<br>否则选择nums[i]，记入答案数组中<br>题目 402. 移掉 K 位数字 与本题类似</p>
</li>
<li><p>最小差值 II<br>排序+贪心<br>元素顺序不影响答案，先对数组进行排序<br>考虑对整个数组全部增加或全部减少的情况，答案初始化为nums[n-1]-nums[0]<br>为了得到最大值和最小值的最小差值，枚举某个点i，[0,i]全部增加，[i+1,n]全部减少<br>对于这样的点i：<br>最大值max有两种可能：nums[i]+k 和 nums[n-1]-k<br>最小值min有两种可能：nums[0]+k 和 nums[i+1]-k<br>维护ans&#x3D;Math.min(ans,max-min)得到答案</p>
</li>
<li><p>由斜杠划分区域<br>dfs<br>将n<em>n的格子看成3n</em>3n的格子，也就是每个格子看成由9个小格子形成<br>对于两种斜杠，分别填充3个小格子<br>dfs查找联通分块得到答案</p>
</li>
<li><p>删除操作后的最大子段和<br>倒序回答 + 并查集<br>删除不好做，添加比较好做。不妨倒着思考，删除变成了添加<br>添加时进行合并，维护最大字段和</p>
</li>
<li><p>到达角落需要移除障碍物的最小数目<br>Dijkstra最短路<br>把障碍物看成花费1可到达的位置，使用Dijkstra计算到达角落的最短距离</p>
</li>
<li><p>超级回文数<br>暴力枚举<br>边界数字的长度最大为18，则其平方根长度最大为9，由于平方根是回文，则回文的左半部分长度最大为4<br>枚举回文的左半部分[1,10000]，构造回文，再平方后判断是否为超级回文数，注意剪枝跳过超出边界的枚举</p>
</li>
<li><p>两个数组最小的异或值之和<br>记忆化DFS<br>定义dfs(index,mask)表示从nums1的index下标开始计算，nums2的已选择情况为mask时两个数组最小的异或值之和<br>枚举nums1[index]与nums2中哪个元素进行异或运算：ret&#x3D;Math.min(ret,(nums1[index]^nums2[i])+dfs(index+1,mask|(1&lt;&lt;i)))<br>注意异或运算和加法的优先级，异或运算需要添加括号</p>
</li>
<li><p>查询差绝对值的最小值<br>前缀和<br>数组中的元素范围较小，对每个数字统计前缀和<br>对于查询[left,right] 使用前缀和计算出该区间内不同数字出现的次数，维护差绝对值的最小值作为答案</p>
</li>
<li><p>可见点的最大数目<br>数学：求极角几何题</p>
</li>
<li><p>找出最安全路径<br>二分+BFS</p>
</li>
<li><p>前往目标的最小代价<br>Dijkstra最短路<br>把起点、终点和所有特殊路径的终点看成是图上的点，求最短路径</p>
</li>
<li><p>最小化数对的最大差值<br>二分<br>二分查找最大差值</p>
</li>
<li><p>服务中心的最佳位置<br>机器学习<br>使用梯度下降法求解</p>
</li>
<li><p>从栈中取出 K 个硬币的最大面值和<br>分组背包</p>
</li>
<li><p>序列顺序查询<br>对顶堆<br>维护一个大顶堆和一个小顶堆，大顶堆的元素都小于小顶堆的元素</p>
</li>
<li><p>还原原数组<br>枚举<br>暴力枚举index，判断在nums[0]与nums[index]配对情况下是否合法</p>
</li>
<li><p>分割数组使乘积互质<br>质因数分解<br>记录每一个质因数最后出现的位置，遍历数组，对当前数字进行质因数分解，用index表示[0,i]中的质因数最后出现的位置，当i&#x3D;&#x3D;index时，i就是答案</p>
</li>
<li><p>逃离大迷宫<br>BFS<br>在网格中，要知道点s与点t是否连通<br>由于障碍物数量比较少，问题转化为判断点s和点t是否被障碍物及网格边界完全包围<br>判断某个点是否被边界及障碍物完全包围，可以从该点出发进行BFS判断能到达的网格数<br>障碍物最多n个，可以用BFS能否到达至少n*(n-1)&#x2F;2个格子来判断某个点是否被包围<br>如果BFS能访问超过1e5格子，认为没有被包围<br>对点s和点t分别进行BFS，如果都没有被包围返回true，反之返回false</p>
</li>
<li><p>第 K 个最小的素数分数<br>模拟<br>双循环构造分数并排序</p>
</li>
<li><p>向下取整数对和<br>前缀和<br>对于表达式floor(nums[i] &#x2F; nums[j])，固定nums[j]，有多个nums[i]使得该表达式值相同，枚举这样的nums[i]的个数<br>使用前缀和快速得到个数进行统计</p>
</li>
<li><p>堆叠长方体的最大高度<br>贪心+排序+dp<br>把每个长方体最长的一条边作为高度才能得到最大高度<br>定义h[i]表示以下标为i的长方体作为堆叠后的顶部时能够得到的最大高度<br>h[i]由h[j]转移而来：h[i]&#x3D;max(h[j]+height[i]) 为长方体排序后双重循环枚举i和j<br>最后答案为max(h[i])</p>
</li>
<li><p>最大公约数遍历<br>质因数分解+并查集<br>gcd(nums[i], nums[j]) &gt; 1等价于nums[i]和nums[j]存在相同的质因数<br>对每个nums元素进行分解质因数，将质因数与该元素合并<br>最后使用并查集判断所有nums元素是否位于同一连通分量<br>注意需要特判nums元素中有1的情况</p>
</li>
<li><p>下一个更大元素 IV<br>双单调栈<br>从左往右遍历 nums，用（递减）单调栈stack记录元素，如果 x&#x3D;nums[i]比stack的栈顶大，则x是栈顶的下个更大元素，弹出栈顶。最后把x入栈（实际入栈的是其下标i）<br>把弹出的元素加到另一个栈stack2中（注意保持原始顺序，即按下标顺序，下标小的优先入栈），后续循环时，如果y&#x3D;nums[j]比stack2的栈顶大，则y栈顶的下下个更大元素，记录答案，弹出栈顶</p>
</li>
<li><p>黑格子的数目<br>哈希表<br>对于一个位于(x,y)的黑格子而言，它可能位于四个块中：<br>以(x-1,y-1)为左上角的块<br>以(x,y-1)为左上角的块<br>以(x-1,y)为左上角的块<br>以(x,y)为左上角的块<br>将这些可能受影响的块（的左上角）放入哈希表中<br>所有的块减去受影响的块得到ans[0]<br>遍历受影响的块，分别统计每个块中有多少个黑格子</p>
</li>
<li><p>最大化一张图中的路径价值<br>暴力dfs<br>分析题目数据发现合法路径最多递归10次，直接暴力dfs获取答案</p>
</li>
<li><p>到达目的地的第二短时间<br>动态边权+最短路径dijkstra<br>红绿灯切换问题：本质是动态边权<br>假设在T时间到达节点i，红绿灯切换时间为change，则有：<br>当 T&#x2F;change 为偶数时 处于绿灯时间不需要等待，边权为0<br>当 T&#x2F;change 为奇数时 处于红灯时间，等待时间为change - (T%change)，该值也就是边权<br>将节点编号映射为[0,n-1]，跑最短路径算法求解<br>题目要求第二短时间，因此使用dijkstra算法时，引入一个dis2数组，来维护节点0到节点i的次短路径，最后答案就是节点0到节点n-1的次短路径，也就是dis2[n-1] </p>
</li>
<li><p>使子序列的和等于目标的最少操作次数<br>贪心<br>缺少哪一位就从高位分解获取，注意已有的低位也可以凑出当前需要的位</p>
</li>
<li><p>树中距离之和<br>换根dfs<br>先通过dfs计算出节点root到所有节点的距离ans[root]<br>考虑从节点root转移到其子节点child：<br>对于child及其子树上的节点，距离更近了，记子树的所有节点数量为size<br>对于其他节点，距离更远了，这部分节点数量为n-size<br>可以得到转移方程：ans[child]&#x3D;ans[root] + (n-size) - size<br>根据转移方程得到所有答案</p>
</li>
<li><p>不同字符的最小子序列<br>贪心<br>统计每个字符的数量，使用ans构造答案，使用visit数组判断某个字符是否已经在ans中。遍历字符串，对于每个ch：<br>如果ans中的最后一个字符last&gt;ch而且右边还有字符last，那么把last从ans中删除，不断重复此过程，直到last不再大于ch或ans为空<br>此时再把ch放入ans中。遍历完字符串得到的ans就是答案</p>
</li>
<li><p>子序列宽度之和<br>排序+贡献法+数学<br>由于元素顺序对答案无影响，可对数组排序，计算每个元素对答案的贡献<br>对于一个元素num：<br>在某个序列中它作为最小值时，对答案的贡献为-num，作为最大值时，对答案的贡献为num<br>那么只要找出它作为最小值&#x2F;最大值时的序列总数，就可以得到num对答案的总贡献<br>假设num位于排序后数组的下标index，其左边有index个元素，这index个元素都有选&#x2F;不选两种状态，因此num作为最大值时的子序列个数为2^index，同理可得作为最小值时的子序列个数为2^(n-1-index)<br>遍历所有num累加贡献得到答案</p>
</li>
<li><p>最美子字符串的数目<br>状态压缩+前缀哈希<br>固定子字符串右端点，枚举有多少个满足条件的左端点<br>使用二进制数压缩字符串中每一个字符出现的奇偶次数状态<br>使用哈希表记录前缀的字符状态及其出现次数<br>对于每一个右端点的状态status，在前缀哈希表中的preStatus 只要满足与status的二进制表示最多有1位不同，那么preStatus就是符合条件的左端点，将其出现个数计入答案</p>
</li>
<li><p>找到矩阵中的好子集<br>分类讨论+思维<br>结论：如果一个子集是好子集，那么该子集的元素个数不超过2。<br>如果存在元素个数为1的好子集，等价于存在一行元素全为0矩阵<br>如果存在元素个数为2的好子集，这两行的每一列元素之和都为1<br>如果存在元素个数为3的好子集，这三行的每一列元素之和不超过1，必然可以去掉其中一行转化为元素个数为2的好子集<br>可以理解为答案好子集中的元素个数如果大于2，可以去掉一些行转化为2的情况，因此只需要考虑好子集的元素个数为1或2</p>
</li>
<li><p>按公因数计算最大组件大小<br>质因数分解+并查集<br>对每个元素进行质因数分解，再与质因数合并，统计最大的联通分量大小作为答案<br>例如元素ele存在质因数v，需要merge(ele,v)以及merge(ele,ele&#x2F;v)<br>注意：1不能与其他数字合并，因此当ele!&#x3D;v时才可以进行合并</p>
</li>
<li><p>满足条件的子序列数目<br>排序+二分查找+快速幂<br>由于考虑的是子序列，那么元素顺序不影响答案，先对数组进行排序<br>固定最小值，记最小值下标为left，二分查找满足条件的最大值可以出现的最大下标right<br>区间(left,right]的元素个数有count&#x3D;right-left个，这些元素每个都有选择&#x2F;不选两种情况，因此固定这个最小值对答案的贡献是pow(2,count)<br>统计每个最小值对答案的贡献即可</p>
</li>
<li><p>用邮票贴满网格图<br>二维前缀和+二维差分<br>如果一个区域的前缀和为0，说明可以放下邮票，贪心地放置邮票，并记录在差分数组中<br>最后遍历每个空格，通过差分数组还原该空格放置的邮票层数，如果为0返回false</p>
</li>
<li><p>只出现一次的数字 III<br>位运算<br>设答案为a，b<br>整个数组异或可以得到x &#x3D; a ^ b<br>x不为0，因为a不可能等于b，如果a等于b那么a就出现了两次与题目矛盾<br>寻找x的最低位1的位置，记为index，a和b在index位上的结果一定是一个为1，一个为0<br>将整个数组分为两类：index位为1的元素&#x2F;index位为0的元素<br>分别将这两类元素进行异或，就得到了a和b</p>
</li>
</ol>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-数据库" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2023-08-20T15:09:33.000Z"><a href="/2023/08/20/%E6%95%B0%E6%8D%AE%E5%BA%93/">2023-08-20</a></time>
      
      
  
    <h1 class="title"><a href="/2023/08/20/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h3 id="数据库基础概念"><a href="#数据库基础概念" class="headerlink" title="数据库基础概念"></a>数据库基础概念</h3><p>事务：满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚</p>
<p>ACID（事务的4个属性）：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原子性（Atomicity） 事务要么全部完成，要么全部取消</span><br><span class="line">一致性（Consistency） 合法的数据（根据关系约束、函数约束来判断是否合法）才能写入数据库</span><br><span class="line">隔离性（Isolation） 多个并发执行的事务操作相互隔离，互不影响，避免不一致和脏读</span><br><span class="line">持久性（Durability） 事务提交成功对数据库的改变是永久性的</span><br></pre></td></tr></table></figure>

<p>范式：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一范式：属性不可再分</span><br><span class="line">第二范式：每个非主属性完全函数依赖于主码</span><br><span class="line">第三范式：每个非主属性不传递函数依赖于主码</span><br></pre></td></tr></table></figure>

<p>关系型数据库设计流程：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">有以下6个阶段</span><br><span class="line"></span><br><span class="line">需求分析：分析用户的需求，包括数据、功能和性能需求</span><br><span class="line"></span><br><span class="line">概念结构设计：主要采用E-R模型进行设计，包括画E-R图</span><br><span class="line"></span><br><span class="line">逻辑结构设计：通过将E-R图转换成表，实现从E-R模型到关系模型的转换</span><br><span class="line"></span><br><span class="line">数据库物理设计：主要是为所设计的数据库选择合适的存储结构和存取路径</span><br><span class="line"></span><br><span class="line">数据库的实施：包括编程、测试和试运行</span><br><span class="line"></span><br><span class="line">数据库运行与维护：系统的运行与数据库的日常维护</span><br></pre></td></tr></table></figure>

<p>并发一致性问题：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">丢失修改：两个事务都对一个数据进行修改，事务1修改后事务2再次修改，事务2的修改覆盖了事务1的修改，导致事务1的修改丢失</span><br><span class="line"></span><br><span class="line">读脏数据：事务1对一个数据进行了修改，此时事务2读取了该数据，若事务1进行回滚，那么事务2读到的数据就是脏数据</span><br><span class="line"></span><br><span class="line">不可重复读：事务1读取一个数据，事务2对该数据进行了修改，此时事务1再读一遍该数据，发现两次读取的结果不同</span><br><span class="line"></span><br><span class="line">幻影读：事务1对数据集进行查询，事务2修改了该数据集，事务1再次查询发现两次查询得到的结果不同</span><br></pre></td></tr></table></figure>

<p>产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性</p>
<p>封锁粒度：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MySQL 中提供了两种封锁粒度: 行级锁以及表级锁</span><br><span class="line">应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高</span><br><span class="line">但是加锁需要消耗资源，锁的各种操作(包括获取锁、释放锁、以及检查锁状态)都会增加系统开销。因此封锁粒度越小，系统开销就越大</span><br><span class="line">在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡</span><br></pre></td></tr></table></figure>

<p>封锁类型：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">排它锁(Exclusive)，简写为 X 锁，又称写锁：一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁</span><br><span class="line">共享锁(Shared)，简写为 S 锁，又称读锁：一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁</span><br></pre></td></tr></table></figure>

<h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p>参考文章：<a target="_blank" rel="noopener" href="https://www.pdai.tech/md/db/sql-mysql/sql-mysql-overview.html">https://www.pdai.tech/md/db/sql-mysql/sql-mysql-overview.html</a></p>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>参考文章：<a target="_blank" rel="noopener" href="https://www.pdai.tech/md/db/nosql-redis/db-redis-overview.html">https://www.pdai.tech/md/db/nosql-redis/db-redis-overview.html</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-Spring框架的IOC、AOP" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2023-08-05T02:38:57.000Z"><a href="/2023/08/05/Spring%E6%A1%86%E6%9E%B6%E7%9A%84IOC%E3%80%81AOP/">2023-08-05</a></time>
      
      
  
    <h1 class="title"><a href="/2023/08/05/Spring%E6%A1%86%E6%9E%B6%E7%9A%84IOC%E3%80%81AOP/">Spring框架的IOC、AOP</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h1 id="原文章"><a href="#原文章" class="headerlink" title="原文章"></a>原文章</h1><p><a target="_blank" rel="noopener" href="https://javadoop.com/post/spring-ioc">https://javadoop.com/post/spring-ioc</a></p>
<p><a target="_blank" rel="noopener" href="https://javadoop.com/post/spring-aop-source">https://javadoop.com/post/spring-aop-source</a> </p>
<h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>IOC最重要的两个地方，一个是创建Bean容器，一个是初始化Bean</p>
<h6 id="启动Spring容器"><a href="#启动Spring容器" class="headerlink" title="启动Spring容器"></a>启动Spring容器</h6><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationfile.xml&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码利用配置文件applicationfile.xml启动了Spring容器</p>
<p>也可以使用其他方式启动Spring容器，下面是一张继承结构图<br><img src="/../images/1.png" alt="image">)<br>图中绿色标注的类也可以用来创建Spring容器：<br>FileSystemXmlApplicationContext 的构造函数需要一个 xml 配置文件在系统中的路径，其他和 ClassPathXmlApplicationContext 基本上一样</p>
<p>AnnotationConfigApplicationContext 是基于注解来使用的，它不需要配置文件，采用 java 配置类和各种注解来配置，是比较简单的方式</p>
<p>ApplicationContext 启动过程中，会负责创建实例 Bean，往各个 Bean 中注入依赖</p>
<h6 id="BeanFactory简介"><a href="#BeanFactory简介" class="headerlink" title="BeanFactory简介"></a>BeanFactory简介</h6><p>BeanFactory是生产 bean 的工厂，它负责生产和管理各个 bean 实例，前面说的 ApplicationContext 其实就是一个 BeanFactory</p>
<p>以下是和BeanFactory 接口相关的主要的继承结构：<br><img src="/../images/2.png" alt="image">)<br>其中比较重要的几个点</p>
<ul>
<li>ApplicationContext 继承了 ListableBeanFactory，这个 Listable 的意思就是，通过这个接口，我们可以获取多个 Bean，大家看源码会发现，最顶层 BeanFactory 接口的方法都是获取单个 Bean 的</li>
<li>ApplicationContext 继承了 HierarchicalBeanFactory，Hierarchical 单词本身已经能说明问题了，也就是说我们可以在应用中起多个 BeanFactory，然后可以将各个 BeanFactory 设置为父子关系</li>
<li>AutowireCapableBeanFactory 这个名字中的 Autowire 大家都非常熟悉，它就是用来自动装配 Bean 用的，但是仔细看上图，ApplicationContext 并没有继承它，不过不用担心，不使用继承，不代表不可以使用组合，如果你看到 ApplicationContext 接口定义中的最后一个方法 getAutowireCapableBeanFactory() 就知道了</li>
<li>ConfigurableListableBeanFactory 也是一个特殊的接口，看图，特殊之处在于它继承了第二层所有的三个接口，而 ApplicationContext 没有。这点之后会用到</li>
</ul>
<h6 id="启动过程分析"><a href="#启动过程分析" class="headerlink" title="启动过程分析"></a>启动过程分析</h6><p>ClassPathXmlApplicationContext 的构造方法</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class ClassPathXmlApplicationContext extends AbstractXmlApplicationContext &#123;</span><br><span class="line"></span><br><span class="line">  private Resource[] configResources;</span><br><span class="line"></span><br><span class="line">  // 如果已经有 ApplicationContext 并需要配置成父子关系，那么调用这个构造方法</span><br><span class="line">  public ClassPathXmlApplicationContext(ApplicationContext parent) &#123;</span><br><span class="line">    super(parent);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent)</span><br><span class="line">      throws BeansException &#123;</span><br><span class="line"></span><br><span class="line">    super(parent);</span><br><span class="line">	</span><br><span class="line">    // 根据提供的路径，处理成配置文件数组(以分号、逗号、空格、tab、换行符分割)</span><br><span class="line">    setConfigLocations(configLocations);</span><br><span class="line">	</span><br><span class="line">    if (refresh) &#123;</span><br><span class="line">      refresh(); // 核心方法</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>refresh方法既可以初始化ApplicationContext，也可以继续调用，重建ApplicationContext（将原来的 ApplicationContext 销毁，然后再重新执行一次初始化操作）</p>
<p>refresh方法源码如下</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">   // 上锁，防止在refresh方法结束前继续调用了多个refresh方法</span><br><span class="line">   synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line"></span><br><span class="line">      // 准备工作，记录容器的启动时间、标记“已启动”状态、处理配置文件中的占位符</span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      // 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，</span><br><span class="line">      // 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，</span><br><span class="line">      // 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)</span><br><span class="line">      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      // 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean</span><br><span class="line">      // 这块待会会展开说</span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">         // 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，</span><br><span class="line">         // 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】</span><br><span class="line"></span><br><span class="line">         // 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化</span><br><span class="line">         // 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line">         // 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法</span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         // 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别</span><br><span class="line">         // 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</span><br><span class="line">         // 两个方法分别在 Bean 初始化之前和初始化之后得到执行。注意，到这里 Bean 还没初始化</span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         // 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了</span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         // 初始化当前 ApplicationContext 的事件广播器，这里也不展开了</span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         // 从方法名就可以知道，典型的模板方法(钩子方法)，</span><br><span class="line">         // 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）</span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         // 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过</span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         // 重点，重点，重点</span><br><span class="line">         // 初始化所有的 singleton beans</span><br><span class="line">         //（lazy-init 的除外）</span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         // 最后，广播事件，ApplicationContext 初始化完成</span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      catch (BeansException ex) &#123;</span><br><span class="line">         if (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(&quot;Exception encountered during context initialization - &quot; +</span><br><span class="line">                  &quot;cancelling refresh attempt: &quot; + ex);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         // Destroy already created singletons to avoid dangling resources.</span><br><span class="line">         // 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源</span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         // Reset &#x27;active&#x27; flag.</span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">         // 把异常往外抛</span><br><span class="line">         throw ex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      finally &#123;</span><br><span class="line">         // Reset common introspection caches in Spring&#x27;s core, since we</span><br><span class="line">         // might not ever need metadata for singleton beans anymore...</span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="创建容器前的准备工作"><a href="#创建容器前的准备工作" class="headerlink" title="创建容器前的准备工作"></a>创建容器前的准备工作</h6><p>prepareRefresh()方法</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">protected void prepareRefresh() &#123;</span><br><span class="line">   // 记录启动时间，</span><br><span class="line">   // 将 active 属性设置为 true，closed 属性设置为 false，它们都是 AtomicBoolean 类型（原子布尔类型，提供了原子性操作的能力，保证了对布尔值的操作是原子的，实现线程安全）</span><br><span class="line">   this.startupDate = System.currentTimeMillis();</span><br><span class="line">   this.closed.set(false);</span><br><span class="line">   this.active.set(true);</span><br><span class="line">	</span><br><span class="line">   if (logger.isInfoEnabled()) &#123;</span><br><span class="line">      logger.info(&quot;Refreshing &quot; + this);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // Initialize any placeholder property sources in the context environment</span><br><span class="line">   initPropertySources();</span><br><span class="line"></span><br><span class="line">   // 校验 xml 配置文件</span><br><span class="line">   getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">   this.earlyApplicationEvents = new LinkedHashSet&lt;ApplicationEvent&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="创建-Bean-容器，加载并注册-Bean"><a href="#创建-Bean-容器，加载并注册-Bean" class="headerlink" title="创建 Bean 容器，加载并注册 Bean"></a>创建 Bean 容器，加载并注册 Bean</h6><p>obtainFreshBeanFactory()方法</p>
<p>这个方法是最重要的部分之一，这里将会初始化 BeanFactory、加载 Bean、注册 Bean 等等。</p>
<p>注意，Bean实例并未在这一步生成。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected ConfigurableListableBeanFactory obtainFreshBeanFactory() &#123;</span><br><span class="line">   // 关闭旧的 BeanFactory (如果有)，创建新的 BeanFactory，加载 Bean 定义、注册 Bean 等等</span><br><span class="line">   refreshBeanFactory();</span><br><span class="line"></span><br><span class="line">   // 返回刚刚创建的 BeanFactory</span><br><span class="line">   ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">   if (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(&quot;Bean factory for &quot; + getDisplayName() + &quot;: &quot; + beanFactory);</span><br><span class="line">   &#125;</span><br><span class="line">   return beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>obtainFreshBeanFactory方法调用了refreshBeanFactory方法（AbstractRefreshableApplicationContext.java 120行）</p>
<p>以下是refreshBeanFactory的源码</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected final void refreshBeanFactory() throws BeansException &#123;</span><br><span class="line">   // 如果 ApplicationContext 中已经加载过 BeanFactory 了，销毁所有 Bean，关闭 BeanFactory</span><br><span class="line">   // 注意，应用中 BeanFactory 本来就是可以多个的，这里可不是说应用全局是否有 BeanFactory，而是当前</span><br><span class="line">   // ApplicationContext 是否有 BeanFactory</span><br><span class="line">   if (hasBeanFactory()) &#123;</span><br><span class="line">      destroyBeans();</span><br><span class="line">      closeBeanFactory();</span><br><span class="line">   &#125;</span><br><span class="line">   try &#123;</span><br><span class="line">      // 初始化一个 DefaultListableBeanFactory，为什么用这个，我们马上说。</span><br><span class="line">      DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">      // 用于 BeanFactory 的序列化，我想不部分人应该都用不到</span><br><span class="line">      beanFactory.setSerializationId(getId());</span><br><span class="line"></span><br><span class="line">      // 下面这两个方法很重要，别跟丢了，具体细节之后说</span><br><span class="line">      // 设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用</span><br><span class="line">      customizeBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      // 加载 Bean 到 BeanFactory 中</span><br><span class="line">      loadBeanDefinitions(beanFactory);</span><br><span class="line">      synchronized (this.beanFactoryMonitor) &#123;</span><br><span class="line">         this.beanFactory = beanFactory;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   catch (IOException ex) &#123;</span><br><span class="line">      throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + getDisplayName(), ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ApplicationContext 继承自 BeanFactory，但是它不应该被理解为 BeanFactory 的实现类，而是说其内部持有一个实例化的 BeanFactory（DefaultListableBeanFactory）。以后所有的 BeanFactory 相关的操作其实是委托给这个实例来处理的。</p>
<p>为什么选择实例化 DefaultListableBeanFactory 呢？回过头看上面的那张图，可以发现ConfigurableListableBeanFactory 只有一个实现类 DefaultListableBeanFactory，而且实现类 DefaultListableBeanFactory 还通过实现右边的 AbstractAutowireCapableBeanFactory 通吃了右路。所以结论就是，最底下这个家伙 DefaultListableBeanFactory 基本上是最牛的 BeanFactory 了，这也是为什么这边会使用这个类来实例化的原因</p>
<p>想要在程序运行的时候动态往 Spring IOC 容器注册新的 bean，就会使用到DefaultListableBeanFactory</p>
<h6 id="bean的本质"><a href="#bean的本质" class="headerlink" title="bean的本质"></a>bean的本质</h6><p>BeanFactory 是 Bean 容器，那么 Bean 又是什么呢？Spring 的 Bean 在代码层面上而言其实是BeanDefinition的实例，定义的各个 Bean 会转换成一个个的 BeanDefinition实例 存在于 Spring 的 BeanFactory中</p>
<p>BeanDefinition 接口定义</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanDefinition extends AttributeAccessor, BeanMetadataElement &#123;</span><br><span class="line"></span><br><span class="line">   // 我们可以看到，默认只提供 sington 和 prototype 两种，</span><br><span class="line">   // 很多读者可能知道还有 request, session, globalSession, application, websocket 这几种，</span><br><span class="line">   // 不过，它们属于基于 web 的扩展。</span><br><span class="line">   String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;</span><br><span class="line">   String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;</span><br><span class="line"></span><br><span class="line">   // 比较不重要，直接跳过吧</span><br><span class="line">   int ROLE_APPLICATION = 0;</span><br><span class="line">   int ROLE_SUPPORT = 1;</span><br><span class="line">   int ROLE_INFRASTRUCTURE = 2;</span><br><span class="line"></span><br><span class="line">   // 设置父 Bean，这里涉及到 bean 继承，不是 java 继承。请参见附录的详细介绍</span><br><span class="line">   // 一句话就是：继承父 Bean 的配置信息而已</span><br><span class="line">   void setParentName(String parentName);</span><br><span class="line"></span><br><span class="line">   // 获取父 Bean</span><br><span class="line">   String getParentName();</span><br><span class="line"></span><br><span class="line">   // 设置 Bean 的类名称，将来是要通过反射来生成实例的</span><br><span class="line">   void setBeanClassName(String beanClassName);</span><br><span class="line"></span><br><span class="line">   // 获取 Bean 的类名称</span><br><span class="line">   String getBeanClassName();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   // 设置 bean 的 scope</span><br><span class="line">   void setScope(String scope);</span><br><span class="line"></span><br><span class="line">   String getScope();</span><br><span class="line"></span><br><span class="line">   // 设置是否懒加载</span><br><span class="line">   void setLazyInit(boolean lazyInit);</span><br><span class="line"></span><br><span class="line">   boolean isLazyInit();</span><br><span class="line"></span><br><span class="line">   // 设置该 Bean 依赖的所有的 Bean，注意，这里的依赖不是指属性依赖(如 @Autowire 标记的)，</span><br><span class="line">   // 是 depends-on=&quot;&quot; 属性设置的值。</span><br><span class="line">   void setDependsOn(String... dependsOn);</span><br><span class="line"></span><br><span class="line">   // 返回该 Bean 的所有依赖</span><br><span class="line">   String[] getDependsOn();</span><br><span class="line"></span><br><span class="line">   // 设置该 Bean 是否可以注入到其他 Bean 中，只对根据类型注入有效，</span><br><span class="line">   // 如果根据名称注入，即使这边设置了 false，也是可以的</span><br><span class="line">   void setAutowireCandidate(boolean autowireCandidate);</span><br><span class="line"></span><br><span class="line">   // 该 Bean 是否可以注入到其他 Bean 中</span><br><span class="line">   boolean isAutowireCandidate();</span><br><span class="line"></span><br><span class="line">   // 主要的。同一接口的多个实现，如果不指定名字的话，Spring 会优先选择设置 primary 为 true 的 bean</span><br><span class="line">   void setPrimary(boolean primary);</span><br><span class="line"></span><br><span class="line">   // 是否是 primary 的</span><br><span class="line">   boolean isPrimary();</span><br><span class="line"></span><br><span class="line">   // 如果该 Bean 采用工厂方法生成，指定工厂名称。对工厂不熟悉的读者，请参加附录</span><br><span class="line">   // 一句话就是：有些实例不是用反射生成的，而是用工厂模式生成的</span><br><span class="line">   void setFactoryBeanName(String factoryBeanName);</span><br><span class="line">   // 获取工厂名称</span><br><span class="line">   String getFactoryBeanName();</span><br><span class="line">   // 指定工厂类中的 工厂方法名称</span><br><span class="line">   void setFactoryMethodName(String factoryMethodName);</span><br><span class="line">   // 获取工厂类中的 工厂方法名称</span><br><span class="line">   String getFactoryMethodName();</span><br><span class="line"></span><br><span class="line">   // 构造器参数</span><br><span class="line">   ConstructorArgumentValues getConstructorArgumentValues();</span><br><span class="line"></span><br><span class="line">   // Bean 中的属性值，后面给 bean 注入属性值的时候会说到</span><br><span class="line">   MutablePropertyValues getPropertyValues();</span><br><span class="line"></span><br><span class="line">   // 是否 singleton</span><br><span class="line">   boolean isSingleton();</span><br><span class="line"></span><br><span class="line">   // 是否 prototype</span><br><span class="line">   boolean isPrototype();</span><br><span class="line"></span><br><span class="line">   // 如果这个 Bean 是被设置为 abstract，那么不能实例化，</span><br><span class="line">   // 常用于作为 父bean 用于继承，其实也很少用......</span><br><span class="line">   boolean isAbstract();</span><br><span class="line"></span><br><span class="line">   int getRole();</span><br><span class="line">   String getDescription();</span><br><span class="line">   String getResourceDescription();</span><br><span class="line">   BeanDefinition getOriginatingBeanDefinition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了 BeanDefinition 的概念以后，我们再往下看 refreshBeanFactory() 方法中的剩余部分：</p>
<p>customizeBeanFactory(beanFactory);</p>
<p>loadBeanDefinitions(beanFactory);</p>
<h6 id="customizeBeanFactory"><a href="#customizeBeanFactory" class="headerlink" title="customizeBeanFactory"></a>customizeBeanFactory</h6><p>customizeBeanFactory(beanFactory) 比较简单，就是配置是否允许 BeanDefinition 覆盖、是否允许循环引用</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) &#123;</span><br><span class="line">   if (this.allowBeanDefinitionOverriding != null) &#123;</span><br><span class="line">      // 是否允许 Bean 定义覆盖</span><br><span class="line">      beanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);</span><br><span class="line">   &#125;</span><br><span class="line">   if (this.allowCircularReferences != null) &#123;</span><br><span class="line">      // 是否允许 Bean 间的循环依赖</span><br><span class="line">      beanFactory.setAllowCircularReferences(this.allowCircularReferences);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="loadBeanDefinitions"><a href="#loadBeanDefinitions" class="headerlink" title="loadBeanDefinitions"></a>loadBeanDefinitions</h6><p>这个方法将根据配置，加载各个 Bean，然后放到 BeanFactory 中,读取配置的操作在 XmlBeanDefinitionReader 中，其负责加载配置、解析</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/** 我们可以看到，此方法将通过一个 XmlBeanDefinitionReader 实例来加载各个 Bean。*/</span><br><span class="line">@Override</span><br><span class="line">protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException &#123;</span><br><span class="line">   // 给这个 BeanFactory 实例化一个 XmlBeanDefinitionReader</span><br><span class="line">   XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">   // Configure the bean definition reader with this context&#x27;s</span><br><span class="line">   // resource loading environment.</span><br><span class="line">   beanDefinitionReader.setEnvironment(this.getEnvironment());</span><br><span class="line">   beanDefinitionReader.setResourceLoader(this);</span><br><span class="line">   beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));</span><br><span class="line"></span><br><span class="line">   // 初始化 BeanDefinitionReader，其实这个是提供给子类覆写的，</span><br><span class="line">   // 我看了一下，没有类覆写这个方法，我们暂且当做不重要吧</span><br><span class="line">   initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">   // 通过下面这个方法，一个配置文件将被转换为一颗 DOM 树</span><br><span class="line">   loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="注册-Bean"><a href="#注册-Bean" class="headerlink" title="注册 Bean"></a>注册 Bean</h6><p>BeanDefinitionReaderUtils 143行 别名注册</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void registerBeanDefinition(</span><br><span class="line">      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span><br><span class="line">      throws BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">   String beanName = definitionHolder.getBeanName();</span><br><span class="line">   // 注册这个 Bean</span><br><span class="line">   registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">   // 如果还有别名的话，也要根据别名全部注册一遍，不然根据别名就会找不到 Bean 了</span><br><span class="line">   // 这里是获取要注册的 bean 的别名数组</span><br><span class="line">   String[] aliases = definitionHolder.getAliases();</span><br><span class="line">   </span><br><span class="line">   // 如果别名数组不为空，则逐个将别名注册到 BeanDefinitionRegistry 中</span><br><span class="line">   if (aliases != null) &#123;</span><br><span class="line">      for (String alias : aliases) &#123;</span><br><span class="line">         // alias -&gt; beanName 保存它们的别名信息，这个很简单，用一个 map 保存一下就可以了，</span><br><span class="line">         // 获取的时候，会先将 alias 转换为 beanName，然后再查找</span><br><span class="line">         registry.registerAlias(beanName, alias);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DefaultListableBeanFactory 793行 注册Bean</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)</span><br><span class="line">      throws BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">   Assert.hasText(beanName, &quot;Bean name must not be empty&quot;);</span><br><span class="line">   Assert.notNull(beanDefinition, &quot;BeanDefinition must not be null&quot;);</span><br><span class="line"></span><br><span class="line">   if (beanDefinition instanceof AbstractBeanDefinition) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">         ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">      &#125;</span><br><span class="line">      catch (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">         throw new BeanDefinitionStoreException(...);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // old? 还记得 “允许 bean 覆盖” 这个配置吗？allowBeanDefinitionOverriding</span><br><span class="line">   BeanDefinition oldBeanDefinition;</span><br><span class="line"></span><br><span class="line">   // 之后会看到，所有的 Bean 注册后会放入这个 beanDefinitionMap 中</span><br><span class="line">   oldBeanDefinition = this.beanDefinitionMap.get(beanName);</span><br><span class="line"></span><br><span class="line">   // 处理重复名称的 Bean 定义的情况</span><br><span class="line">   if (oldBeanDefinition != null) &#123;</span><br><span class="line">      if (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">         // 如果不允许覆盖的话，抛异常</span><br><span class="line">         throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription()...</span><br><span class="line">      &#125;</span><br><span class="line">      else if (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">         // log...用框架定义的 Bean 覆盖用户自定义的 Bean </span><br><span class="line">      &#125;</span><br><span class="line">      else if (!beanDefinition.equals(oldBeanDefinition)) &#123;</span><br><span class="line">         // log...用新的 Bean 覆盖旧的 Bean</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">         // log...用同等的 Bean 覆盖旧的 Bean，这里指的是 equals 方法返回 true 的 Bean</span><br><span class="line">      &#125;</span><br><span class="line">      // 覆盖</span><br><span class="line">      this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line">      // 判断是否已经有其他的 Bean 开始初始化了.</span><br><span class="line">      // 注意，&quot;注册Bean&quot; 这个动作结束，Bean 依然还没有初始化，我们后面会有大篇幅说初始化过程，</span><br><span class="line">      // 在 Spring 容器启动的最后，会 预初始化 所有的 singleton beans</span><br><span class="line">      if (hasBeanCreationStarted()) &#123;</span><br><span class="line">         // Cannot modify startup-time collection elements anymore (for stable iteration)</span><br><span class="line">         synchronized (this.beanDefinitionMap) &#123;</span><br><span class="line">            this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">            List&lt;String&gt; updatedDefinitions = new ArrayList&lt;String&gt;(this.beanDefinitionNames.size() + 1);</span><br><span class="line">            updatedDefinitions.addAll(this.beanDefinitionNames);</span><br><span class="line">            updatedDefinitions.add(beanName);</span><br><span class="line">            this.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">            if (this.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">               Set&lt;String&gt; updatedSingletons = new LinkedHashSet&lt;String&gt;(this.manualSingletonNames);</span><br><span class="line">               updatedSingletons.remove(beanName);</span><br><span class="line">               this.manualSingletonNames = updatedSingletons;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">         // 最正常的应该是进到这个分支。</span><br><span class="line"></span><br><span class="line">         // 将 BeanDefinition 放到这个 map 中，这个 map 保存了所有的 BeanDefinition</span><br><span class="line">         this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">         // 这是个 ArrayList，所以会按照 bean 配置的顺序保存每一个注册的 Bean 的名字</span><br><span class="line">         this.beanDefinitionNames.add(beanName);</span><br><span class="line">         // 这是个 LinkedHashSet，代表的是手动注册的 singleton bean，</span><br><span class="line">         // 注意这里是 remove 方法，到这里的 Bean 当然不是手动注册的</span><br><span class="line">         // 手动指的是通过调用以下方法注册的 bean ：</span><br><span class="line">         //     registerSingleton(String beanName, Object singletonObject)</span><br><span class="line">         // 这不是重点，解释只是为了不让大家疑惑。Spring 会在后面&quot;手动&quot;注册一些 Bean，</span><br><span class="line">         // 如 &quot;environment&quot;、&quot;systemProperties&quot; 等 bean，我们自己也可以在运行时注册 Bean 到容器中的</span><br><span class="line">         this.manualSingletonNames.remove(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      // 这个不重要，在预初始化的时候会用到，不必管它。</span><br><span class="line">      this.frozenBeanDefinitionNames = null;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (oldBeanDefinition != null || containsSingleton(beanName)) &#123;</span><br><span class="line">      resetBeanDefinition(beanName);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从启动Spring容器到执行完注册bean，总结一下：到这里已经初始化了 Bean 容器，<bean /> 配置也相应的转换为了一个个 BeanDefinition，然后注册了各个 BeanDefinition 到注册中心，并且发送了注册事件。</p>
<h6 id="准备-Bean-容器-prepareBeanFactory"><a href="#准备-Bean-容器-prepareBeanFactory" class="headerlink" title="准备 Bean 容器: prepareBeanFactory"></a>准备 Bean 容器: prepareBeanFactory</h6><p>Spring 把我们在 xml 配置的 bean 都注册以后，会”手动”注册一些特殊的 bean</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Configure the factory&#x27;s standard context characteristics,</span><br><span class="line"> * such as the context&#x27;s ClassLoader and post-processors.</span><br><span class="line"> * @param beanFactory the BeanFactory to configure</span><br><span class="line"> */</span><br><span class="line">protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">   // 设置 BeanFactory 的类加载器，我们知道 BeanFactory 需要加载类，也就需要类加载器，</span><br><span class="line">   // 这里设置为加载当前 ApplicationContext 类的类加载器</span><br><span class="line">   beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line"></span><br><span class="line">   // 设置 BeanExpressionResolver</span><br><span class="line">   beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">   // </span><br><span class="line">   beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));</span><br><span class="line"></span><br><span class="line">   // 添加一个 BeanPostProcessor，这个 processor 比较简单：</span><br><span class="line">   // 实现了 Aware 接口的 beans 在初始化的时候，这个 processor 负责回调，</span><br><span class="line">   // 这个我们很常用，如我们会为了获取 ApplicationContext 而 implement ApplicationContextAware</span><br><span class="line">   // 注意：它不仅仅回调 ApplicationContextAware，</span><br><span class="line">   //   还会负责回调 EnvironmentAware、ResourceLoaderAware 等，看下源码就清楚了</span><br><span class="line">   beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));</span><br><span class="line"></span><br><span class="line">   // 下面几行的意思就是，如果某个 bean 依赖于以下几个接口的实现类，在自动装配的时候忽略它们，</span><br><span class="line">   // Spring 会通过其他方式来处理这些依赖。</span><br><span class="line">   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 下面几行就是为特殊的几个 bean 赋值，如果有 bean 依赖了以下几个，会注入这边相应的值，</span><br><span class="line">    * 之前我们说过，&quot;当前 ApplicationContext 持有一个 BeanFactory&quot;，这里解释了第一行。</span><br><span class="line">    * ApplicationContext 还继承了 ResourceLoader、ApplicationEventPublisher、MessageSource</span><br><span class="line">    * 所以对于这几个依赖，可以赋值为 this，注意 this 是一个 ApplicationContext</span><br><span class="line">    * 那这里怎么没看到为 MessageSource 赋值呢？那是因为 MessageSource 被注册成为了一个普通的 bean</span><br><span class="line">    */</span><br><span class="line">   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">   beanFactory.registerResolvableDependency(ResourceLoader.class, this);</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationContext.class, this);</span><br><span class="line"></span><br><span class="line">   // 这个 BeanPostProcessor 也很简单，在 bean 实例化后，如果是 ApplicationListener 的子类，</span><br><span class="line">   // 那么将其添加到 listener 列表中，可以理解成：注册 事件监听器</span><br><span class="line">   beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));</span><br><span class="line"></span><br><span class="line">   // 这里涉及到特殊的 bean，名为：loadTimeWeaver，这不是我们的重点，忽略它</span><br><span class="line">   // tips: ltw 是 AspectJ 的概念，指的是在运行期进行织入，这个和 Spring AOP 不一样，</span><br><span class="line">   //    感兴趣的读者请参考我写的关于 AspectJ 的另一篇文章 https://www.javadoop.com/post/aspectj</span><br><span class="line">   if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">      // Set a temporary ClassLoader for type matching.</span><br><span class="line">      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 从下面几行代码我们可以知道，Spring 往往很 &quot;智能&quot; 就是因为它会帮我们默认注册一些有用的 bean，</span><br><span class="line">    * 我们也可以选择覆盖</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">   // 如果没有定义 &quot;environment&quot; 这个 bean，那么 Spring 会 &quot;手动&quot; 注册一个</span><br><span class="line">   if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line">   // 如果没有定义 &quot;systemProperties&quot; 这个 bean，那么 Spring 会 &quot;手动&quot; 注册一个</span><br><span class="line">   if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">   &#125;</span><br><span class="line">   // 如果没有定义 &quot;systemEnvironment&quot; 这个 bean，那么 Spring 会 &quot;手动&quot; 注册一个</span><br><span class="line">   if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring 对一些特殊的 bean 进行了处理,初始化所有的 singleton beans</p>
<p>剩下的就是初始化 singleton beans 了，我们知道它们是单例的，如果没有设置懒加载，那么 Spring 会在接下来初始化所有的 singleton beans。</p>
<p>AbstractApplicationContext.java 834行</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 初始化剩余的 singleton beans</span><br><span class="line">protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line"></span><br><span class="line">   // 首先，初始化名字为 conversionService 的 Bean。本着送佛送到西的精神，我在附录中简单介绍了一下 ConversionService，因为这实在太实用了</span><br><span class="line">   // 什么，看代码这里没有初始化 Bean 啊！</span><br><span class="line">   // 注意了，初始化的动作包装在 beanFactory.getBean(...) 中，这里先不说细节，先往下看吧</span><br><span class="line">   if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">      beanFactory.setConversionService(</span><br><span class="line">            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // Register a default embedded value resolver if no bean post-processor</span><br><span class="line">   // (such as a PropertyPlaceholderConfigurer bean) registered any before:</span><br><span class="line">   // at this point, primarily for resolution in annotation attribute values.</span><br><span class="line">   if (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">      beanFactory.addEmbeddedValueResolver(new StringValueResolver() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public String resolveStringValue(String strVal) &#123;</span><br><span class="line">            return getEnvironment().resolvePlaceholders(strVal);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 先初始化 LoadTimeWeaverAware 类型的 Bean</span><br><span class="line">   // 之前也说过，这是 AspectJ 相关的内容，放心跳过吧</span><br><span class="line">   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);</span><br><span class="line">   for (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">      getBean(weaverAwareName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // Stop using the temporary ClassLoader for type matching.</span><br><span class="line">   beanFactory.setTempClassLoader(null);</span><br><span class="line"></span><br><span class="line">   // 没什么别的目的，因为到这一步的时候，Spring 已经开始预初始化 singleton beans 了，</span><br><span class="line">   // 肯定不希望这个时候还出现 bean 定义解析、加载、注册。</span><br><span class="line">   beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">   // 开始初始化</span><br><span class="line">   beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-力扣1880-2050" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2023-07-23T16:15:26.000Z"><a href="/2023/07/24/%E5%8A%9B%E6%89%A31880-2050/">2023-07-24</a></time>
      
      
  
    <h1 class="title"><a href="/2023/07/24/%E5%8A%9B%E6%89%A31880-2050/">力扣1880-2050</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <pre><code class="text">2023.07.24

2101. 引爆最多的炸弹
BFS
数据量较小，注意引爆条件


754. 到达终点数字
数学+分类讨论
1.target正负不影响答案（所有步骤反着来为-target的答案），取abs(target)来讨论
2.一直往右走，若最后恰好到达target，得到答案
3.最后一步超过终点，且与终点距离为偶数，则将前面的其中一步改为往左得到答案
4.如果与终点距离为奇数，继续向前走，直到相距为偶数，再改一步往左得到答案


1106. 解析布尔表达式
栈
1.遇到逗号，跳过
2.遇到右括号，进行计算（直到左括号的上一个运算符）
3.遇到其他字符，入栈


1536. 排布二进制网格的最少交换次数
贪心
1.需要后缀有n-1个0的行，n-2个0的行...0个0的行
2.从上到下确定，找到最近的满足情况的行，模拟交换
3.由于从上到下确定行，越下面的行限制条件越宽松，贪心正确
4.最后一行无需判断


1255. 得分最高的单词集合
DFS
words长度较小，可以对每个单词枚举 选/不选 最终判断该选择是否合法 最多枚举 pow(2,n) 种情况，n为words长度


2054. 两个最好的不重叠活动
排序
1.把活动的开始时间点和结束时间点提取出来进行排序,时间相同时先处理开始事件,否则可能让第一个活动的结束时间等于第二个活动的开始时间
2.遍历时间点，遇到结束时间点维护已结束活动的最大价值，遇到开始时间点维护答案=已结束活动的最大价值+当前开始时间点的价值


2023.07.25

1326. 灌溉花园的最少水龙头数目
模拟
类似于跳跃游戏，位于i的水龙头，范围为r，预处理:i-r最大能到达i+r
即 maxPos[i-r] = max(maxPos[i-r],i+r) 当i-r&lt;=0时，则更新maxPos[0]
接下来模拟跳跃，cur表示当前最大能跳跃的位置，当i==cur时：将cur更新为max，max为之前所有的位置中最大能到达的位置，同时ans+=1


2064. 分配给商店的最多商品的最小值
二分
最大值最小化，使用二分查找。需要把所有商品分配出去，商店可以接收0件商品，但分配后不能有多余商品
每个商店最多分到max件，计算最多能分给count个商店。当商店数n&gt;=count时，不会让商品多余，为合法的分配，缩小右边界，答案为最后一次合法的右边界


2305. 公平分发饼干
DFS+回溯
数据量较小，枚举哪个孩子得到当前饼干


2537. 统计好子数组的数目
滑动窗口
使用哈希表统计相同元素的出现次数，从而获取满足条件的下标对的个数cnt
注意当相同元素有n个时，减少1个该元素，会减少多少个满足条件的下标对？会减少(n-1)个


1722. 执行交换操作后的最小汉明距离
并查集
allowedSwaps[i] = [ai, bi]说明ai和bi这两个下标的元素可以互通
对于互通的下标集，大小为m，尽可能让更多的下标与target对应下标的元素相同，假设有k个下标符合条件，得到最小汉明距离为m-k，累加所有互通下标集的最小汉明距离即为答案


2327. 知道秘密的人数
动态规划
dp[i]表示第i天结束时，新增的知道秘密的人数，dp[i]=dp[begin,end]的累加，其中begin为i-forget+1，end为i-delay
第n天时知道秘密的人数为最后forget天的新增人数之和


1871. 跳跃游戏 VII
动态规划+前缀和
1.定义dp[i]表示i位置是否能够到达，在区间[i-maxJump,i-minJump]中若存在j，满足dp[j]为true，则dp[i]为true
2.通过枚举区间来得到dp[i]的算法时间复杂度为o(n^2)，会超出时间限制，因此使用前缀和来优化。
3.当dp[i]为true时对前缀和的贡献为0，反之贡献为1
3.当pre[right+1]-pre[left]!=(right-left+1)时说明出现了0，即出现了true


878. 第 N 个神奇数字
数学+二分
1.设f(x)表示&lt;=x的神奇数字的个数。在&lt;=x的数中，有x/a个数能被a整除，有x/b个数能被b整数，有x/lcm(a,b)个数能被lcm(a,b)整除，lcm为最小公倍数函数
2.可以写出f(x)的表达式f(x)=x/a+x/b-x/lcm(a,b),在题目条件下f(x)是单调递增函数
3.设f(x)==k,那么x就是第k个神奇数字,要得到第n个神奇数字，可以使用二分查找，当f(x)&lt;n时缩小左边界，最后得到的右边界right有f(right)==n，right即为答案


2360. 图中的最长环
模拟
使用一个时钟记录全局时间，尝试从每一个点出发寻找环。若该点不是首次访问，则跳过。若该点是首次访问，记录当前时间startTime，再开始寻找环。
如果找到某个节点其访问时间visitTme满足visitTime&gt;=startTime，说明找到了一个环，动态更新最长环的长度即可得到答案


780. 到达终点
模拟
反向计算：位于(x,y)的点可以转换为(x,y-x)或(x-y,y)
由于x，y&gt;=1，那么能够继续转换的条件是：当前的x大于目标x，当前的y大于目标y，当前的x不等于当前的y
当前x&gt;当前y且能够继续转换时，x不断减去y；反之y不断减去x，直到无法继续转换
如果当前x，y与目标x，y完全相同返回true，否则判断x和y是否其中一个与目标相同，若没有其中一个相同，返回false。若其中一个相同，进一步判断能否通过不断减的操作让其也与目标相同。


1878. 矩阵中最大的三个菱形和
暴力枚举
枚举所有可能的菱形和，使用TreeSet及其pollLast方法可以维护最大的三个菱形和


823. 带因子的二叉树
排序+枚举
先对arr进行排序，因为较大的元素只能由两个较小元素相乘得到，优先计算以较小元素为根的构造方案数
遍历arr数组，枚举每一个元素作为二叉树的根节点时，有多少种构造方案
设根节点为root，如果arr中存在元素x以及root/x，则：
以root为根的构造方案数 += 以x为根的方案数 * 以root/x为根的方案数
以root为根的初始构造方案数为1，即没有左子树也没有右子树


2023.07.26

1665. 完成所有任务的最少初始能量
排序
由于门槛&gt;=耗能，对每个任务提炼一个虚报值=门槛-耗能
对任务按照虚报值从小到大排序，虚报值越大的任务越需要前面的耗能来支撑虚报，若前面的能量还不够则补到足够为止。
遍历每个任务，累加实际耗能，若实际耗能仍不够虚报，则补到虚报后的值。


2602. 使数组元素全部相等的最少操作次数
排序+二分查找+前缀和
首先对数组进行排序，记数组长度为n。对于每个查询queries[i]，二分查找最后一个&lt;=queries[i]的下标，记为left
将数组分成[0,left]以及[left+1,n-1]两部分，要把数组中所有元素变成queries[i]：
对于[0,left]而言，相当于把所有元素增加至queries[i]；
对于[left+1,n-1]而言，相当于把所有元素减少至queries[i]；
使用前缀和维护区间的值，通过整体计算可以快速获得答案。


2608. 图中的最短环
BFS
首先建立无向图。由于顶点总数较小，从每个节点出发寻找环，同时记录到不同节点的距离，当重复遇到节点时说明找到了环，动态维护最短环的长度作为答案
进行BFS时，数据格式为&#123;节点id,当前节点的父节点&#125;,不能走回头路(即不能重新回到父节点)


1124. 表现良好的最长时间段
枚举+前缀和
hours的长度不超过1e4，可以使用双重循环枚举表现良好的时间段
工作时间大于8小时，记为1，反之记为0，通过前缀和可快速判断某个区间是否为表现良好时间段
动态维护表现良好时间段的最大长度作为答案


991. 坏了的计算器
数学+模拟
反向计算：当Y大于X时，对Y进行操作向X趋近，Y为奇数时进行加一操作，为偶数时进行除2操作
最后对Y进行（X-Y）次加一操作得到X


2585. 获得分数的方法数
动态规划
分组背包模板题。定义dp[i][j]表示前i道题目获得target分的方案数
使用三重循环，枚举前i道题目，枚举第i道题目做的数量j，枚举分数k进行状态转移，最后dp[n][target]就是答案


873. 最长的斐波那契子序列的长度
动态规划
定义dp[j][k]表示最后两项为下标j和下标k的元素时最长的斐波那契子序列长度
对于每个k，枚举可能的下标i和j满足arr[i]+arr[j]==arr[k]
找到满足这样条件的下标i,j,k时，如果以下标i,j为最后两项的斐波那契子序列长度为0，那么下标i,j,k组成了新的斐波那契初始序列，令dp[j][k]=3，否则dp[j][k]=max(dp[j][k],dp[i][j]+1)，同时更新ans
如果arr[i]+arr[j]&lt;arr[k]，增加i，反之减少j，直到i&gt;=j时枚举下一个k


2049. 统计最高分的节点数目
DFS
0节点是根，从0出发进行dfs
对于每一个节点，计算出左子树的节点数量leftCnt以及右子树的节点数量rightCnt，那么该节点的分数为：
leftCnt * rightCnt * (sum-leftCnt-rightCnt-1)，这三部分中出现0的部分取1
动态维护最高分及其个数，最高分的个数作为答案


2296. 设计一个文本编辑器
双向链表
光标不会主动移动到某个下标位置，只会相对移动（向左或向右），可以用双向链表模拟，每个节点存储一个字符


2680. 最大或值
枚举+前缀后缀优化
选择一个数并将它乘2等价于将其二进制表示左移1位
进行k次操作一定是移动同一个数字，才能得到最大的结果
枚举对每一个数字左移k次，取最大值作为答案
对于下标i，使用前缀或、后缀或数组可以快速计算出[0,i-1]中元素的按位或以及[i,n-1]中元素的按位或


1147. 段式回文
贪心+递归
当前缀与后缀相同时，立即分离出来，再对剩余字符串继续递归，直到无法分离
为什么要立即分离？因为对于更长的相同前后缀，一定可以分解为更多的子串，题目需要求出k的最大值，因此需要贪心地分离相同的前后缀。


1898. 可移除字符的最大数目
二分
移除的字符越少，越可能满足p是s的子序列，而假设移除n个下标后仍满足p是s的子序列，那么移除更少的下标例如n-1个，一定也满足该条件。
二分查找最大的k，找到满足条件的临界值作为答案


1671. 得到山形数组的最少删除次数
枚举+动态规划
题目定义山形数组的长度至少为3。记nums长度为n，枚举[1,n-2]作为山顶，当山顶为i时，问题转化为：
求[0,i]中最长上升子序列的长度len1以及[i,n-1]中最长下降子序列的长度len2
此时删除次数为n-(len1+len2-1)，动态维护最少删除次数作为答案
定义upper[i]表示到下标i为止的最长上升子序列的长度
定义lower[i]表示以下标i开始的最长下降子序列的长度
注意点：
不能把山顶的左边或右边全部删掉了，左右两边至少留有一个元素，即最长上升/下降子序列都&gt;1时，才更新答案


2023.07.27

1373. 二叉搜索子树的最大键值和
递归
每棵子树返回：这棵子树的最小节点值、这棵子树的最大节点值、这棵子树的所有节点值之和
对于空节点，返回&#123;max,min,0&#125;，对于不是二叉搜索树的节点，返回&#123;min,max,0&#125;
这是由二叉搜索树的判断决定的，当一个节点root的孩子child不是二叉搜索树，该节点也不会是二叉搜索树，非二叉搜索树的判断条件为：
root的值&lt;=child的最大值(当child为左孩子) 或者 root的值&gt;=child的最小值(当child为右孩子)
需要让以上式子成立，因此child不是二叉搜索树时返回&#123;min,max,0&#125;，使其父节点也被判定为非二叉搜索树
同理，空节点返回&#123;max,min,0&#125;是为了让父节点无条件被判定为二叉搜索树


2147. 分隔长廊的方案数
模拟
如果座位的总数为0或者为奇数，那么不存在划分方案，返回0
模拟划分，每遇到两个座位后，统计中间间隔的植物数量count，该段的划分方案为(count+1)，
对ans而言应乘上(count+1)，再对mod取余


2594. 修车的最少时间
二分
给定m分钟，计算所有机械工可以修好的汽车总数cnt，当cnt&gt;=cars时缩小右边界right，最后right作为答
案
能力值为 r 的机械工可以在 r * n * n 分钟内修好 n 辆车，那么给定m分钟，可以修好sqrt(m/r)辆车


1043. 分隔数组以得到最大和
动态规划
定义dp[i]表示前i个元素可以得到的最大和
dp[i]由dp[j]+max*(i-j)转移而来


2673. 使二叉树所有路径值相等的最小代价
递归
对于两个有着相同父节点的叶子节点来说，他们到达根节点的路径上只有本身的cost不同，要满足到达根节点的路径值相同，只能将两个节点的cost改为相同，由于只能进行增加操作，应增加较小的cost
通过递归，获取每个node经过操作后到每个叶子节点的路径值，叶子节点的路径值为本身的cost值
具体来说，先获取node的左、右孩子到其每个节点的路径值left、right，为答案增加abs(left-right)次，让左右孩子的路径值相同，返回给上一级的数据为max(left,right)+本身的cost值


2398. 预算内的最多机器人数目
二分+滑动窗口
题目要求的是可以连续运行的机器人数目，枚举连续的个数m，二分查找满足条件的边界值作为答案
对于连续个数m，具体实现是使用固定长度的滑动窗口+TreeMap维护窗口内最大值，找到满足cost&lt;=budget的窗口则返回true，遍历完所有可行的窗口仍未找到返回false


2069. 模拟行走机器人 II
模拟
根据题目描述，机器人只会在网格图的最外圈移动。
定义方向，记录机器人的坐标以及朝向，模拟进行移动


2023.07.28

2050. 并行课程 III
记忆化搜索
定义dfs函数返回第i门课程所需要的最少月份数：
若第i门课程没有先修课，完成该课程的最少月份数为time[i-1];
若第i门课程有先修课，完成该课程的最少月份数为max(先修课需要的最少月份数)+time[i-1];
使用记忆化搜索减少重复搜索
所有课程中最大的最少需要月份数作为答案


1130. 叶值的最小代价生成树
单调栈
问题可以转化为：给定一个数组arr，不断地合并相邻的数，合并代价为两个数的乘积，合并之后的数为两个数的最大值，直到数组只剩一个数，求最小合并代价和
在合并时，优先合并较小的两个数能得到最小代价


1552. 两球之间的磁力
排序+二分
对pos进行排序后，二分枚举答案
具体实现：枚举最小磁力为k时，是否为合法放置。
统计成功放置的个数cnt，使用pre记录上一个放置的位置，从下标1开始枚举位置，当前位置pos[i]-pre&gt;=k时，可以在pos[i]放置，cnt+=1。最后如果cnt&gt;=m为合法放置


2731. 移动机器人
排序+前缀和
当两个机器人相撞时，它们开始沿着原本相反的方向移动，等价于没有相撞
分别计算出每个机器人最后的位置,排序后再计算两两距离之和
为什么需要排序？对于i下标，保证pos[i,n-1]都大于pos[i]，那么计算距离和时相当于pos[i,n-1]之和减去(n-1-i+1)个pos[i]，如果不排序，那么计算出的距离可能为负数。
由于(i,j) 和 (j,i) 视为相同的坐标对，因此遍历到i时，只需计算i与后面下标的距离，不用计算与前面下标的距离。使用前缀和快速计算距离


1416. 恢复数组
动态规划
定义f[i]表示s的前i个字符能恢复的方案数
k&lt;=1e9 对于第i个字符，只需枚举下标[i-10,i-1]是否能够形成有效的数字
注意前导0的判断


1745. 分割回文串 IV
动态规划+枚举
使用动态规划预处理所有区间，找出回文区间。再使用双重循环枚举分割点
具体实现：枚举区间长度len，枚举区间左端点i，计算出区间右端点j=i+len-1，若s[i]==s[j]：当len==2时，dp[i][j]为true，否则dp[i][j]=dp[i+1][j-1]
题目需要分割成非空子字符串，注意割点的范围


85. 最大矩形
预处理+枚举
对于位于(i,j)的1，预处理len[i][j]，表示其左边连续1的个数(包括本身)
遍历矩阵，找到1说明找到了矩形的底边，向上枚举矩形的高度，同时底边的长度取min(len[k][j])，其中k为向上枚举的行下标，从而得到面积，维护最大面积作为答案
具体实现：当mat[i][j]==1时，记录底边长度a=len[i][j]，矩形高度b=1，矩形面积s=a*b，在想上枚举高度的过程中b不断+1，a取最小的len[k][j]，s取最大的a*b，最后用s来更新答案


1727. 重新排列后的最大子矩阵
预处理+排序+枚举
对于(i,j)的1，预处理len[i][j]表示其上面连续1的个数（包括自身）
对每一行的len[i][j]进行排序，对于i行，找到一个len[i][j]!=0后向左扩展矩阵的宽度，维护最大高度，同时维护最大矩阵面积作为答案，同时跳出i行的循环，因为经过排序，后面的len[i][j]只会更小


2023.07.29

1562. 查找大小为 M 的最新分组
模拟
使用正难则反的思想。反向遍历进行操作，当出现恰好长度为m的一组连续1时，直接返回答案
通过TreeSet可快速记录最近的前面的1的位置以及最近的后面的1的位置
注意步骤与下标之间的映射,以及可以直接返回结果的特判


2654. 使数组所有元素变成 1 的最少操作次数
模拟
出现一个1就可以一直传播，直到整个数组所有元素等于1
遍历数组，统计1出现的次数cnt，如果cnt不等于0，答案为n-cnt，n为数组长度
否则，需要找到一个最短子数组，满足其元素的最大公约数为1，从而构造出1，答案为(len-1)+(n-1),其中len为子数组的长度


1802. 有界数组中指定下标处的最大值
贪心+二分
要让nums[index]最大，那么其他元素应尽可能小，即nums[index]的左边的元素大小不断递减，右边的元素大小也是不断递减，[0,index]形成递增数列，[index,n-1]形成递减数列
二分枚举nums[index]的值，计算所有元素之和是否小于等于maxSum，若满足为合法赋值，缩小左边界。最后的左边界作为答案
注意点
2.题目要求数组全部为正整数，等差数列小于1
1.用到了高中的等差数列求和公式的部分记为1


2018. 判断单词是否能放入填字游戏内
模拟
1 &lt;= m * n &lt;= 2 * 1e5 数据量较小，模拟是否能够将单词填入矩阵中


1705. 吃苹果的最大数目
优先队列
把苹果的过期时间放入优先队列中，模拟每一天吃苹果，直到队列中所有苹果都已过期
在一边新增苹果时就一边吃苹果，遍历完新增苹果数组后，继续模拟吃苹果


1798. 你能构造出连续值的最大数目
排序+贪心
对硬币进行排序，初始时ans=0，表示数字0必定能得到。
遍历硬币，当前正在构造的数为ans+1，若coins[i]&gt;ans+1，而后面的硬币值只会更大，说明ans+1无法被构造，只能构造[0,ans]的数，返回ans+1作为答案。
否则可以将可以构造[0,ans+coins[i]]中的所有整数。那么如何证明？
仔细想想，之前可以构造[0,ans]区间的数，现在来了一个coins[i]，我把coins[i]与前面可以构造出来的1组合，是不是得到了coins[i]+1?与之前的2再组合，得到coins[i]+2,再与3,与4...一直组合，最后可以构造出ans+coins[i]。


2023.07.31

996. 正方形数组的数目
建图+dfs+回溯+排序
对于下标a，如果与下标b各自对应的元素之和为完全平方数，则为下标a与b之间添加一条无向边
dfs同时记录路径情况，将所有节点遍历得到顺序后，放入哈希表去重
使用排序进行剪枝，当相邻元素相同，且visit[i-1]为false时，说明i-1已经作为同层元素（想象一下搜索树长什么样子）使用过一次（经过回溯其visit又变成了false），直接跳过
最后哈希表的长度作为答案


1964. 找出到每个位置为止最长的有效障碍赛跑路线
二分
维护一个列表，列表中元素为非递减，遍历数组
当前元素大于等于列表中所有元素时，放入列表末尾，ans[i]为当前列表长度
否则，在列表中二分查找第一个大于当前元素的位置，并将其改为当前元素，ans[i]为该位置+1
这样做的原因是在保持非递减序列最长的同时，序列中每一项尽可能小。
答案是不会错的，但是我们实际匹配的序列与列表中的序列并不一定相同，
例如输入数组&#123;1,2,3,5,2,6&#125;
当遍历到下标4，列表中的元素&#123;1,2,3,5&#125;会被修改为&#123;1,2,2,5&#125;
接着遍历下标5，我们知道设置的障碍应该是&#123;1,2,3,5,6&#125;,而此时将6放入列表末尾，列表为&#123;1,2,2,5,6&#125;
但是毫无疑问的是，对于下标5的答案是5，我们通过维护的非递减列表长度依然得到了正确的答案


827. 最大人工岛
dfs+枚举
先对所有的岛进行dfs并记录岛的编号及其大小（为了与初始矩阵中的0、1区分开，岛的编号从1001开始），并初始化答案为最大的岛屿面积
再遍历矩阵，枚举每个0，计算将其变成1后可以合并的岛屿的最大面积，注意：翻转后，当前0的位置会变成1，也算岛屿面积


1818. 绝对差值和
排序+二分
先将nums1中所有元素复制一份样本并排序，并计算每一对下标i对应的两个数组的绝对差值
遍历nums2中的元素，从nums1的排序副本中二分查找最接近的元素，维护替换后能产生最大变化的差值及其下标
最后统计绝对差值和，对于替换后能产生最大变化的下标进行替换，其余下标按原来的diff计算
为什么要选择替换后能产生最大变化的下标？
由于使用二分查找，那么进行替换后的差值一定小于等于原差值，替换后的差值相比与原差值的变化越大，说明替换后能使差值和越小


813. 最大平均值和的分组
前缀和+动态规划
结论：对于给定的k，分成k个非空子数组能得到最大分数。如何证明？
可以这样想，求平均值时相当于每个元素都要除去一个分母再相加，这个分母是划分出的子数组的长度，要让平均值更大，就要让每个元素除去的分母更小，所以划分更多的子数组，可以得到更大的分数
定义dp[i][j]表示前i个元素划分为j个子数组的最大平均值和，使用前缀和快速获取区间总和
最后答案为dp[n][k]


2023.08.01

777. 在LR字符串中交换相邻字符
思维题
可以转换需要满足的条件：
1.字符L和R的相对顺序相同
2.每个L在end中的下标小于等于对应的L在start中的下标
3.每个R在end中的下标大于等于对应的R在start中的下标
三个条件都满足时返回true，否则返回false


1760. 袋子里最少数目的球
二分
根据操作的定义，袋子中的球可以被拆分而不能合并，且求的是最小的单个袋子最大球数，使用二分查找
具体实现：每个袋子的最大球数为max时，求出此时所需要的操作次数needOp,若needOp&lt;=maxOp,说明当前操作可行，缩小右边界。最后一次右边界作为答案


2762. 不间断子数组
滑动窗口+TreeMap
使用TreeMap快速获取窗口内的最大值与最小值，每一次循环都先增加右边界，再计算窗口内的差值，当差值不满足条件时进行缩窗，缩窗后如果当前窗口满足条件，对答案加上当前窗口的长度


2111. 使数组 K 递增的最少操作次数
分组+二分
将arr分成k组，分别求每一组变成非递减的最少次数，最后累加得到答案
对于某一组元素，设长度为n，则将其变成非递减序列的最少次数=n-最长非严格递增子序列长度
由于数组长度达到1e5，不能使用时间复杂度为o(n^2)的动态规划算法，可以使用维护有序序列+二分查找来获取最长非严格递增子序列的长度


2227. 加密解密字符串
模拟
对于一个字符串，其解密结果可能不唯一，其加密结果唯一。可以逆向思考：
对dictionary中的每个字符串进行加密，记录加密得到的 字符串及其出现的次数
那么对于word2，想知道其解密结果，获取其在加密记录表中的出现次数即可


2023.08.02

1482. 制作 m 束花所需的最少天数
二分
二分枚举等待的天数，判断是否能满足条件
具体实现：遍历数组，当开花时间&lt;=等待时间，说明该朵花可以采摘，count++。每当count&gt;=k时，count-=k，并为find+1说明完成了一束花的制作。如果遇到一朵花其开花时间&gt;等待时间，立即重置count的数量为0。最后返回find是否&gt;=m


1793. 好子数组的最大分数
预处理+单调栈+枚举
分数由子数组中的最小值以及子数组的长度决定，为了得到最大分数，可以枚举最小值。
当最小值固定后，尽可能让子数组长度更大
使用单调栈预处理每个下标i，其左右两边比自己更小的数字出现的下标，那么当下标i作为最小值时，就可以快速得到子数组的最大长度，再计算出分数，维护最大分数作为答案
分数计算的具体细节：设上一个更大值的下标为left，下一个更大值的下标为right，那么该子数组的范围为[left+1,right-1]，长度为right-1-left-1+1=right-left-1，分数为nums[i]*(right-left-1),注意合法的子数组需要满足左右端点与k的关系


1631. 最小体力消耗路径
BFS+二分
二分枚举体力消耗值，判断是否能找到终点
对于限定最大值max，使用BFS从起点出发搜索是否能到达终点，当相邻格子未被访问且高度差绝对值小于max时放入队列，能到达终点说明当前max合法

2516. 每种字符至少取 K 个
滑动窗口
先统计出每个字符分别有多少个，如果存在某字符个数少于k，直接返回-1。获取一个最长的窗口，窗口内每个字符的个数&lt;=cnt-k，cnt是字符对应的总数，那么n-窗口长度就是答案


2509. 查询树中环的长度
最近公共祖先
对于每个查询获取其最近的公共祖先，答案为两个节点分别到与公共祖先的距离+1
由于本题是数组表示的完全二叉树，可以通过下标快速获取最近公共祖先的位置
具体实现：对于编号a和b
如果 a&gt;b，说明 a 的深度大于等于 b 的深度，把 a 移动到其父节点，即 a=a/2；
如果 a&lt;b，说明 a 的深度小于等于 b 的深度，把 b 移动到其父节点，即 b=b/2；
如果 a=b，则找到了 LCA，退出循环


1690. 石子游戏 VII
前缀和+动态规划
定义dp[i][j]表示对于数组区间[i,j]两人得分的差值
使用前缀和快速计算石头的价值之和
具体实现：从小到大枚举区间长度，dp[i,j]可由更小的区间dp[i+1,j]或dp[i,j-1]转移而来，二者取最大


1737. 满足三条件之一需改变的最少字符数
模拟
枚举a的最大值，b的最小值的各种情况，取最少操作次数
枚举b的最大值，a的最小值的各种情况，取最少操作次数
枚举a和b每个字母都相同时的各种情况，取最少操作次数
答案取上面三个方案中的最少操作次数


2434. 使用机器人打印字典序最小的字符串
贪心+栈
遍历s，不断从s中取出ch，放入栈中。
什么时候将字符写到纸上？
当栈顶元素&lt;=当前s中剩余字符的最小值时，将其写在纸上。
否则应继续从s取到那个更小值ch&#39;，让ch&#39;在答案字符串的前排


1696. 跳跃游戏 VI
动态规划+优先队列
使用maxScore记录到达每个位置的最大得分
对于位置x，需要知道[x-k,x-1]的最大得分，可以使用优先队列快速获取该区间内的最大得分


2023.08.03

1463. 摘樱桃 II
动态规划
两个机器人同时移动，任意时刻两个机器人都在同一行中
定义dp[i][j][k]表示在移动到下标为i的行时，机器人1位于(i,j)，机器人2位于(i,k)可以收集的最多樱桃数目
初始化：除了dp[0][0][n-1],所有状态初始化为-1
当机器人1与机器人2位于同一列时，只能摘取一次（摘取顺序不影响答案）
枚举机器人1的上一个状态以及机器人2的上一个状态，当两个机器人的上一个状态都合法（不等于-1）时，进行状态转移，取最大的状态
枚举到达m-1行时，机器人1和机器人2分别位于不同位置时可以收集的最多樱桃数目，取最大作为答案


2564. 子字符串异或查询
预处理
需要找到一个二进制字符串str，满足：str对应的十进制值 ^ firsti == secondi
根据异或的性质，等价于str对应的十进制值 == firsti ^ secondi
由于0 &lt;= firsti, secondi &lt;= 1e9 那么满足条件的str字符串对应的十进制值也会在该范围中
预处理所有长度&lt;=30的子字符串及其位置，通过哈希表快速匹配字符串


2392. 给定条件下构造矩阵
拓扑排序
矩阵的大小为 k × k ，需要填充k个数字，让每个数字独占一行，可以尽可能的使矩阵满足条件
分别对行和列的约束关系进行拓扑排序，从而确定数字的位置
如果行和列的拓扑排序后得到的序列长度&lt;k，说明出现了环（所有节点的入度都不为0），则无法构造矩阵
注意：题目给的约束条件是有重复的！比如[a,b]可能出现多次，需要去重处理


2350. 不可能得到的最短骰子序列
思维+哈希表
一开始，可以表示的最长子序列长度len为0
遍历数组，每当某个时刻1~k都出现至少一次，那么len+=1，并清空对所有数字的计数
最后无法表示的长度为len+1 
使用哈希表快速判断每个数字是否都出现至少一次


1537. 最大得分
贪心+前缀和
两个数组都有序，那么不论怎么走，所有的公共点都至少经过一次
记录公共点的位置，当遇到公共点时，根据前缀和判断是否要切换路径（比较两条路径中，当前公共点与下一个公共点之间的所有数字的和，贪心地选择和更大的路径）
1.所有公共点只统计一次
2.第一个公共点之前、最后一个公共点之后的路径怎么走，需要额外讨论
3.两个数组没有任何公共点时，也需要额外讨论


1642. 可以到达的最远建筑
二分+贪心+排序
一架梯子相当于无限量的砖块，因此梯子应该用在高度差尽可能大的地方
二分枚举到达最远的下标，将其中每次需要梯子或砖块的地方的高度差统计出来，进行排序
排序后，在最大的ladders个高度差上使用梯子，其余的高度差使用bricks
如果使用后bricks&gt;=0说明该下标可达，缩小左边界，否则缩小右边界
最后一个合法的左边界作为答案
获取高度差时，可以遍历，也可以预处理+二分(这里直接从下标0开始遍历到下标mid获取高度差)

2023.08.07

815. 公交路线
BFS
先遍历所有的线路，若该线路中存在起始点source，则将该线路中所有点放入队列中
进行BFS，路线不需要重复访问，每访问到一条路线时将其标记为已访问
进入新的路线时将整个路线的点入队。找到终点target时返回答案
特判：source==target时，不需要乘坐任何公交车，返回0


2439. 最小化数组中的最大值
二分
枚举经过操作后，数组的最大值为x，遍历数组判断是否可行
进行操作相当于可以把后面大于x的元素全部改为x，并分配给前面小于x的元素
遍历数组：
当nums[i]&lt;x时，可以为后面的元素分担x-nums[i]
当nums[i]&gt;x时，需要前面的元素分担nums[i]-x
记当前剩余可分担的大小为cnt，任何时刻cnt&lt;0说明令最大元素为x不可行


1293. 网格中的最短路径
BFS 
对于每个状态，记录当前状态的行下标、列下标和已经消除的障碍物个数，记已经消除的障碍物个数是 eliminations，记当前状态的最少步数是distance
如果当前状态已经到达右下角，则返回distance。如果当前状态尚未到达右下角，则对于四个方向上的每个相邻单元格执行BFS：
1.如果相邻单元格是空白，且该相邻单元格对应的消除eliminations个障碍物的状态未访问，则将该相邻状态的最少步数更新为 distance+1，继续访问该相邻状态。
2.如果相邻单元格是障碍物，且满足eliminations&lt;k、该相邻单元格对应消除eliminations+1 个障碍物的状态未访问，则将该相邻状态的最少步数更新为distance+1，继续访问该相邻状态。
3.遍历结束之后，如果未到达右下角，则不存在从左上角到右下角的路径，返回 −1


1943. 描述绘画结果
差分
注意到 1 &lt;= start_i &lt; end_i &lt;= 1e5 那么只需要开一个差分数组就可以知道某下标的颜色之和
但是颜色值相同可能是由不同颜色混合而来的，如何区分？
将差分数组开成二维，分别记录加和减，某位置如果有加或有减，那么它就是不同颜色的边界
将color初始化为0，每遇到颜色边界时，如果color不为0，添加答案，更新color，并更新color的左边界pre为当前的下标i


835. 图像重叠
思维+模拟
将所有的1上下左右移动相当于img1的(0,0)位置可以贴在img2的任意坐标(可以超出img2的范围)，img1自身相对位置保持不变
枚举帖在img2的任意坐标位置，计算最大重叠数
实际上枚举img1贴在img2中的x坐标(-n,n),y坐标(-n,n)即可，因为超出该范围的坐标即使贴上去两张图片也不会有重叠


1250. 检查「好数组」
裴蜀定理
对于不全为零的任意整数 a 和 b，记 g = 最大公约数(a, b)，则对于任意整数 x 和 y 都满足 a×x + b×y 是 g 的倍数
特别地，存在整数 x 和 y 满足 a×x + b×y=g
裴蜀定理可以推广到任意个整数的情况，本题等价于求出nums数组中所有元素的最大公约数，若最大公约数为1返回true

1032. 字符流
字典树
1.把words中所有单词放入字典树
2.使用StringBuilder记录当前的字符流
3.对于每一次查询，枚举StringBuilder中的所有后缀，如果能找到返回true
使用字典树可以通过现有的StringBuilder进行后缀匹配，不需要截取字符串，因此省下许多时间


1488. 避免洪水泛滥
贪心+TreeSet
由于湖泊编号较大，可以使用哈希表来存储哪些湖泊是满的
每次遇到不下雨的天气，先存储抽干湖泊的机会，具体操作是将该机会的下标放入TreeSet中
当湖泊未满时，记录湖泊的满水日期
当遇到湖泊已满时，使用湖泊满水日期之后最近的抽水机会，具体使用TreeSet的higher方法查找，并更新湖泊的满水日期


2023.08.08

1092. 最短公共超序列
动态规划
str1、str2长度最大为1000，可以根据数据量推测解题使用的算法
定义dp[i][j]表示同时以str1中[i,m-1]的字符和str2中的[j,n-1]的字符作为子序列的最短字符串的长度
初始化：其中一个字符串不选取任何字符时，dp值为另一个字符串的长度
状态转移：
ch1==ch2时，最短字符串的开头为ch1，dp[i][j] = dp[i+1][j+1] + 1 
ch1!=ch2时，最短字符串的开头为ch1或ch2，dp[i][j] = min(dp[i+1][j],dp[i][j+1])+1
最后根据字符的相同情况以及dp值的转移过程构造答案字符串


907. 子数组的最小值之和
单调栈
最容易想到的是使用双循环枚举每个子数组的最小值计算答案，超出时间限制
如果枚举arr[i]作为最小值时对答案的贡献呢？那么就需要使用单调栈来维护arr[i]作为最小值时子数组的左右边界
假设左边更小值出现在下标left，右边更小值出现在right 则对答案的贡献为(i-left)*(right-i)*arr[i]
但是这样计算会导致子区间的重复计算，因此需要使用左开右闭或者左闭右开区间


1882. 使用服务器处理任务
优先队列
服务器分配规则：
1.需要处于空闲状态，优先分配给权重最小的服务器
2.权重相同时，分配给下标最小的服务器
使用两个优先队列分别存放空闲服务器、繁忙服务器
使用time来标记全局时间，遍历任务数组并处理任务，每遍历一次time+=1
遍历完任务数组后，可能还有任务没有完成，这时候继续处理，此时time应该直接“加速”到又有繁忙服务器变为空闲的时间，而不是简单+1（每个任务的完成时间可能会很长）


2151. 基于陈述统计最多好人数
二进制枚举
人数至少为2，那么可以认为好人数至少为1（可以枚举所有的4种情况来证明）
情况一：
1 认为2 是好人
2 认为1 是好人
最佳情况是两人都是好人
情况二：
1 认为2 是坏人
2 认为1 是好人
至少1可以是好人，此时2是坏人
情况三：
1 认为2 是好人
2 认为1 是坏人
至少2可以是好人，此时1是坏人
情况四：
1 认为2 是坏人
2 认为1 是坏人
可以认为1或2是好人，那么另一个人是坏人而且说假话
人数至多为15，可以通过二进制枚举[1,1&lt;&lt;n-1]，二进制位上为1代表是好人，0代表是坏人
对于i，一边统计好人个数cnt，一边判断好人的陈述是否出现矛盾，若出现直接跳出循环，不出现矛盾时根据cnt维护答案


1278. 分割回文串 III
预处理+动态规划
先预处理每个区间[left,right]构成回文子串需要的最少修改字符数
定义dp[i][j]表示[0,i]区间分割为j个回文子串时需要的最少字符数


2023.08.09

805. 数组的均值分割
折半搜索+二进制枚举
数组长度最大为30,由于A、B不能为空，考虑可行方案下，A、B的长度：A长度为[1,29], B长度为30-A长度
此时进行pow(2,30)次搜索会超出时间限制，可以使用折半搜索达到空间换时间的效果
具体实现是先对数组的前一半进行搜索，并记录相关信息，再对数组后一半进行搜索，判断是否存在前一半的一种方案与后一半的一种方案可以组合出答案
折半搜索时，对于数组长度n，使用n/2位的二进制数来表示A、B中的元素情况
如果前半段和后半段能组合出一种数组A使得平均值为整个数组的平均值all/n，则数组B自然也满足条件
设前半段的长度为j，和为ele，那么有等式(ele+sum)/(j+cnt)==all/n，移项可得ele的表达式：
ele=all(j+cnt)/n-sum，从哈希表中判断是否存在该ele即可，由于除法可能导致整数计算精度不正确，可以使用乘法再验算一遍


1733. 需要教语言的最少人数
贪心+模拟
数据量较小，可以把所有是好友且无法沟通的关系找出来，再枚举教学的语言


940. 不同的子序列 II
枚举
字符串仅由小写英文字母组成，枚举以26个小写字母为结尾的子序列的个数，最后答案就是以26个小写字母为结尾的子序列个数之和
具体实现：每遇到一个字符ch，先统计之前以a~z为结尾的子序列的总数sum，那么现在以ch为结尾的子序列总数应更新为sum+1。
可以在每次遍历时都统计总数sum，也可以把总数sum作为全局变量来维护


928. 尽量减少恶意软件的传播 II
并查集
在924题尽量减少恶意软件的传播I中，只是让某个节点初始时不再是感染状态，并不影响联通分量的状态
本题中，让某个节点被完全删除，可能将原来的联通分量拆分成多个联通分量
对健康节点进行建图，合并，得到多个联通分量
枚举每一个初始感染节点，统计对哪些联通分量进行了感染
对于健康的连通分量，如果它的感染源只有1个，说明它是可被拯救的
再次枚举初始感染节点，计算移除当前初始感染节点后最终感染的节点数，取可以得到最少节点数的感染节点作为答案


902. 最大为 N 的数字组合
数位dp
将n转化为字符数组进行记忆化数位dp计算
当前填的位置不受限制时，才可以返回缓存中的答案，同时算出结果时继续缓存
当前填好的数字处在不合法的状态时，可以跳过当前数位
当前可以填的数字上限取决于当前位置是否受限制（n为数字上限，当上一位数字与n中对应位数字相同时，当前位置就是受限状态）


756. 金字塔转换矩阵
DFS
数据量较小，dfs搜索是否能完成金字塔的构建
把允许的三角形图案进行状态压缩存入哈希表，方便查找合法图案
dfs参数：上一层的图案pre，当前层的图案now，当前层正在构建的下标index
当前层已构造完毕，递归是否可以构造再上一层，出口为上一层的长度为1，代表金字塔顶部已构建完毕
对于当前层的index下标，枚举可以构建的图案，只要存在一种图案最终到达终点则返回true


963. 最小面积矩形 II
枚举
数据量较小，枚举三个点，判断是否存在第四个点与其组成矩阵


1625. 执行操作后字典序最小的字符串
枚举
无法改变字符串的长度，那么字典序越小就是对应的数字越小，分情况枚举答案
如果 b 是偶数，无论轮转多少次，都只能给奇数位的元素做累加操作
如果 b 是奇数，可以给奇数位和偶数位的元素都做加法，且操作次数可以不同
由于加法超过9会变回0，那么可操作次数也是极小的，很快就会恢复到原来的状态
直接枚举操作的次数，维护字典序最小的字符串作为答案


2023.08.10


927. 三等分
枚举
先统计arr中1的个数sum，若个数为0则返回任意答案，若个数%3不等于0，说明无法做到
将arr分成三部分，每部分中1的个数partial=sum/3，根据每部分中1的个数寻找分割点
由于第一部分和第二部分首尾的0的划分不确定，但是第三部分的尾部是固定的，用第三部分的值来反推是否可以划分为三部分


1986. 完成任务的最少工作时间段
状态压缩+动态规划
数据量较小，可以使用二进制数表示任务完成的状态
定义dp[mask]表示任务完成状态为mask时需要的最小工作时间段
初始化：
1.先初始化所有dp值为最大值
2.枚举mask，若工作时长之和&lt;=sessionTime，可以在一个工作时间段内完成，dp[mask]初始化为1
状态转移：
对于mask，枚举其子集subset，如果dp[subset]==1，则dp[mask]可由dp[mask^subset]+1转移而来，取最小的dp[mask]
返回答案：dp[(1&lt;&lt;n)-1]，表示所有任务都完成所需要的最少工作时间段


2250. 统计包含每个点的矩形数目
枚举+排序+二分
横坐标最大为1e9，纵坐标最大只有100
首先对矩阵的右上角按横坐标从小到大排序
对矩阵的右上角按纵坐标分组，每个纵坐标对应一个或多个横坐标，存入哈希表中
对于查询点(x,y)，纵坐标&lt;y的矩阵必然不会包含该点
枚举纵坐标，从y遍历到100，对每一个纵坐标进行二分查找大于等于x的个数，就是该纵坐标上包含查询点的矩阵的个数，累加即可得到答案


2488. 统计中位数为 K 的子数组
前缀和
数组由1到n的不同整数组成，k只出现一次，对于其他数，只考虑与k相比的大小，具体大小不影响答案
中位数为k的子数组满足以下条件的任意一条：
1.包含k，小于k的个数 与 大于k的个数相等
2.包含k，只有一个大于k的元素，没有任何一个小于k的元素
3.只包含k，没有其他任何元素
将小于k的数记作-1，大于k的数记作1，等于k的数记作0，则有：
对于上述的条件1，等价于子数组元素和为0
对于上述的条件2，等价于子数组元素和为1
对于上述的条件3，等价于子数组元素和为0
对于当前的前缀和sum，若之前出现过一个前缀和pre，满足sum-pre=0或sum-pre=1，就可以构成满足题意的子数组，移项可得pre的表达式：pre=sum或pre=sum-1
使用哈希表记录前缀和出现的次数获取答案
注意:
1.需要在包含k时和包含k之后才可以开始记录答案（满足子数组要包含k的条件）
2.在k出现之后，不需要再向哈希表中记录前缀和


765. 情侣牵手
贪心+并查集
对于一对情侣，假设编号为a，b，那么让a，b并肩坐在一起即可，与具体顺序是a，b还是b，a无关，因此可以将同一对情侣编上相同的号，以简化代码
由于座位没有循环，最终0，1下标的座位必然是同一对情侣，而不会出现1，2下标是同一对情侣，因为这样0下标的人无法与Ta的对象牵手
将n对情侣看做图中的n个节点，对于每两个相邻的节点，如果是第 i 对与第 j 对坐在了一起，则在 i 号节点与 j 号节点之间连接一条边，代表需要交换这两对情侣的位置
最终每一个联通分量都是一个环，交换次数为这个联通分量的大小减1
统计所有联通分量的交换次数作为答案


2023.08.15

911. 在线选举
预处理+二分查找
预处理每一个时间的最近获胜者，对于查询t，找到&lt;=t时间的获胜者作为答案

2023.08.16

1686. 石子游戏 VI
贪心
假设有石子a和石子b，Alice认为价值为a1，b1，Bob认为价值为a2，b2
考虑取石子的方案：
第一种方案：Alice取第一个石子，Bob取第二个石子，此时分数差diff1=a1-b2
第二种方案：Alice取第二个石子，Bob取第一个石子，此时分数差diff2=b1-a2
两种不同方案之差：
diff = diff1 - diff2 = (a1+a2) - (b1+b2)
因此有：
diff&gt;0 第一个方案更优 此时(a1+a2) &gt; (b1+b2)
diff=0 两个方案等价  此时(a1+a2) = (b1+b2)
diff&lt;0 第二个方案更优 此时(a1+a2) &lt; (b1+b2)
对于Alice而言，a石头和b石头哪一个的双方认为价值之和更大，就选择那个石子
因此对于每个人而言，贪心地选择剩余石头中双方认为价值之和更大的石子就是最优策略
将石子价值之和放入优先队列，模拟两人取石子的过程，统计两人分数得到答案


2328. 网格图中递增路径的数目
动态规划+优先队列
定义dp[i][j]表示以(i,j)为终点的路径数目
需要从较小值所在位置开始计算，每个位置都可能从四个方向上的更小值转移而来，记录每个位置的数值大小并放入优先队列，按数值从小到大顺序对每个位置进行计算


2092. 找出知晓秘密的所有专家
BFS
使用哈希表维护目前知道秘密的专家的编号
同一个时间的会议上，对知道秘密的人进行BFS，得到该时间过后有多少人知道秘密


1927. 求和游戏
数学
当问号的个数为零，可直接判断胜负，下面讨论问号个数不为零的情况
结论1：如果问号的个数为奇数，那么Alice一定获胜。
因为Alice是先手操作，那么最后一个问号是由Alice来操作的，Alice可以让前一半数字与后一半数字不相等
结论2：如果问号的个数是偶数，前一半数字和为n0，问号个数为q0，后一半数字和为n1，问号个数为q1，Bob只有在n0-n1=(q1-q0)*9/2成立时必胜


1761. 一个图中连通三元组的最小度数
枚举
数据量较小，建图后枚举可能的三元组（注意剪枝），统计度数，取最小度数作为答案


2448. 使数组相等的最小开销
排序+前缀和+枚举
枚举把数组中所有元素变成nums[i]的开销，使用前缀和+排序快速计算开销，取最少的开销作为答案
将cost[i]理解为nums[i]有cost[i]个即可

2023.08.21

1223. 掷骰子模拟
dfs+记忆化
枚举第一次投掷的编号，第二次投掷的编号...最后一次投掷的编号
根据题目数据的大小，开三维数组cache进行记忆化，注意不合法序列的判断


1981. 最小化目标值与所选元素的差
暴力枚举
数据量较小，可以枚举到下标为i的行为止，每行选一个元素能得到的所有可能和值
最后遍历选到最后一行的所有可能和值，维护与目标值的最小绝对差 


880. 索引处的解码字符串
模拟
模拟解码字符串的过程，直到解码出至少k个字符，再回头寻找第k个字符，如果回头寻找时遇到数字，将长度除以数字，并将k对长度求余


2333. 最小差值平方和
排序+二分
获取每对nums1[i]和nums2[i]的差值，放入diff数组
k1和k2都可以让diff中最大的一个元素减1，记总共的剩余操作次数为cnt，cnt=k1+k2
对diff进行排序，二分查找得到在提供cnt次操作的情况下，diff中最小的最大差值为maxDiff
得到maxDiff后，计算使最大差值为maxDiff后还有多少剩余次数
在maxDiff的情况下，说明要么剩余次数为0，要么就是其他的maxDiff可以再减1，直到次数被用完，这是由于如果可以把所有的maxDiff缩小，那么maxDiff就会是maxDiff-1了

2023.08.23

2477. 到达首都的最少油耗
递归
对于一个节点u，计算出以u为根节点的子树（包括u节点）的节点总数为cnt
因此得到节点u向其父节点p出发需要提供的汽车数量car为Math.ceil(cnt*1.0/seats)
当u不为首都时，u到p的耗油量即为car，ans+=car


2472. 不重叠回文子字符串的最大数目
预处理+动态规划
预处理每个区间[i,j]是否回文
定义dp[i]表示s中前i个字符能选择的子字符串的最大数目


1105. 填充书架
动态规划
定义dp[i]表示放置前i本书需要的最小高度，由于书的放置顺序固定，
对于前i本书，可以枚举[j,i-1]的书放在新一层书架上，前提是[j,i-1]的宽度之和符合题意，那么新增高度为max(height[j],height[i-1])


1354. 多次求和构造目标数组
逆向思维 模拟
target中最大的数字（记下标为maxIndex）是上一轮的sum，因此可以推出在上一轮中下标为maxIndex的元素的值，不断往回推，判断最后能否得到全1数组（数组之和为n，n是数组长度）
当最大元素&gt;其他元素之和时，每一次操作会让最大元素减少(sum-最大元素),需要优化计算使其可以一步得到多次操作后的最大值（使用求余）


1353. 最多可以参加的会议数目
贪心+排序+优先队列
将会议按照开始时间排序，遍历每个时间，将已开始的会议其放入优先队列中
优先队列按照结束时间早的优先，贪心的参加较早结束的会议，参加会议或会议已结束移除队列


909. 蛇梯棋
BFS
注意到n比较小，可以直接BFS得到答案


2547. 拆分数组的最小代价
动态规划
定义dp[i]表示前i个元素拆分的最小代价


2517. 礼盒的最大甜蜜度
排序+二分
二分判断甜蜜度是否可行，取最大可行甜蜜度作为答案


2741. 特别的排列
状态压缩+记忆化dfs
枚举每一个位置填的数字，得到合法完整排列后计入答案


2271. 毯子覆盖的最多白色砖块数
排序+双指针
结论：一定存在至少一种覆盖砖块最多的方案，毯子的左端点位置是在某一段连续瓷砖的第一个
对于离散区间是否覆盖的处理：使用p指针维护覆盖到了哪一片连续瓷砖


2251. 花期内花的数目
排序+优先队列
将花朵按开花时间排序，将人按时间先后排序，遍历每个人的看花时间
开花后将其结束时间放入优先队列，动态获取每个人能看到的花的数目


1210. 穿过迷宫的最少移动次数
BFS
数据量较小，直接BFS


2023.08.24

1235. 规划兼职工作
排序+动态规划
将工作按照结束时间排序
定义dp[i]表示前i份工作能得到的最大报酬
枚举做第i份工作或不做第i份工作：
不做第i份工作时，dp[i]=dp[i-1]
做第i份工作时，需要找到前面的一个dp[j]，使得第j件工作的结束时间data[j-1][2]&lt;=第i件工作的开始时间data[i-1][0]
由于dp[j]已经是前j件工作的最大报酬了，因此找到这样的j后立即更新dp[i]的值并跳出循环，避免超时


2597. 美丽子集的数目
dfs+回溯
数据量较少，dfs枚举每个位置选或不选


1734. 解码异或后的排列
模拟
注意encoded的长度是n-1，perm的长度是n
1.将encoded中下标为奇数的元素进行异或，得到除perm第一个元素以外其他元素的异或运算结果
2.将1~n元素进行异或，可以得到perm所有元素的异或运算结果
将1和2的结果进行异或，从而得到perm第一个元素的值，perm其他元素的值可根据encoded的计算方式反推得到


1406. 石子游戏 III
动态规划
定义dp[i]表示剩余石子的下标范围是[i,n-1]时当前玩家与对方玩家的得分之差的最大值


1626. 无矛盾的最佳球队
排序+动态规划
对球员按分数进行排序，分数相同按年龄排序
定义dp[i]表示选择下标为i的球员得到的无矛盾球队中最高的得分
由于已排好序，对于dp[i]，向前枚举无矛盾的dp[j]，取最大的dp[j]+下标为i的球员的分数作为dp[i]的值


895. 最大频率栈
模拟
原始栈拆分成多个栈，使用一个哈希表来维护栈中元素及其出现个数
用一个列表来存多个栈，栈的下标表示出现频率，每次pop时从最后一个栈（频率最高）中取出元素


2772. 使数组中的所有元素都等于零
贪心+差分
遍历数组元素，若当前元素不为0则将当前位置以及后面k-1个位置同时减去当前元素，让当前位置为0
若后面出现负数，返回false。遍历完所有元素，说明可以让数组元素都等于0，返回true
使用差分数组快速进行区间操作


2023.08.25

剑指 Offer 51. 数组中的逆序对
归并排序
进行归并排序，将数组分成前半段[left,mid]和后半段[mid+1,right]，且这两部分再次递归进行归并，现已各自有序，进行合并
在合并时，若前半段中存在元素nums[i]&gt;后半段中的nums[j]，由于前半段已经有序，那么[i,mid]这区间的所有元素也会&gt;后半段中的nums[j],对答案的贡献就是[i,mid]区间的长度mid-i+1


2426. 满足不等式的数对数目
归并排序
对于题目中的条件，移项可得nums1[i]-nums2[i]-diff &lt;= nums1[j]-nums2[j]
对所有的nums1[i]-nums2[i]进行归并排序，合并时进行统计得到答案


1425. 带限制的子序列和
优先队列+动态规划
定义dp[i]表示到下标i为止，恰好选择了nums[i]的最大子序列和
使用优先队列维护往前k个dp值，先按时间先后排序，再按dp值从大到小排序，进行状态转移时取未过期的最大值
在遍历时维护答案，因为最大子序列和不一定出现在dp[n-1]


2023.08.26

2262. 字符串的总引力
思维题/贡献法
对于s中的每一个字符ch，可以计算出ch对哪个范围内的子串做出贡献
规定一个子字符串，如果包含多个相同的字符ch，那么只有第一个ch对本子串做出贡献
统计s中每个字符的上一次出现位置pre[ch-&#39;a&#39;]，遍历字符串，对于下标为i的ch有：
ch作用的子串范围：最小左端点pre[ch-&#39;a&#39;]+1 最大右端点s.length()-1
以i为中心，左端点left和右端点right可任意组合，因此需要相乘，ch对答案的贡献为((long)i-pre[ch-&#39;a&#39;])*((long)s.length()-i)
累加所有ch对答案的贡献，得到最终答案


2136. 全部开花的最早一天
贪心
开花周期长的花优先种植,同时获取每朵花的开花时间,最大的开花时间就是答案

828. 统计子串中的唯一字符
预处理/贡献法
对于下标i的字符ch，预处理向前最近的一个相同字符ch的位置pre和向后最近的一个相同字符ch的位置suf，
可得到ch对哪些范围内的子串做出了贡献,以i为中心,左右端点可两两组合，因此需要相乘


947. 移除最多的同行或同列石头
并查集
根据同行或同列对石头进行合并，最后可以得到多个集合
每一个集合应该是呈网格形的，对于每个集合，可以不断移除石头，直至该集合剩下1个石头
数据量较小，使用双重循环进行合并


1335. 工作计划的最低难度
动态规划
特判：任务个数为n，计划天数为d，当n&lt;d时无解，当n==d时每天恰好完成一个任务，当d==1时返回难度数组中的最大值
定义dp[i][j]表示计划进行前i+1天，完成到下标为j的任务时的最小难度
由于每天至少完成1个任务，在转移时应注意上一个状态最少完成任务的数量


1140. 石子游戏 II
动态规划
定义dp[i][j]表示区间[i,len-1]先手玩家能得到的最多石子数
当i+2M&gt;=len时，当前玩家可直接取走剩余的所有石子
否则，枚举当前选多少能得到最多石子数


1348. 推文计数
暴力模拟
0 &lt;= endTime - startTime &lt;= 1e4且最多操作1e4次
理论数据量为1e8（时间的遍历每次至少为60，实际数据量更少），可直接暴力模拟


2245. 转角路径的乘积中最多能有几个尾随零
数学+预处理+前缀和
结论1：至少存在一个两端位于数组边界的路径的尾随零数量最多。因为在得到某条存在尾随零且两端未到达数组边界的路径时，可继续向边界选取数字，尾随零的数量只多不少
结论2：至少存在一条尾随零数量最多的路径，且该路径属于转角路径。因为直线路径进行转角，尾随零的数量只多不少
计算优化：尾随零的数量等于路径上所有元素进行质因数分解后因子2的数目与因子5的数目的较小值
枚举所有可能的路径：
1.从上往下走，枚举左拐/右拐
2.从下往上走，枚举左拐/右拐


2116. 判断一个括号字符串是否有效
数学
如果字符串长度为奇数，无论如何也无法有效，返回false
令左括号分数为1，右括号分数为-1，那么对于一个括号字符串s，其有效的条件等价于：
任意前缀的分数均&gt;=0 且 整个字符串的分数为0


1590. 使数组和能被 P 整除
数学+前缀和
如果整个数组可以被p整除，返回0，否则先记下数组元素和%p的值mod
使用哈希表记录每个前缀和及其出现下标，如果两个前缀和的值相差恰好为mod，说明存在一个子数组和为mod：对于整个数组而言，对p求余为mod，减去这个子数组对p求余就恰好为0了
记录前缀和的变量sum也需要不断对p求余，因为要找的mod(子数组和)是通过对p求余得来的，对于sum而言，需要找到前面一个前缀和的值为(sum-mod+p)%p
记录最短的子数组长度作为答案


1201. 丑数 III
容斥原理+二分
[1,i]中,能被a整除的数的个数为i/a
由容斥原理可以求出[1,i]中能被a或b或c整除的数的个数之和count=i/a + i/b + i/c - i/lcmAB - i/lcmBC - i/lcmAC + i/lcmABC
二分查找满足count&gt;=n的最小i即为答案


1371. 每个元音包含偶数次的最长子字符串
哈希表记录前缀状态+状态压缩
对于5个元音字母出现的次数的状态，使用5个2进制位来表示，1代表出现奇数次，0代表出现偶数次
使用哈希表记录最早出现某个状态status的下标，当后面再次出现这个状态status时，说明每个元音字母的奇偶性再次相同，即两个status之间的子字符串满足条件，根据长度维护答案


1751. 最多可以参加的会议数目 II
排序+动态规划+二分查找
按照结束时间排序
定义dp[i][j]表示前i个会议最多参加j个能得到的最大价值
不参加第i个会议时，dp[i][j]=dp[i-1][j]
参加第i个会议，dp[i][j]=max(dp[p][j-1]+value[i])，p是与第i个会议没有冲突的，结束的最晚的一个会议，p通过二分查找得到


2735. 收集巧克力
预处理+枚举
数组长度较小，旋转对每个元素同时生效，可以枚举旋转的次数，设旋转次数为count，则有：
收集下标为i的元素的成本为nums中区间[i,(i+count)%n]的最小值
可以预处理每个区间的最小值，把数组多复制一份，预处理时区间就不需要跨越数组边界


2551. 将珠子放入背包中
排序+贪心
问题等价于需要在数组中切k-1刀，得到k个非空子数组，每个子数组的左右边界的元素之和就是分数
枚举每一个可以切的位置i，切下去可以得到nums[i]和nums[i+1]的分数，对每个位置可以得到的分数进行排序，取最小的前k-1个位置可得到最小分数，取最大的前k-1个位置可得到最大分数，从而得到答案


1553. 吃掉 N 个橘子的最少天数
数学+记忆化搜索
吃掉1个橘子的操作是最少的，每次选择吃二分之一或三分之二的橘子，两个方案取最少天数


1648. 销售价值减少的颜色球
贪心+排序+二分
贪心地每次都卖出剩余个数最多的球，得到最大价值
二分查找一个值，满足给定orders次减少的机会，令数组中的最大值最小，得到这个值记为max
那么最后结果数组中，最大值就只能为max，先把数组中所有大于max的卖到只剩max
如果orders还不为0，保留一个max，对其他max再减1，直到次数被用完
这是由于如果可以把所有的max缩小，那么max就会是max-1了
</code></pre>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-苍穹外卖笔记" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2023-07-18T09:25:42.000Z"><a href="/2023/07/18/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E7%AC%94%E8%AE%B0/">2023-07-18</a></time>
      
      
  
    <h1 class="title"><a href="/2023/07/18/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E7%AC%94%E8%AE%B0/">苍穹外卖笔记</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h1 id="p1"><a href="#p1" class="headerlink" title="p1"></a>p1</h1><ul>
<li>项目效果展示</li>
<li>2023-07-18 17:44:13</li>
</ul>
<h1 id="p2"><a href="#p2" class="headerlink" title="p2"></a>p2</h1><ul>
<li>软件开发流程介绍</li>
<li>需求分析阶段：需求规格说明书、产品原型（使用静态网页展示）</li>
<li>设计阶段：UI设计、数据库设计、接口设计</li>
<li>编码阶段：项目代码、单元测试</li>
<li>测试阶段：测试用例、测试报告</li>
<li>上线运维：软件环境安装、配置</li>
<li>软件环境：开发环境、测试环境、生产环境</li>
<li>2023-07-18 17:52:05</li>
</ul>
<h1 id="p3"><a href="#p3" class="headerlink" title="p3"></a>p3</h1><ul>
<li>项目介绍</li>
<li>前端分为管理端（vue实现）和用户端（微信小程序）</li>
<li>技术选型<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">用户层 node.js vue.js elementUI 微信小程序 apache-echarts</span><br><span class="line">网关层 nginx</span><br><span class="line">应用层 SpringBoot SpringMVC SpringTask httpclient SpringCache</span><br><span class="line">	   JWT 阿里云OSS Swagger POI WebSocket</span><br><span class="line">数据层 Mysql Redis mybatis pagehelper spring-data-redis	 </span><br><span class="line">工具   Git maven Junit postman  </span><br></pre></td></tr></table></figure></li>
<li>2023-07-18 18:03:27</li>
</ul>
<h1 id="p4"><a href="#p4" class="headerlink" title="p4"></a>p4</h1><ul>
<li>前端环境搭建</li>
<li>前端代码已打包部署到nginx中 运行nginx.exe即可启动前端项目，访问端口号为80</li>
<li>2023-07-18 18:09:09</li>
</ul>
<h1 id="p5"><a href="#p5" class="headerlink" title="p5"></a>p5</h1><ul>
<li>后端环境搭建</li>
<li>后端工程使用maven进行分模块开发</li>
<li>模块信息<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sky-take-out  maven父工程，统一管理依赖版本，聚合其他子模块</span><br><span class="line">sky-common 子模块，存放公共类（工具类、常量类、异常类）</span><br><span class="line">sky-pojo 子模块，存放实体类</span><br><span class="line">sky-server 子模块，后端服务，存放配置文件、Controller、Service、Mapper等</span><br></pre></td></tr></table></figure></li>
<li>2023-07-18 18:31:17</li>
</ul>
<h1 id="p6"><a href="#p6" class="headerlink" title="p6"></a>p6</h1><ul>
<li>使用git进行版本控制</li>
<li>将项目初始代码推送到git仓库</li>
<li>2023-07-18 18:32:29</li>
</ul>
<h1 id="p7"><a href="#p7" class="headerlink" title="p7"></a>p7</h1><ul>
<li>数据库环境搭建</li>
<li>建表语句已提供，直接执行sky.sql即可</li>
<li>2023-07-18 18:33:57</li>
</ul>
<h1 id="p8"><a href="#p8" class="headerlink" title="p8"></a>p8</h1><ul>
<li>前后端联调测试</li>
<li>外卖管理后台账号admin 密码123456 </li>
<li>修改数据库的配置后，启动springboot主程序类</li>
<li>测试外卖管理后台的登录</li>
<li>2023-07-18 20:56:04</li>
</ul>
<h1 id="p9"><a href="#p9" class="headerlink" title="p9"></a>p9</h1><ul>
<li>前端发送的请求端口为80，而后端的端口为8080，后端能接收到前端的请求，是因为nginx转发了请求</li>
<li>nginx反向代理的好处：提高访问速度、进行负载均衡、保证后端服务的安全（不暴露后端服务器）</li>
<li>2023-07-20 11:40:16</li>
</ul>
<h1 id="p10-p11"><a href="#p10-p11" class="headerlink" title="p10-p11"></a>p10-p11</h1><ul>
<li>配置nginx反向代理</li>
<li>listen： 监听端口号 </li>
<li>location：监听到的请求</li>
<li>proxy_pass指令： 转发的路径</li>
<li>配置nginx负载均衡</li>
<li>upstream webservers：指定多个后端服务器地址</li>
<li>server 192.168.100.128:8080：指定一个后端服务器地址</li>
<li>2023-07-20 11:43:32</li>
</ul>
<h1 id="p12"><a href="#p12" class="headerlink" title="p12"></a>p12</h1><ul>
<li>完善登录功能</li>
<li>不使用明文来存储密码，将密码加密后存储，使用MD5加密</li>
<li>2023-07-20 11:50:12</li>
</ul>
<h1 id="p13"><a href="#p13" class="headerlink" title="p13"></a>p13</h1><ul>
<li>导入接口文档</li>
<li>把接口.json文件导入到YApi平台</li>
<li><a target="_blank" rel="noopener" href="https://yapi.pro/">https://yapi.pro/</a></li>
<li>账号shengshui 密码shengshui </li>
<li>2023-07-20 11:54:59</li>
</ul>
<h1 id="p14"><a href="#p14" class="headerlink" title="p14"></a>p14</h1><ul>
<li>根据接口文档开发后端接口</li>
<li>使用Postman或者Swagger进行接口测试</li>
<li>knife4j是为Java MVC框架集成Swagger生成Api文档的增强解决方案</li>
<li>1.导入knife4j的maven坐标</li>
<li>2.在配置类中加入knife4j相关配置</li>
<li>3.设置静态资源映射，否则接口文档页面无法访问</li>
<li>启动项目后，访问localhost:8080&#x2F;doc.html查看接口文档</li>
<li>2023-07-20 12:02:08</li>
</ul>
<h1 id="pp15"><a href="#pp15" class="headerlink" title="pp15"></a>pp15</h1><ul>
<li>Swagger常用注解</li>
<li>@Api 用在类上，对类进行说明</li>
<li>@ApiModel 用在类上，例如entity、DTO&#x2F;VO</li>
<li>@ApiModelProperty 用在属性上，描述属性信息</li>
<li>@ApiOperation 用在方法上，例如Controller的方法，说明方法用途和作用</li>
<li>2023-07-20 12:04:52</li>
</ul>
<h1 id="p16"><a href="#p16" class="headerlink" title="p16"></a>p16</h1><ul>
<li>新增员工接口的需求分析</li>
<li>2023-07-21 14:43:50</li>
</ul>
<p>#p17</p>
<ul>
<li>使用DTO来封装数据</li>
<li>2023-07-21 14:58:18</li>
</ul>
<h1 id="p18"><a href="#p18" class="headerlink" title="p18"></a>p18</h1><ul>
<li>使用接口文档测试接口</li>
<li>通过登录接口获取JWT令牌，在接口文档的全局参数设置中添加token，以测试新增员工接口</li>
<li>2023-07-21 15:03:14</li>
</ul>
<h1 id="p19-p20"><a href="#p19-p20" class="headerlink" title="p19-p20"></a>p19-p20</h1><ul>
<li>完善新增员工接口</li>
<li>通过新增自定义异常，给前端返回异常的提示信息</li>
<li>使用ThreadLocal动态获取当前登录的用户id，为新增员工时添加操作者id</li>
<li>2023-07-21 15:39:39</li>
</ul>
<h1 id="p21-p24"><a href="#p21-p24" class="headerlink" title="p21-p24"></a>p21-p24</h1><ul>
<li>员工分页查询</li>
<li>使用分页插件完成</li>
<li>在员工实体类的属性上添加JsonFormat注解，让日期类型转化为指定格式</li>
<li>2023-07-21 16:24:25</li>
</ul>
<h1 id="p25-p26"><a href="#p25-p26" class="headerlink" title="p25-p26"></a>p25-p26</h1><ul>
<li>启用&#x2F;禁用员工账号</li>
<li>2023-07-22 18:41:25</li>
</ul>
<h1 id="p27-p29"><a href="#p27-p29" class="headerlink" title="p27-p29"></a>p27-p29</h1><ul>
<li>编辑员工</li>
<li>1.根据id查询员工信息以回显到前端 2.更新员工信息</li>
<li>2023-07-22 19:50:52</li>
</ul>
<h1 id="p30"><a href="#p30" class="headerlink" title="p30"></a>p30</h1><ul>
<li>导入分类管理模块功能源码</li>
<li>2023-07-22 20:05:52</li>
</ul>
<h1 id="p31-p34"><a href="#p31-p34" class="headerlink" title="p31-p34"></a>p31-p34</h1><ul>
<li>公共字段自动填充</li>
<li>公共字段使用java代码来填充，会造成代码冗余</li>
<li>解决方案：自定义注解AutoFill，自定义切面类统一拦截</li>
<li>使用技术：枚举、注解、AOP、反射</li>
<li>2023-07-23 13:40:26</li>
</ul>
<h1 id="p35-p39"><a href="#p35-p39" class="headerlink" title="p35-p39"></a>p35-p39</h1><ul>
<li>新增菜品功能</li>
<li>涉及接口：根据类型查询分类、文件上传、新增菜品</li>
<li>实现文件上传接口时，在JWT校验拦截器中放行文件下载请求<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//判断是否为文件下载接口，如果是直接放行</span><br><span class="line">        HandlerMethod handlerMethod = (HandlerMethod) handler;</span><br><span class="line">        if (handlerMethod.hasMethodAnnotation(GetMapping.class)) &#123;</span><br><span class="line">            GetMapping getMapping = handlerMethod.getMethodAnnotation(GetMapping.class);</span><br><span class="line">            if (getMapping != null &amp;&amp; Arrays.asList(getMapping.value()).contains(&quot;/download/&#123;name&#125;&quot;)) &#123;</span><br><span class="line">                // 当前请求为下载文件接口，直接放行</span><br><span class="line">                log.info(&quot;放行文件下载接口&quot;);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
<li>2023-07-24 17:06:10</li>
</ul>
<h1 id="p40-p41"><a href="#p40-p41" class="headerlink" title="p40-p41"></a>p40-p41</h1><ul>
<li>菜品分页查询</li>
<li>2023-07-24 17:19:56</li>
</ul>
<h1 id="p42-p48"><a href="#p42-p48" class="headerlink" title="p42-p48"></a>p42-p48</h1><ul>
<li>删除菜品、修改菜品</li>
<li>起售中的菜品、被套餐关联的菜品不能删除</li>
<li>菜品成功删除后，关联的口味数据也需要删除 </li>
<li>2023-07-27 13:41:59</li>
</ul>
<h1 id="p49-65"><a href="#p49-65" class="headerlink" title="p49-65"></a>p49-65</h1><ul>
<li>使用Redis来设置店铺营业状态</li>
<li>Redis常用数据类型<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">这些数据类型都是相对于value而言的，key一直是字符串</span><br><span class="line">字符串 string</span><br><span class="line">哈希 hash</span><br><span class="line">列表 list</span><br><span class="line">集合 set</span><br><span class="line">有序集合 sorted set/zset</span><br></pre></td></tr></table></figure></li>
<li>使用Spring Data Redis框架实现在java中操作redis</li>
<li>redis连接过程（自己的电脑为例）<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">虚拟机ip地址：http://192.168.169.128/</span><br><span class="line">打开虚拟机 打开终端</span><br><span class="line">关闭防火墙systemctl stop firewalld.service</span><br><span class="line">.cd /usr/local/redis/bin/ 进入redis安装目录</span><br><span class="line">./redis-server在前台启动redis</span><br><span class="line">再打开一个终端</span><br><span class="line">cd /usr/local/redis/bin/ 进入redis安装目录</span><br><span class="line">./redis-cli连接redis</span><br><span class="line">ping 出现pong说明连接成功</span><br><span class="line">config set protected-mode no 关闭redis的保护模式</span><br><span class="line">接下来可以在java中使用Spring Data Redis连接到redis进行操作了</span><br></pre></td></tr></table></figure></li>
<li>相关接口：设置营业状态 管理端查询营业状态 用户端查询营业状态</li>
<li>在controller下创建user软件包，复制admin软件包下的ShopController，由于两个Controller名字一样会冲突，在@RestController中指定bean的名字避免冲突</li>
<li>@RestController(“userShopController”) @RestController(“adminShopController”)</li>
<li>2023-07-30 15:21:29</li>
</ul>
<h1 id="p66-p69"><a href="#p66-p69" class="headerlink" title="p66-p69"></a>p66-p69</h1><ul>
<li>HttpClient：是一个开源的、用于发送 HTTP 请求的 Java 库</li>
<li>使用该库可以在java中发送http请求，以调用一些第三方的工具或接口。在本项目中用来实现向微信登录接口发送请求，得到登录用户的openid（微信用户的唯一标识）</li>
<li>2023-07-30 17:15:02</li>
</ul>
<h1 id="p70-p85"><a href="#p70-p85" class="headerlink" title="p70-p85"></a>p70-p85</h1><ul>
<li>实现用户端的微信登录和商品浏览</li>
<li>小程序目录结构<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">小程序文件</span><br><span class="line">app.js  必需 小程序逻辑文件</span><br><span class="line">app.json 必需 小程序公共配置</span><br><span class="line">app.wxss 非必需 小程序公共样式表</span><br><span class="line"></span><br><span class="line">页面文件</span><br><span class="line">js 必需 页面逻辑</span><br><span class="line">wxml 必需 页面结构</span><br><span class="line">json 非必需 页面配置</span><br><span class="line">wsxx 非必需 页面样式表</span><br></pre></td></tr></table></figure></li>
<li>导入已写好的微信小程序代码</li>
<li>使用官方提供的登录api实现微信登录，小程序会向生成并向后端发送微信登录授权码，后端拿到</li>
<li>2023-07-31 14:13:35</li>
</ul>
<h1 id="p86-p104"><a href="#p86-p104" class="headerlink" title="p86-p104"></a>p86-p104</h1><ul>
<li>缓存商品、购物车</li>
<li>使用Spring Cache框架：纯注解使用缓存</li>
<li>2023-08-01 12:55:31</li>
</ul>
<h1 id="p105-p122"><a href="#p105-p122" class="headerlink" title="p105-p122"></a>p105-p122</h1><ul>
<li>用户下单、订单支付</li>
</ul>
<h1 id="p123"><a href="#p123" class="headerlink" title="p123"></a>p123</h1><ul>
<li>SpringTask实现定时任务</li>
<li>WebSocket实现订单提醒</li>
</ul>
<h3 id="SpringTask"><a href="#SpringTask" class="headerlink" title="SpringTask"></a>SpringTask</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">使用cron表达式（本质是一个字符串）指定任务触发的时间</span><br><span class="line">构成规则：分为6或7个域，由空格分隔开，每个域分别代表秒、分钟、小时、日、月、周、年（可选）</span><br><span class="line"> </span><br><span class="line"> SpringTask坐标：spring-context</span><br><span class="line"> </span><br><span class="line"> 使用方法</span><br><span class="line"> 1.在启动类上添加@EnableScheduling</span><br><span class="line"> 2.在需要定时触发的方法上添加@Scheduled(cron = cron表达式)</span><br><span class="line"> 3. 注意该类是需要被Spring容器所管理的，否则@Scheduled 注解不生效</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">WebSocket是基于TCP的网络协议，实现浏览器与服务器全双工通信</span><br><span class="line">浏览器和服务器只需完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输</span><br><span class="line"></span><br><span class="line">1.导入坐标</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">2.创建WebSocket配置类</span><br><span class="line">@Configuration</span><br><span class="line">@EnableWebSocket</span><br><span class="line">public class WebSocketConfig implements WebSocketConfigurer &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) &#123;</span><br><span class="line">        registry.addHandler(myWebSocketHandler(), &quot;/websocket&quot;).setAllowedOrigins(&quot;*&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public WebSocketHandler myWebSocketHandler() &#123;</span><br><span class="line">        return new MyWebSocketHandler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">3. WebSocket处理程序</span><br><span class="line">public class MyWebSocketHandler extends TextWebSocketHandler &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterConnectionEstablished(WebSocketSession session) throws Exception &#123;</span><br><span class="line">        // 在建立WebSocket连接后执行的逻辑</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception &#123;</span><br><span class="line">        // 处理收到的文本消息</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception &#123;</span><br><span class="line">        // 在关闭WebSocket连接后执行的逻辑</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-gulimall笔记" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2023-07-02T08:36:29.000Z"><a href="/2023/07/02/gulimall%E7%AC%94%E8%AE%B0/">2023-07-02</a></time>
      
      
  
    <h1 class="title"><a href="/2023/07/02/gulimall%E7%AC%94%E8%AE%B0/">gulimall笔记</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h1 id="p1"><a href="#p1" class="headerlink" title="p1"></a>p1</h1><ul>
<li>项目大致介绍</li>
<li>2023-06-29 16:30:29</li>
</ul>
<h1 id="p2"><a href="#p2" class="headerlink" title="p2"></a>p2</h1><ul>
<li>项目页面展示</li>
<li>2023-06-29 16:53:02</li>
</ul>
<h1 id="p3"><a href="#p3" class="headerlink" title="p3"></a>p3</h1><ul>
<li>分布式中的相关概念</li>
<li>远程调用：SpringCloud中使用HTTP+JSON的方式完成远程调用</li>
<li>负载均衡 算法</li>
<li>轮询：循环调用 </li>
<li>最小连接：优先选择连接数最少 </li>
<li>散列算法：同用户让同一服务器来服务</li>
<li>服务注册：注册中心 </li>
<li>配置中心：每一个服务都有大量配置，设置配置中心让每个服务都从配置中心获取自己的配置</li>
<li>服务熔断&#x2F;服务降级</li>
<li>服务熔断：设置超时时间，服务超时则不再调用该服务，返回默认数据</li>
<li>服务降级：高峰期间，非核心业务不进行处理或者简单处理</li>
<li>API网关：抽象了微服务中的公共功能，同时提供负载均衡、服务熔断、统一认证、限流流控、日志记录等功能</li>
<li>2023-06-29 17:10:42</li>
</ul>
<h1 id="p4"><a href="#p4" class="headerlink" title="p4"></a>p4</h1><ul>
<li>微服务架构图</li>
<li>用户在手机、电脑等客户端发起请求后，请求先转发到nginx集群</li>
<li>nginx集群将请求转发到SpringCloud Gateway网关，该网关再将请求分发给具体的服务</li>
<li>将所有服务注册到注册中心Nacos，同时Nacos作为配置中心</li>
<li>2023-06-30 16:32:13</li>
</ul>
<h1 id="p5"><a href="#p5" class="headerlink" title="p5"></a>p5</h1><ul>
<li>微服务划分图</li>
<li>前端划分：admin-vue 后台管理页面 shop-vue 供客户访问 </li>
<li>后端划分：各种业务服务（商品服务、支付服务、用户服务等）</li>
<li>Nacos：作为注册中心和配置中心</li>
<li>Seata：解决分布式事务</li>
<li>Sentine：解决服务容错</li>
<li>Feign：解决远程调用和负载均衡</li>
<li>Gateway：作为网关</li>
<li>Sleuth：解决服务追踪</li>
<li>Zipkin：解决可视化追踪</li>
<li>Prometheus+Grafana：进行应用监控</li>
<li>redis：作为缓存数据库</li>
<li>mysql：作为持久化数据库</li>
<li>RabbitMQ：提供消息队列</li>
<li>ElasticSearch：提供全文检索</li>
<li>阿里云OSS：存储静态图片视频等</li>
<li>2023-06-30 16:39:36</li>
</ul>
<h1 id="p6"><a href="#p6" class="headerlink" title="p6"></a>p6</h1><ul>
<li>搭建项目开发环境</li>
<li>安装linux环境 </li>
<li>虚拟机系统：centos7 </li>
<li>账号：root 密码：comin-lin </li>
<li>用户账号：lin 用户密码：123456</li>
<li>2023-06-30 16:43:50</li>
</ul>
<h1 id="p7"><a href="#p7" class="headerlink" title="p7"></a>p7</h1><ul>
<li>虚拟机网络设置</li>
<li>2023-06-30 16:45:21</li>
</ul>
<h1 id="p8"><a href="#p8" class="headerlink" title="p8"></a>p8</h1><ul>
<li>安装docker</li>
<li>Docker：虚拟化容器技术，基于镜像，秒级启动各种容器。每种容器都是一个完整的运行环境，容器之间互相隔离</li>
<li>卸载docker<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure></li>
<li>安装相关依赖包以及设置地址<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br><span class="line">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure></li>
<li>安装docker及其客户端：sudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</li>
<li>启动docker：sudo systemctl start docker</li>
<li>查看docker版本：docker -v</li>
<li>查看dokcer所有镜像：sudo docker images</li>
<li>设置docker开机自启：sudo systemctl enable docker</li>
<li>2023-06-30 17:03:30</li>
</ul>
<h1 id="p9"><a href="#p9" class="headerlink" title="p9"></a>p9</h1><ul>
<li>配置docker镜像加速</li>
<li>可以让阿里云完成容器镜像加速，有魔法可不进行配置</li>
<li>2023-06-30 17:06:03</li>
</ul>
<h1 id="p10"><a href="#p10" class="headerlink" title="p10"></a>p10</h1><ul>
<li>安装mysql</li>
<li>下载mysql镜像：sudo docker pull mysql:5.7 </li>
<li>启动镜像：docker run -p 3306:3306 表示linux的3306端口与docker容器的3306端口进行映射。再加上各种配置参数，即可启动mysql镜像</li>
<li>查看docker启动的容器：docker ps</li>
<li>2023-06-30 17:17:39</li>
</ul>
<h1 id="p11"><a href="#p11" class="headerlink" title="p11"></a>p11</h1><ul>
<li>安装redis</li>
<li>同mysql</li>
<li>2023-06-30 17:19:11</li>
</ul>
<h1 id="p12"><a href="#p12" class="headerlink" title="p12"></a>p12</h1><ul>
<li>开发工具、开发环境配置</li>
<li>检查JDK版本，配置maven远程仓库</li>
<li>在VScode中安装插件</li>
<li>auto close Tag：自动关闭标签插件</li>
<li>ESLint：ES语法检查插件</li>
<li>html css support：简化html开发插件</li>
<li>javascript(ES6):js ES6语法提示插件</li>
<li>Live Server：本地启动服务器插件</li>
<li>vetur：vue项目常用插件</li>
<li>2023-06-30 17:25:01</li>
</ul>
<h1 id="p13"><a href="#p13" class="headerlink" title="p13"></a>p13</h1><ul>
<li>配置gitee</li>
<li>配置用户名和邮箱</li>
<li>git config –global user.name “name”</li>
<li>git config –global user.mail “mail”</li>
<li>2023-06-30 17:31:55</li>
</ul>
<h1 id="p14"><a href="#p14" class="headerlink" title="p14"></a>p14</h1><ul>
<li>项目结构创建</li>
<li>创建gulimall项目，包含多个服务模块</li>
<li>2023-06-30 17:40:19</li>
</ul>
<h1 id="p15"><a href="#p15" class="headerlink" title="p15"></a>p15</h1><ul>
<li>数据库初始化</li>
<li>执行oms、pms、sms、ums、wms的sql文件</li>
<li>2023-06-30 18:01:38</li>
</ul>
<h1 id="p16"><a href="#p16" class="headerlink" title="p16"></a>p16</h1><ul>
<li>使用人人开源的renren-fast和renren-fast-vue实现快速开发</li>
<li>将renren-fast导入到项目中</li>
<li>打开renren-fast，找到db目录下的mysql.sql文件，创建后台管理数据库并执行sql文件 </li>
<li>打开renren-fast的配置文件application.yml，配置数据库</li>
<li>启动renren-fast后端项目</li>
<li>使用vscode打开renren-fast-vue</li>
<li>使用npm install安装包后，npm run dev启动前端项目（启动通过set NODE_OPTIONS&#x3D; 清空环境变量）</li>
<li>问题：在npm install时出现报错，解决方法：安装nvm，将node版本从v16切换到v14，以及切换相应的npm版本</li>
<li>nvm（node.js版本管理工具，可自动切换与node版本相匹配的npm版本）常用命令<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nvm off                     // 禁用node.js版本管理(不卸载任何东西)</span><br><span class="line">nvm on                      // 启用node.js版本管理</span><br><span class="line">nvm install &lt;version&gt;       // 安装node.js的命名 version是版本号 例如：nvm install 8.12.0</span><br><span class="line">nvm uninstall &lt;version&gt;     // 卸载指定版本的nodejs，当安装失败时进行卸载</span><br><span class="line">nvm ls                      // 显示所有已安装的node.js版本</span><br><span class="line">nvm list available          // 显示可以安装的所有node.js的版本</span><br><span class="line">nvm use &lt;version&gt;           // 切换到使用指定的nodejs版本</span><br><span class="line">nvm v                       // 显示nvm版本</span><br></pre></td></tr></table></figure></li>
<li>2023-06-30 22:07:08</li>
</ul>
<h1 id="p17"><a href="#p17" class="headerlink" title="p17"></a>p17</h1><ul>
<li>使用人人开源的代码生成器为每个微服务生成代码</li>
<li>将renren-generator导入到项目中，并在聚合服务的pom.xml中导入module</li>
<li>在renren-generator的application.yml中配置数据库，在generator.properties中配置生成信息</li>
<li>启动renren-generator项目，在本地80端口打开，点击renren-fast选项，选择需要生成代码的表一键生成代码</li>
<li>将生成的main文件夹放到对应的微服务模块中</li>
<li>在main resources下有个src文件夹，里面是生成的前端代码，这里用不到将其删除</li>
<li>创建一个公共模块common，将每个微服务都需要的依赖写在里面</li>
<li>对于每个模块，都引入common依赖<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;com.xunqi.gulimall&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;gulimall-common&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li>2023-07-01 10:41:25</li>
</ul>
<h1 id="p18"><a href="#p18" class="headerlink" title="p18"></a>p18</h1><ul>
<li>商品服务CRUD测试</li>
<li>2023-07-01 11:22:48</li>
</ul>
<h1 id="p19"><a href="#p19" class="headerlink" title="p19"></a>p19</h1><ul>
<li>使用代码生成器为其他服务生成代码</li>
<li>2023-07-01 11:24:47</li>
</ul>
<h1 id="p20"><a href="#p20" class="headerlink" title="p20"></a>p20</h1><ul>
<li>分布式组件简介</li>
<li>SpringCloud Alibaba</li>
<li>2023-07-01 15:06:55</li>
</ul>
<h1 id="p21"><a href="#p21" class="headerlink" title="p21"></a>p21</h1><ul>
<li>使用nacos作为注册中心（先引入SpringCloud Alibaba依赖）</li>
<li>在application.properties中配置Nacos Server地址，以及项目的名字（application name，用来显示在nacos中）</li>
<li>下载Nacos服务器，运行目录下的bat启动Nacos</li>
<li>在SpringBoot主启动类上使用@EnableDiscoveryClient注解开启服务注册与发现功能</li>
<li>启动SpringBoot项目和Nacos后，在本地打开127.0.0.1:8848&#x2F;nacos 进入nacos可视化页面</li>
<li>默认账号nacos 默认密码nacos</li>
<li>nacos作为注册中心和配置中心</li>
<li>2023-07-01 15:19:10</li>
</ul>
<h1 id="p22"><a href="#p22" class="headerlink" title="p22"></a>p22</h1><ul>
<li>测试微服务之间的远程调用</li>
<li>引入open-feign相关依赖</li>
<li>编写接口，告诉SpringCloud该接口需要调用远程服务</li>
<li>使用@FeignClient(“远程服务名”)声明远程调用</li>
<li>声明接口的每一个方法是调用远程服务的哪个请求（使用@RequestMapping）</li>
<li>在主启动类添加@EnableFeignClients(basePackages&#x3D;”需要远程服务的接口的包名”)</li>
<li>2023-07-01 15:30:12</li>
</ul>
<h1 id="p23"><a href="#p23" class="headerlink" title="p23"></a>p23</h1><ul>
<li>使用Nacos作为配置中心</li>
<li>需要单独引入Nacos Config Starter依赖</li>
<li>创建固定配置文件bootstrap.properties，配置spring.application.name以及spring.cloud.nacos.config.server-addr&#x3D;ip地址:端口</li>
<li>原生在application.yml中读取配置，修改了配置需要重新部署项目 使用Nacos可解决该问题</li>
<li>在Nacos配置管理中添加配置文件</li>
<li>使用@Value(“${test.a}”)读取配置，使用@RefreshScope注解开启配置刷新</li>
<li>2023-07-01 15:53:21</li>
</ul>
<h1 id="p24"><a href="#p24" class="headerlink" title="p24"></a>p24</h1><ul>
<li>Nacos作为配置中心的其他细节</li>
<li>命名空间：用来配置隔离，默认命名空间为public（区分生产、测试、开发等不同环境中的配置）</li>
<li>配置集：所有配置的集合</li>
<li>配置集Id:类似于配置文件名</li>
<li>配置分组:默认所有的配置集都属于：DEFAULT_GROUP</li>
<li>2023-07-01 16:43:48</li>
</ul>
<h1 id="p25"><a href="#p25" class="headerlink" title="p25"></a>p25</h1><ul>
<li>从配置中心加载多个配置集<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.cloud.nacos.config.ext-config[0].data-id=datasource.yml 要加载的配置文件名为datasource.yml</span><br><span class="line">spring.cloud.nacos.config.ext-config[0].group=dev 要加载的配置文件所在的分组为dev</span><br><span class="line">spring.cloud.nacos.config.ext-config[0].refresh=true 开启自动刷新功能</span><br></pre></td></tr></table></figure></li>
<li>ext-config是Spring Cloud Nacos Config提供的一个扩展配置项，用于加载外部配置文件。[0]表示要加载的外部配置文件的索引，如果需要加载多个外部配置文件，可以在ext-config中添加多个配置项，并在data-id、group、refresh等属性中指定不同的值</li>
<li>2023-07-01 17:34:17</li>
</ul>
<h1 id="p26"><a href="#p26" class="headerlink" title="p26"></a>p26</h1><ul>
<li>GateWay网关的使用</li>
<li>2023-07-01 17:46:38</li>
</ul>
<h1 id="p27"><a href="#p27" class="headerlink" title="p27"></a>p27</h1><ul>
<li>GateWay网关具体使用步骤</li>
<li>创建API网关模块，创建主启动类，引入相关依赖</li>
<li>配置路由规则</li>
<li>2023-07-01 18:08:28</li>
</ul>
<h1 id="p28"><a href="#p28" class="headerlink" title="p28"></a>p28</h1><ul>
<li>前端基础</li>
<li>ES6新特性</li>
<li>Node.js包管理工具</li>
<li>Vue框架</li>
<li>Babel JavaScript 编译器</li>
<li>Webpack前端项目打包工具</li>
<li>2023-07-02 13:42:17</li>
</ul>
<h1 id="p29"><a href="#p29" class="headerlink" title="p29"></a>p29</h1><ul>
<li>ES6是js语言的标准</li>
<li>let声明变量有严格局部作用域</li>
<li>let不能多次声明同一个变量</li>
<li>var声明普通变量，const声明只读变量</li>
<li>解构表达式</li>
<li>数组解构 let [a,b,c] &#x3D;arr;从数组中取出下标0,1,2元素分别赋给a,b,c</li>
<li>对象解构 const {name,age,language} &#x3D;person;从person中取出属性值分别赋给前面声明的变量</li>
<li>2023-07-02 13:48:03</li>
</ul>
<h1 id="p30"><a href="#p30" class="headerlink" title="p30"></a>p30</h1><ul>
<li>字符串扩展，新增API</li>
<li>str.startsWith&#x2F;endsWith 判断字符串是否以某字符串开始&#x2F;结束</li>
<li>字符串模板:使用反引号<code>将字符串括起来，如</code>hello&#96;，可保留字符串格式（如空格 换行）</li>
<li>字符串模板中还可以插入变量和表达式，使用${}实现</li>
<li>2023-07-02 13:51:55</li>
</ul>
<h1 id="p31"><a href="#p31" class="headerlink" title="p31"></a>p31</h1><ul>
<li>ES6函数新特性</li>
<li>函数默认值：如果没传入b参数，b默认值为1<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function add(a,b=1)&#123;</span><br><span class="line">	return a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>函数不定参数<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function fun(...values)&#123;</span><br><span class="line">	console.log(values.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>箭头函数<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">单参数箭头函数</span><br><span class="line">var print_fun = obj =&gt;console.log(obj);</span><br><span class="line">print_fun(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">多参数箭头函数</span><br><span class="line">var get_sum = (a,b) =&gt; a+b;</span><br><span class="line">console.log(sum(a,b));</span><br><span class="line"></span><br><span class="line">多行箭头函数</span><br><span class="line">var get_sum2 = (a,b) =&gt;&#123;</span><br><span class="line">	c=a+b;</span><br><span class="line">	return a+c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>注意：箭头函数中this不能使用</li>
<li>2023-07-02 13:58:59</li>
</ul>
<h1 id="p32"><a href="#p32" class="headerlink" title="p32"></a>p32</h1><ul>
<li>对象优化</li>
<li>Object.keys(person) 获取对象的所有属性</li>
<li>Object.values(person) 获取对象的所有属性对应的值</li>
<li>Object.entries(person) 获取对象的所有属性以及对应的值</li>
<li>声明对象简写<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当属性名与属性值一样时，可缩写</span><br><span class="line">const age=23</span><br><span class="line">const name=&quot;zhangsan&quot;</span><br><span class="line">const person=&#123;age,name&#125;</span><br><span class="line">创建一个person对象，有age和name属性，age的值为age，name的值为name</span><br></pre></td></tr></table></figure></li>
<li>对象拓展运算符… 用于取出参数对象所有可遍历属性然后拷贝到当前对象(深拷贝)<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let person=&#123;name:&quot;Jack&quot;,age:15&#125;</span><br><span class="line">let someone=&#123;...person&#125;</span><br></pre></td></tr></table></figure></li>
<li>2023-07-02 14:06:16</li>
</ul>
<h1 id="p33"><a href="#p33" class="headerlink" title="p33"></a>p33</h1><ul>
<li>数组的map、reduce</li>
<li>map():接收一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr=[&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;]</span><br><span class="line">arr=arr.map(item=&gt;item*2)</span><br><span class="line"></span><br><span class="line">将数组所有元素乘2并返回</span><br></pre></td></tr></table></figure></li>
<li>reduce()为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let result=arr.reduce((a,b)=&gt;&#123;</span><br><span class="line">	console.log(&quot;上一次处理的值&quot;+a);</span><br><span class="line">	console.log(&quot;当前处理的值&quot;+b);</span><br><span class="line">	return a+b;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>2023-07-02 14:10:40</li>
</ul>
<h1 id="p34"><a href="#p34" class="headerlink" title="p34"></a>p34</h1><ul>
<li>promise异步编排</li>
<li>promise封装异步操作，实现链式操作<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let p=new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">	//异步操作</span><br><span class="line">	$.ajax(&#123;</span><br><span class="line">	url:&quot;test&quot;,</span><br><span class="line">	success:function(data)&#123;</span><br><span class="line">		resolve(data);</span><br><span class="line">	&#125;,</span><br><span class="line">	error:function(err)&#123;</span><br><span class="line">		reject(err);</span><br><span class="line">	&#125;</span><br><span class="line">	)&#125;;</span><br><span class="line">&#125;);</span><br><span class="line">p.then((obj)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;).catch((err)=&gt;&#123;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>2023-07-02 14:28:06</li>
</ul>
<h1 id="p35"><a href="#p35" class="headerlink" title="p35"></a>p35</h1><ul>
<li>模块化</li>
<li>export命令：用于规定模块的对外接口</li>
<li>import命令：用于导入其他模块提供的功能</li>
<li>2023-07-02 14:32:24</li>
</ul>
<h1 id="p36"><a href="#p36" class="headerlink" title="p36"></a>p36</h1><ul>
<li>Vue基础</li>
<li>MVVM思想：模型与视图间的双向操作</li>
<li>2023-07-02 15:22:33</li>
</ul>
<h1 id="p37"><a href="#p37" class="headerlink" title="p37"></a>p37</h1><ul>
<li>vue基本语法<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">声明式渲染vue实例</span><br><span class="line">let vm= new Vue(&#123;</span><br><span class="line">	el:&quot;#app&quot;,</span><br><span class="line">	data:&#123;</span><br><span class="line">		name:&quot;zhangsan&quot;,</span><br><span class="line">		age:18</span><br><span class="line">	&#125;,</span><br><span class="line">	methods:&#123;</span><br><span class="line">		fun()&#123;</span><br><span class="line">			this.age++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>2023-07-02 15:24:49</li>
</ul>
<h1 id="p38"><a href="#p38" class="headerlink" title="p38"></a>p38</h1><ul>
<li>单向绑定与双向绑定</li>
<li>2023-07-02 15:27:51</li>
</ul>
<h1 id="p39"><a href="#p39" class="headerlink" title="p39"></a>p39</h1><ul>
<li>vue指令</li>
<li>v-on</li>
<li>v-for</li>
<li>v-if</li>
<li>2023-07-02 15:28:54</li>
</ul>
<h1 id="p40"><a href="#p40" class="headerlink" title="p40"></a>p40</h1><ul>
<li>vue计算属性<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">使用函数动态计算</span><br><span class="line">computed:&#123;</span><br><span class="line">	fun()&#123;</span><br><span class="line">		return this.a+this.b</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;&#123;fun&#125;&#125;将fun函数的返回值显示到页面中</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用watch监听数据</span><br><span class="line">watch:&#123;</span><br><span class="line">	a(newVal,oldVal)&#123;</span><br><span class="line">		if(newVal&gt;3)</span><br><span class="line">			this.msg=&quot;超出限制&quot;;</span><br><span class="line">		else&#123;</span><br><span class="line">			this.meg=&quot;&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">监听器来检测a的值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">过滤器</span><br><span class="line">filters:&#123;</span><br><span class="line">	genderFilter(val)&#123;</span><br><span class="line">		if(val==1)</span><br><span class="line">			return &quot;男&quot;;</span><br><span class="line">		else return &quot;女&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">使用&#123;&#123;user.gender | genderFilter&#125;&#125;获取过滤器执行后的结果</span><br></pre></td></tr></table></figure></li>
<li>2023-07-02 15:35:18</li>
</ul>
<h1 id="p41"><a href="#p41" class="headerlink" title="p41"></a>p41</h1><ul>
<li>vue组件化</li>
<li>2023-07-02 15:36:02</li>
</ul>
<h1 id="p42"><a href="#p42" class="headerlink" title="p42"></a>p42</h1><ul>
<li>vue生命周期与钩子函数</li>
<li>2023-07-02 15:36:59</li>
</ul>
<h1 id="p43"><a href="#p43" class="headerlink" title="p43"></a>p43</h1><ul>
<li>vue脚手架的使用</li>
<li>2023-07-02 15:37:48</li>
</ul>
<h1 id="p44"><a href="#p44" class="headerlink" title="p44"></a>p44</h1><ul>
<li>vue整合element-ui</li>
<li>引入element-ui，可直接使用其提供的组件</li>
<li>2023-07-02 15:38:26</li>
</ul>
<h1 id="p45"><a href="#p45" class="headerlink" title="p45"></a>p45</h1><ul>
<li>商品三级分类</li>
<li>在Mybatis-plus中，xxServiceImpl已经继承了 ServiceImpl&lt;xxMapper,xxEntity&gt; 在实现类中可以直接调用baseMapper的方法，而这个baseMapper就是继承泛型中的xxMapper</li>
<li>先查询出所有分类，再使用stream()来筛选不同的分类</li>
<li>2023-07-03 10:58:19</li>
</ul>
<h1 id="p46"><a href="#p46" class="headerlink" title="p46"></a>p46</h1><ul>
<li>前端的后台的增删改查</li>
<li>使用vue的生命周期函数在页面激活后向后端接口发送请求</li>
<li>前端向网关发送请求，在网关模块的配置中设置转发规则</li>
<li>网关将请求进行负载均衡</li>
<li>2023-07-03 13:13:39</li>
</ul>
<h1 id="p47"><a href="#p47" class="headerlink" title="p47"></a>p47</h1><ul>
<li>跨域：浏览器不能执行其他网站的脚本。由浏览器的同源策略造成，是浏览器对js施加的安全限制</li>
<li>同源策略：协议、域名、端口其中一个不同就产生跨域</li>
<li>一种跨域问题解决方案：使用nginx部署为同一域</li>
<li>在网关模块中编写一个配置类，配置跨域：CorsWebFilter</li>
<li>2023-07-03 13:38:07</li>
</ul>
<h1 id="p48"><a href="#p48" class="headerlink" title="p48"></a>p48</h1><ul>
<li>在网关中配置路由，将所有与商品有关的请求转发到商品服务模块</li>
<li>使用element-ui的树形控件在前端的后台页面展示商品分类数据</li>
<li>2023-07-03 13:56:57</li>
</ul>
<h1 id="p49"><a href="#p49" class="headerlink" title="p49"></a>p49</h1><ul>
<li>页面的删除效果</li>
<li>调用element-ui提供的API来删除树形组件中的数据</li>
<li>实现节点的页面删除</li>
<li>2023-07-03 14:05:57</li>
</ul>
<h1 id="p50"><a href="#p50" class="headerlink" title="p50"></a>p50</h1><ul>
<li>分类数据的逻辑删除：在表中存在一个标记字段，表示是否被删除，数据并没有实际删除，只是逻辑上被删除</li>
<li>public R delete(@RequestBody Long[] catIds) &#x2F;&#x2F;@RequestBody获取请求体，因此前端必须发送post请求</li>
<li>删除前检查是否被其他地方引用</li>
<li>mybatis-plus也提供了逻辑删除的API</li>
<li>在application.yml中配置mybatis-plus的全局逻辑删除规则，值为多少时删除&#x2F;不删除</li>
<li>在实体类属性上添加@TableLogic注解，表示这个属性是逻辑删除字段</li>
<li>2023-07-03 14:16:11</li>
</ul>
<h1 id="p51"><a href="#p51" class="headerlink" title="p51"></a>p51</h1><ul>
<li>HttpRequest.js封装了全局的功能，如登录判断，为所有请求添加token等</li>
<li>优化前端代码，完善删除的细节</li>
<li>2023-07-03 14:44:31</li>
</ul>
<h1 id="p52"><a href="#p52" class="headerlink" title="p52"></a>p52</h1><ul>
<li>新增元素以及测试</li>
<li>2023-07-03 15:38:49</li>
</ul>
<h1 id="p53"><a href="#p53" class="headerlink" title="p53"></a>p53</h1><ul>
<li>修改元素&#x2F;弹窗实现（弹窗中回显要修改的数据）</li>
<li>2023-07-04 11:05:34</li>
</ul>
<h1 id="p54"><a href="#p54" class="headerlink" title="p54"></a>p54</h1><ul>
<li>拖拽的页面效果</li>
<li>通过element-ui的拖拽来更改显示的顺序</li>
<li>2023-07-04 11:18:51</li>
</ul>
<h1 id="p55"><a href="#p55" class="headerlink" title="p55"></a>p55</h1><ul>
<li>拖拽的逻辑实现（前端代码）</li>
<li>2023-07-04 15:12:05</li>
</ul>
<h1 id="p56"><a href="#p56" class="headerlink" title="p56"></a>p56</h1><ul>
<li>拖拽功能的后端更新接口</li>
<li>2023-07-04 15:16:21</li>
</ul>
<h1 id="p57"><a href="#p57" class="headerlink" title="p57"></a>p57</h1><ul>
<li>优化拖拽功能</li>
<li>可开启&#x2F;关闭拖拽功能</li>
<li>2023-07-04 15:17:11</li>
</ul>
<h1 id="p58"><a href="#p58" class="headerlink" title="p58"></a>p58</h1><ul>
<li>删除元素&#x2F;批量删除</li>
<li>2023-07-04 15:20:10</li>
</ul>
<h1 id="p59"><a href="#p59" class="headerlink" title="p59"></a>p59</h1><ul>
<li>品牌管理功能</li>
<li>在人人开源的后台页面中新增菜单，再把逆向生成的vue文件导入到项目中</li>
<li>设置权限后，菜单页将显示可以增删改查，进行页面测试</li>
<li>2023-07-04 15:23:57</li>
</ul>
<h1 id="p60"><a href="#p60" class="headerlink" title="p60"></a>p60</h1><ul>
<li>使用element-ui的Table表格实现自定义显示</li>
<li>2023-07-04 17:12:32</li>
</ul>
<h1 id="p61"><a href="#p61" class="headerlink" title="p61"></a>p61</h1><ul>
<li>云存储</li>
<li>阿里云oss对象存储服务</li>
<li>前端把要上传的图片先给后端进行签名，得到了后端的签名后再上传到阿里云服务器</li>
<li>2023-07-04 18:33:46</li>
</ul>
<h1 id="p62"><a href="#p62" class="headerlink" title="p62"></a>p62</h1><ul>
<li>OSS存储服务测试文件上传</li>
<li>注册阿里云的子账户，在pom.xml中导入相关依赖包</li>
<li>2023-07-04 18:52:47</li>
</ul>
<h1 id="p63"><a href="#p63" class="headerlink" title="p63"></a>p63</h1><ul>
<li>文件给后端签名后直传</li>
<li>2023-07-04 18:54:24</li>
</ul>
<h1 id="p64"><a href="#p64" class="headerlink" title="p64"></a>p64</h1><ul>
<li>前后端联调完成文件上传</li>
<li>前端使用element-ui的el-uoload组件进行文件上传</li>
<li>2023-07-04 21:13:45</li>
</ul>
<h1 id="p65"><a href="#p65" class="headerlink" title="p65"></a>p65</h1><ul>
<li>品牌管理的前端表单校验</li>
<li>使用正则表达式辅助校验</li>
<li>2023-07-04 22:51:04</li>
</ul>
<h1 id="p66"><a href="#p66" class="headerlink" title="p66"></a>p66</h1><ul>
<li>品牌管理的后端JSR303校验</li>
<li>为Bean添加校验注解 在前端传来数据的时候标注@Valid 表明该字段需要校验</li>
<li>如：public R save(@Valid @RequestBody BrandEntity brand)</li>
<li>校验注解参考：javax.validation.constraints</li>
<li>2023-07-04 23:15:09</li>
</ul>
<h1 id="p67"><a href="#p67" class="headerlink" title="p67"></a>p67</h1><ul>
<li>统一异常处理</li>
<li>使用SpringMVC提供的@ControllerAdvice注解</li>
<li>basePackages属性来指定集中处理软件包下的所有异常</li>
<li>public R handleValidException(Exception e);</li>
<li>可通过e.getMessage(),e.getClass()获取异常的相关信息</li>
<li>在代码编写过程中可以抛出异常，再定义全局异常处理器</li>
<li>定义错误状态码（枚举类）来区分不同异常</li>
<li>2023-07-05 19:29:39</li>
</ul>
<h1 id="p68"><a href="#p68" class="headerlink" title="p68"></a>p68</h1><ul>
<li>分组校验</li>
<li>使用不同注解来区分校验的情景</li>
<li>在postman中测试发送错误的参数格式得到的响应</li>
<li>2023-07-05 19:37:30</li>
</ul>
<h1 id="p69"><a href="#p69" class="headerlink" title="p69"></a>p69</h1><ul>
<li>自定义校验</li>
<li>编写一个自定义的校验注解</li>
<li>@Target和@Retention注解定义自定义注解的使用范围和生命周期</li>
<li>实现javax.validation.ConstraintValidator接口创建自定义验证器</li>
<li>2023-07-05 20:09:43</li>
</ul>
<h1 id="p70"><a href="#p70" class="headerlink" title="p70"></a>p70</h1><ul>
<li>SPU标准化产品单元与SKU库存量单位</li>
<li>2023-07-05 20:13:04</li>
</ul>
<h1 id="p71"><a href="#p71" class="headerlink" title="p71"></a>p71</h1><ul>
<li>属性分组的前端管理页面创建</li>
<li>2023-07-05 20:16:15</li>
</ul>
<h1 id="p72"><a href="#p72" class="headerlink" title="p72"></a>p72</h1><ul>
<li>获取所有属性分组</li>
<li>2023-07-05 20:18:48</li>
</ul>
<h1 id="p73"><a href="#p73" class="headerlink" title="p73"></a>p73</h1><ul>
<li>新增分组功能</li>
<li>使用element-ui的级联选择器</li>
<li>2023-07-05 20:20:53</li>
</ul>
<h1 id="p74"><a href="#p74" class="headerlink" title="p74"></a>p74</h1><ul>
<li>分组修改功能</li>
<li>2023-07-05 20:21:51</li>
</ul>
<h1 id="p75"><a href="#p75" class="headerlink" title="p75"></a>p75</h1><ul>
<li>品牌关联分类</li>
<li>2023-07-05 20:22:29</li>
</ul>
<h1 id="p76"><a href="#p76" class="headerlink" title="p76"></a>p76</h1><ul>
<li>新增规格参数</li>
<li>2023-07-05 20:23:40</li>
</ul>
<h1 id="p77"><a href="#p77" class="headerlink" title="p77"></a>p77</h1><ul>
<li>查询规格参数列表</li>
<li>2023-07-06 16:30:06</li>
</ul>
<h1 id="p78"><a href="#p78" class="headerlink" title="p78"></a>p78</h1><ul>
<li>属性修改功能</li>
<li>2023-07-06 16:31:46</li>
</ul>
<h1 id="p79"><a href="#p79" class="headerlink" title="p79"></a>p79</h1><ul>
<li>销售属性维护</li>
<li>2023-07-06 16:32:29</li>
</ul>
<h1 id="p80"><a href="#p80" class="headerlink" title="p80"></a>p80</h1><ul>
<li>分组与属性关联</li>
<li>2023-07-06 16:41:41</li>
</ul>
<h1 id="p81"><a href="#p81" class="headerlink" title="p81"></a>p81</h1><ul>
<li>分组查询</li>
<li>2023-07-06 16:52:18</li>
</ul>
<h1 id="p82"><a href="#p82" class="headerlink" title="p82"></a>p82</h1><ul>
<li>新增分组功能</li>
<li>2023年7月6日 17:41:55</li>
</ul>
<h1 id="p83"><a href="#p83" class="headerlink" title="p83"></a>p83</h1><ul>
<li>新增商品介绍</li>
<li>2023-07-06 17:45:57</li>
</ul>
<h1 id="p84"><a href="#p84" class="headerlink" title="p84"></a>p84</h1><ul>
<li>获取分类</li>
<li>2023-07-06 20:31:30</li>
</ul>
<h1 id="p85"><a href="#p85" class="headerlink" title="p85"></a>p85</h1><ul>
<li>获取分类</li>
<li>2023-07-06 20:32:00</li>
</ul>
<h1 id="p86"><a href="#p86" class="headerlink" title="p86"></a>p86</h1><ul>
<li>数据测试</li>
<li>2023-07-06 20:32:18</li>
</ul>
<h1 id="p87"><a href="#p87" class="headerlink" title="p87"></a>p87</h1><ul>
<li>保存功能</li>
<li>2023-07-06 20:53:00</li>
</ul>
<h1 id="p88"><a href="#p88" class="headerlink" title="p88"></a>p88</h1><ul>
<li>为保存的实体增加基本信息</li>
<li>2023-07-08 13:34:08</li>
</ul>
<h1 id="p89"><a href="#p89" class="headerlink" title="p89"></a>p89</h1><ul>
<li>为保存关联实体增加基本信息</li>
<li>2023-07-08 13:36:52</li>
</ul>
<h1 id="p90"><a href="#p90" class="headerlink" title="p90"></a>p90</h1><ul>
<li>调用远程服务来保存相关信息</li>
<li>通过本地Service进行远程调用时，形参为@RequestBody 实体，springboot会先将实体转成json再发送请求给远程服务</li>
<li>因此远程服务中形参@RequestBody 实体可以与本地Service的形参是不一样的类，只要属性相同就能完成json到实体的转换</li>
<li>2023-07-08 13:45:36</li>
</ul>
<h1 id="p91"><a href="#p91" class="headerlink" title="p91"></a>p91</h1><ul>
<li>服务测试</li>
<li>2023-07-08 13:48:15</li>
</ul>
<h1 id="p92"><a href="#p92" class="headerlink" title="p92"></a>p92</h1><ul>
<li>商品保存的其他细节</li>
<li>2023-07-08 13:49:08</li>
</ul>
<h1 id="p93"><a href="#p93" class="headerlink" title="p93"></a>p93</h1><ul>
<li>SPU检索</li>
<li>多个条件检索信息</li>
<li>2023-07-08 13:49:51</li>
</ul>
<h1 id="p94"><a href="#p94" class="headerlink" title="p94"></a>p94</h1><ul>
<li>SKU检索</li>
<li>多个条件检索信息</li>
<li>2023-07-08 13:50:17</li>
</ul>
<h1 id="p95"><a href="#p95" class="headerlink" title="p95"></a>p95</h1><ul>
<li>仓库检索功能</li>
<li>2023-07-08 13:53:58</li>
</ul>
<h1 id="p96"><a href="#p96" class="headerlink" title="p96"></a>p96</h1><ul>
<li>仓库库存检索</li>
<li>2023-07-08 13:54:20</li>
</ul>
<h1 id="p97"><a href="#p97" class="headerlink" title="p97"></a>p97</h1><ul>
<li>合并采购需求<br>*2023-07-08 13:56:51</li>
</ul>
<h1 id="p98"><a href="#p98" class="headerlink" title="p98"></a>p98</h1><ul>
<li>领取采购单</li>
<li>2023-07-08 14:01:12</li>
</ul>
<h1 id="p99"><a href="#p99" class="headerlink" title="p99"></a>p99</h1><ul>
<li>完成采购</li>
<li>2023-07-08 14:02:37</li>
</ul>
<h1 id="p100"><a href="#p100" class="headerlink" title="p100"></a>p100</h1><ul>
<li>SPU规格管理</li>
<li>2023-07-08 14:03:10</li>
</ul>
<h1 id="p101"><a href="#p101" class="headerlink" title="p101"></a>p101</h1><ul>
<li>分布式基础篇总结</li>
<li>2023-07-08 14:03:51</li>
</ul>
<h1 id="p102"><a href="#p102" class="headerlink" title="p102"></a>p102</h1><ul>
<li>ElasticSearch  </li>
<li>存储json格式的文档</li>
<li>2023-07-08 20:38:01</li>
</ul>
<h1 id="p103"><a href="#p103" class="headerlink" title="p103"></a>p103</h1><ul>
<li>在Docker中安装ElasticSearch：存储和检索数据</li>
<li>安装kibana：可视化检索数据</li>
<li>2023-07-08 20:39:58</li>
</ul>
<h1 id="p104"><a href="#p104" class="headerlink" title="p104"></a>p104</h1><ul>
<li>使用Postman向ElasticSearch发送请求</li>
<li>2023-07-08 21:32:19</li>
</ul>
<h1 id="p105"><a href="#p105" class="headerlink" title="p105"></a>p105</h1><ul>
<li>查看主节点信息 get请求：<a target="_blank" rel="noopener" href="http://localhost:9200/_cat/master">http://localhost:9200/_cat/master</a></li>
<li>测试一些增删改查 </li>
<li>2023-07-08 21:52:21</li>
</ul>
<h1 id="p106"><a href="#p106" class="headerlink" title="p106"></a>p106</h1><ul>
<li>带序列号的修改：先判断序列号，再修改。序列号在修改后会递增，因此避免并发操作导致修改出现问题</li>
<li>2023-07-08 21:57:11</li>
</ul>
<h1 id="p107"><a href="#p107" class="headerlink" title="p107"></a>p107</h1><ul>
<li>更新文档</li>
<li>发送post请求	</li>
<li>put和post，不带_update时都会直接更新数据带update的更新，当更新后的内容与原来数据一模一样，序列号将不会更新</li>
<li>带update的更新，当更新后的内容与原来数据一模一样，不进行任何操作，序列号也不会更新</li>
<li>2023-07-08 22:02:36</li>
</ul>
<h1 id="p108"><a href="#p108" class="headerlink" title="p108"></a>p108</h1><ul>
<li>删除文档&#x2F;索引</li>
<li>发送delete请求用来删除</li>
<li>2023-07-08 22:07:42</li>
</ul>
<h1 id="p109"><a href="#p109" class="headerlink" title="p109"></a>p109</h1><ul>
<li>批量更新</li>
<li>2023-07-10 12:01:50</li>
</ul>
<h1 id="p110-p127"><a href="#p110-p127" class="headerlink" title="p110-p127"></a>p110-p127</h1><ul>
<li>ES的两种基本检索方式</li>
<li>1.通过REST request URI 发送搜索参数</li>
<li>2.通过 REST request body 发送搜索参数 </li>
<li>match匹配查询 </li>
<li>2023-07-10 12:18:35</li>
</ul>
<h1 id="p128"><a href="#p128" class="headerlink" title="p128"></a>p128</h1><ul>
<li>ES是基于内存的，性能比mysql高</li>
<li>因为基于内存，所以需要集群，一个肯定不够用</li>
<li>向ES中保存数据时，应尽可能节约内存，去除冗余信息</li>
<li>2023-07-16 08:45:16</li>
</ul>
<h1 id="p129"><a href="#p129" class="headerlink" title="p129"></a>p129</h1><ul>
<li>向ES中存入数组数据时，数组会被扁平化处理</li>
<li>检索的类型为nested嵌入式类型时，不会受扁平化影响</li>
<li>2023-07-16 08:48:56</li>
</ul>
<h1 id="p130-p135"><a href="#p130-p135" class="headerlink" title="p130-p135"></a>p130-p135</h1><ul>
<li>完成商品上架功能</li>
<li>构造商品信息的数据，存入ES（编写java实体类来封装）</li>
<li>构造sku检索属性 </li>
<li>商品上架前，远程调用查询是否有库存</li>
<li>2023-07-16 09:42:45</li>
</ul>
<h1 id="p136"><a href="#p136" class="headerlink" title="p136"></a>p136</h1><ul>
<li>用户访问nginx nginx转发到网关，网关再转发给各个服务模块</li>
<li>动静分离</li>
<li>静：图片 js css </li>
<li>动：请求</li>
<li>使用thymeleaf模板引擎渲染页面</li>
<li>2023-07-16 10:04:33</li>
</ul>
<h1 id="p137"><a href="#p137" class="headerlink" title="p137"></a>p137</h1><ul>
<li>视图解析器配置访问”&#x2F;“转发到”&#x2F;index.html”</li>
<li>使用dev-tools渲染</li>
<li>2023-07-16 10:12:32</li>
</ul>
<h1 id="p138"><a href="#p138" class="headerlink" title="p138"></a>p138</h1><ul>
<li>渲染多级分类</li>
<li>2023-07-16 15:51:27</li>
</ul>
<h1 id="p139-p140"><a href="#p139-p140" class="headerlink" title="p139-p140"></a>p139-p140</h1><ul>
<li>使用nginx搭建域名访问环境</li>
<li>2023-07-16 16:06:48</li>
</ul>
<h1 id="p141"><a href="#p141" class="headerlink" title="p141"></a>p141</h1><ul>
<li>压力测试</li>
<li>JMeter软件可以进行压力测试</li>
<li>2023-07-16 16:12:04</li>
</ul>
<h1 id="p142-p150"><a href="#p142-p150" class="headerlink" title="p142-p150"></a>p142-p150</h1><ul>
<li>性能压力测试</li>
<li>监控jvm</li>
<li>优化业务逻辑</li>
<li>2023-07-16 16:57:15</li>
</ul>
<h1 id="p151"><a href="#p151" class="headerlink" title="p151"></a>p151</h1><ul>
<li>缓存与分布式锁</li>
<li>适合存入缓存的数据：即时性、数据一致性要求不高的数据以及访问量大更新频率不高的数据</li>
<li>2023-07-17 11:53:09</li>
</ul>
<h1 id="p152-p166"><a href="#p152-p166" class="headerlink" title="p152-p166"></a>p152-p166</h1><ul>
<li>使用Redis作为缓存</li>
<li>给缓存中存入json字符串，取出时需要还原为对象类型</li>
<li>使用阿里巴巴提供的fastjson</li>
<li>在本地加锁时会导致分布式不同机器上有不同的锁，因此需要引入分布式锁</li>
<li>可以用redis实现分布式锁</li>
<li>使用Redisson实现分布式锁</li>
<li>2023-07-17 15:27:39</li>
</ul>
<h1 id="p167-p172"><a href="#p167-p172" class="headerlink" title="p167-p172"></a>p167-p172</h1><ul>
<li>使用SpringCache</li>
<li>SpringCache可以使用注解快速完成缓存功能（对缓存的增删改查）</li>
<li>CacheManager接口有多种实现，用来处理不同类型的缓存</li>
<li>1.引入SpringCache依赖，redis依赖</li>
<li>2.写配置（缓存管理器已自动配置）只需指定使用redis缓存：spring.cache.type&#x3D;redis</li>
<li>3.使用缓存<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Cacheable 触发将数据保存到缓存</span><br><span class="line">@CacheEvict 触发将数据从缓存中删除</span><br><span class="line">@CachePut 不影响方法执行更新缓存</span><br><span class="line">@Caching 组合以上三个注解的操作</span><br><span class="line">@CacheConfig 在类级别上共享缓存的相同配置</span><br></pre></td></tr></table></figure></li>
<li>若缓存中有，方法不会调用，直接从缓存中取出数据</li>
<li>缓存的key默认自动生成，使用jdk序列化机制，将序列化后的数据存入redis</li>
<li>2023-07-18 12:41:26</li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-Java基础知识" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2023-06-28T04:22:43.000Z"><a href="/2023/06/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">2023-06-28</a></time>
      
      
  
    <h1 class="title"><a href="/2023/06/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">Java基础知识</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="https://www.pdai.tech/">https://www.pdai.tech/</a></p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>java中的八个基本类型和大小（单位：比特）</p>
<ul>
<li>boolean&#x2F;1</li>
<li>byte&#x2F;8</li>
<li>char&#x2F;16</li>
<li>short&#x2F;16</li>
<li>int&#x2F;32</li>
<li>float&#x2F;32</li>
<li>long&#x2F;64</li>
<li>double&#x2F;64</li>
</ul>
<p>基本类型有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p>
<h3 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h3><p>new Integer(123) 与 Integer.valueOf(123) 的区别：</p>
<ul>
<li>new Integer(123) 每次都会新建一个对象</li>
<li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用</li>
</ul>
<p>valueOf会先判断值是否在缓存池中，如果存在直接返回缓存池中的内容</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h6 id="String不可变"><a href="#String不可变" class="headerlink" title="String不可变"></a>String不可变</h6><ul>
<li>String声明为final类，无法被继承</li>
<li>String内部使用final修饰的char数组存储数据，意味着该数组初始化后不能再引用其他数组。并且String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</li>
</ul>
<h6 id="不可变的好处"><a href="#不可变的好处" class="headerlink" title="不可变的好处"></a>不可变的好处</h6><ul>
<li>可以缓存 hash 值：String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</li>
<li>String Pool 的需要：如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</li>
<li>安全性：String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。</li>
<li>线程安全：String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</li>
</ul>
<h3 id="String-StringBuffer-和-StringBuilder-的区别"><a href="#String-StringBuffer-和-StringBuilder-的区别" class="headerlink" title="String, StringBuffer 和 StringBuilder 的区别"></a>String, StringBuffer 和 StringBuilder 的区别</h3><ul>
<li>可变性：String 不可变，StringBuffer 和 StringBuilder 可变</li>
<li>线程安全：String 不可变，因此是线程安全的，StringBuilder 不是线程安全的，StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li>
</ul>
<h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><ul>
<li>参数传递：Java 的参数是以值传递的形式传入方法中，而不是引用传递。</li>
<li>float 与 double：1.1字面量属于double类型，不能直接float f&#x3D;1.1，需要float f&#x3D;1.1f。Java不能隐式执行向下转型，因为这会使得精度降低</li>
<li>隐式类型转换：字面量1是int类型，它比short类型精度要高，因此不能隐式地将 int 类型下转型为 short 类型。但是使用 +&#x3D; 运算符可以执行隐式类型转换，s1+&#x3D;1等价于s1&#x3D;(short)(s1+1)</li>
<li>switch：switch 不支持 long，是因为 switch 的设计初衷是对那些只有少数的几个值进行等值判断，如果值过于复杂，那么还是用 if 比较合适</li>
</ul>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>如果没有泛型，要实现不同类型的加法，每种类型都需要重载一个add方法，通过泛型可复用为一个方法：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static &lt;T extends Number&gt; double add(T a, T b) &#123;</span><br><span class="line">    System.out.println(a + &quot;+&quot; + b + &quot;=&quot; + (a.doubleValue() + b.doubleValue()));</span><br><span class="line">    return a.doubleValue() + b.doubleValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型类</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//创建一个使用了泛型的实例：Data&lt;String&gt; data=new Data();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Data&lt;T&gt;&#123;  //声明该类存在泛型T，T可以用其他任何合法标识符或字母指定，如Type等</span><br><span class="line">	private T val;</span><br><span class="line">	public T getVal() &#123; //返回泛型T，T的具体类型由外部决定</span><br><span class="line">		return val;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setVal(T val) &#123;</span><br><span class="line">		this.val=val;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//多元泛型</span><br><span class="line"></span><br><span class="line">class Notepad&lt;K,V&gt;&#123;       // 此处指定了两个泛型类型  </span><br><span class="line">    private K key ;     // 此变量的类型由外部决定  </span><br><span class="line">    private V value ;   // 此变量的类型由外部决定  </span><br><span class="line">    public K getKey()&#123;  </span><br><span class="line">        return this.key ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public V getValue()&#123;  </span><br><span class="line">        return this.value ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public void setKey(K key)&#123;  </span><br><span class="line">        this.key = key ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public void setValue(V value)&#123;  </span><br><span class="line">        this.value = value ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>泛型接口</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">//通过子类实例化对象i = new InfoImpl&lt;String&gt;(&quot;tom&quot;) ;</span><br><span class="line"></span><br><span class="line">interface Info&lt;T&gt;&#123;        // 在接口上定义泛型  </span><br><span class="line">    public T getVar() ; // 定义抽象方法，抽象方法的返回值就是泛型类型  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">class InfoImpl&lt;T&gt; implements Info&lt;T&gt;&#123;   // 定义泛型接口的子类  </span><br><span class="line">    private T var ;             // 定义属性  </span><br><span class="line">    public InfoImpl(T var)&#123;     // 通过构造方法设置属性内容  </span><br><span class="line">        this.setVar(var) ;    </span><br><span class="line">    &#125;  </span><br><span class="line">    public void setVar(T var)&#123;  </span><br><span class="line">        this.var = var ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public T getVar()&#123;  </span><br><span class="line">        return this.var ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>泛型方法</p>
<p>定义泛型方法时，必须在返回值前边加一个<T>，来声明这是一个泛型方法，持有一个泛型T</p>
<p>例如：public <T> void methodName(T parameter)</p>
<p>泛型数组</p>
<p>List<?>[] list = new ArrayList<?>[10]; &#x2F;&#x2F;这里?是通配符，不能修改为其他符号</p>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>作用有以下四方面</p>
<ul>
<li>生成文档，通过代码里标识的元数据生成javadoc文档。</li>
<li>编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。</li>
<li>编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。</li>
<li>运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。</li>
</ul>
<p>注解分类</p>
<ul>
<li>Java自带的标准注解，包括@Override、@Deprecated和@SuppressWarnings，分别用于标明重写某个方法、标明某个类或方法过时、标明要忽略的警告，用这些注解标明后编译器就会进行检查。</li>
<li>元注解，元注解是用于定义注解的注解，包括@Retention、@Target、@Inherited、@Documented，@Retention用于标明注解被保留的阶段，@Target用于标明注解使用的范围，@Inherited用于标明注解可继承，@Documented用于标明是否生成javadoc文档。</li>
<li>自定义注解，可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。</li>
</ul>
<p>内置注解 - @Override</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.METHOD) //用来修饰方法</span><br><span class="line">@Retention(RetentionPolicy.SOURCE) //源码级别保留 只在编译时有效，在编译后的class文件中便不再存在</span><br><span class="line">public @interface Override &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//作用：告诉编译器被修饰的方法是重写的父类的中的相同签名的方法，编译器会对此做出检查，若发现父类中不存在这个方法或是存在的方法签名不同，则会报错</span><br></pre></td></tr></table></figure>

<p>内置注解 - @Deprecated</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Documented //生成javadoc文档</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME) //运行时保留</span><br><span class="line">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;) //能够修饰构造方法、属性、局部变量、方法、包、参数、类型</span><br><span class="line">public @interface Deprecated &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//作用：告诉编译器被修饰的程序元素已被“废弃”，不再建议用户使用</span><br></pre></td></tr></table></figure>

<p>内置注解 - @SuppressWarnings</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;) // 能够修饰的程序元素包括类型、属性、方法、参数、构造器、局部变量</span><br><span class="line">@Retention(RetentionPolicy.SOURCE) //源码级别保留</span><br><span class="line">public @interface SuppressWarnings &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//作用：编译器忽略指定的警告信息，指定的信息由String[] 内容决定</span><br></pre></td></tr></table></figure>


<p>元注解 - @Target</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">描述注解的使用范围（即：被修饰的注解可以用在什么地方）</span><br><span class="line">取值范围定义在ElementType 枚举</span><br><span class="line"></span><br><span class="line">public enum ElementType &#123;</span><br><span class="line"> </span><br><span class="line">    TYPE, // 类、接口、枚举类</span><br><span class="line"> </span><br><span class="line">    FIELD, // 成员变量（包括：枚举常量）</span><br><span class="line"> </span><br><span class="line">    METHOD, // 成员方法</span><br><span class="line"> </span><br><span class="line">    PARAMETER, // 方法参数</span><br><span class="line"> </span><br><span class="line">    CONSTRUCTOR, // 构造方法</span><br><span class="line"> </span><br><span class="line">    LOCAL_VARIABLE, // 局部变量</span><br><span class="line"> </span><br><span class="line">    ANNOTATION_TYPE, // 注解类</span><br><span class="line"> </span><br><span class="line">    PACKAGE, // 可用于修饰：包</span><br><span class="line"> </span><br><span class="line">    TYPE_PARAMETER, // 类型参数，JDK 1.8 新增</span><br><span class="line"> </span><br><span class="line">    TYPE_USE // 使用类型的任何地方，JDK 1.8 新增</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>元注解 - @Retention &amp; @RetentionTarget</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">描述注解保留的时间范围（即：被描述的注解在它所修饰的类中可以被保留到何时）</span><br><span class="line">取值范围定义在RetentionPolicy枚举中</span><br><span class="line"></span><br><span class="line">public enum RetentionPolicy &#123;</span><br><span class="line"> </span><br><span class="line">    SOURCE,    // 源文件保留</span><br><span class="line">    CLASS,       // 编译期保留，默认值</span><br><span class="line">    RUNTIME   // 运行期保留，可通过反射去获取注解信息</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>元注解 - @Documented</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">描述在使用 javadoc 工具为类生成帮助文档时是否要保留其注解信息。</span><br></pre></td></tr></table></figure>

<p>元注解 - @Inherited</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">被它修饰的Annotation将具有继承性。如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解。</span><br></pre></td></tr></table></figure>

<p>元注解 - @Repeatable (Java8)</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用于标记某个注解可以在同一个元素上重复应用多次。在使用@Repeatable注解后，可以简化对同一元素多次应用同一个注解的语法。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>元注解 - @Native (Java8)</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用 @Native 注解修饰成员变量，则表示这个变量可以被本地代码引用，常常被代码生成工具使用</span><br><span class="line">当一个方法或代码被标记为@Native时，它的实现将由底层的本地语言（如C、C++）提供</span><br></pre></td></tr></table></figure>

<p>注解与反射接口</p>
<p>定义注解后，如何获取注解中的内容呢？反射包java.lang.reflect下的AnnotatedElement接口提供这些方法</p>
<p>AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的方法来访问Annotation信息</p>
<ul>
<li>boolean isAnnotationPresent(Class&lt;?extends Annotation&gt; annotationClass) 判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false</li>
<li><T extends Annotation> T getAnnotation(Class<T> annotationClass) 返回该程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。</li>
<li>Annotation[] getAnnotations() 返回该程序元素上存在的所有注解，若没有注解，返回长度为0的数组。</li>
<li><T extends Annotation> T[] getAnnotationsByType(Class<T> annotationClass) 返回一个指定类型的注解数组，包含指定元素上的所有匹配注解对象。</li>
<li><T extends Annotation> T getDeclaredAnnotation(Class<T> annotationClass) 返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注释。如果没有注释直接存在于此元素上，则返回null</li>
<li>Annotation[] getDeclaredAnnotations() 返回直接存在于此元素上的所有注解及注解对应的重复注解容器。与此接口中的其他方法不同，该方法将忽略继承的注解。如果没有注释直接存在于此元素上，则返回长度为零的一个数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。</li>
</ul>
<h3 id="异常机制"><a href="#异常机制" class="headerlink" title="异常机制"></a>异常机制</h3><p>Throwable</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Throwable 是 Java 语言中所有错误与异常的超类。Throwable 包含两个子类：Error（错误）和 Exception（异常），它们通常用于指示发生了异常情况。Throwable 包含了其线程创建时线程执行堆栈的快照，它提供了 printStackTrace() 等接口用于获取堆栈跟踪数据等信息。</span><br></pre></td></tr></table></figure>
<p>Error（错误）</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error 类及其子类：程序中无法处理的错误，表示运行应用程序中出现了严重的错误。此类错误一般表示代码运行时 JVM 出现问题。通常有 Virtual MachineError（虚拟机运行错误）、NoClassDefFoundError（类定义错误）等。比如 OutOfMemoryError：内存不足错误；StackOverflowError：栈溢出错误。此类错误发生时，JVM 将终止线程。这些错误是不受检异常，非代码性错误。因此，当此类错误发生时，应用程序不应该去处理此类错误。按照Java惯例，我们是不应该实现任何新的Error子类的！</span><br></pre></td></tr></table></figure>
<p>Exception（异常）</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常。</span><br><span class="line"></span><br><span class="line">运行时异常都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。</span><br><span class="line"></span><br><span class="line">非运行时异常 （编译异常）是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</span><br></pre></td></tr></table></figure>
<p>可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可查异常（编译器要求必须处置的异常）：正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</span><br><span class="line"></span><br><span class="line">不可查异常(编译器不要求强制处置的异常)包括运行时异常（RuntimeException与其子类）和错误（Error）</span><br></pre></td></tr></table></figure>

<p>异常关键字</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try – 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。</span><br><span class="line">catch – 用于捕获异常。catch用来捕获try语句块中发生的异常。</span><br><span class="line">finally – finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。</span><br><span class="line">throw – 用于抛出异常。throws – 用在方法签名中，用于声明该方法可能抛出的异常。</span><br></pre></td></tr></table></figure>

<h3 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h3><p>反射的作用：通过反射，可获取Class类对象以及类中的成员变量、方法、构造方法等</p>
<p>Class类对象的获取：在类加载的时候，jvm会创建一个class对象，class对象是可以说是反射中最常用的，获取class对象的方式的主要有三种：</p>
<ul>
<li>根据类名获取 User.class</li>
<li>根据对象获取 user.getClass()</li>
<li>根据全限定类名获取 Class.forName(“com.test.User”)</li>
</ul>
<p>Class类的方法</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">forName() 获取Class对象的一个引用，如果类还没被加载就需要加载。该方法一般用来加载这个类</span><br><span class="line">getClass() 获取Class对象的一个引用，返回表示该对象的实际类型的Class引用</span><br><span class="line">getName() 取全限定的类名(包括包名)，即类的完整名字</span><br><span class="line">getSimpleName() 获取类名(不包括包名)</span><br><span class="line">getCanonicalName() 获取全限定的类名(包括包名)</span><br><span class="line">isInterface() 判断Class对象是否是表示一个接口</span><br><span class="line">getInterfaces() 返回Class对象数组，表示Class对象所引用的类所实现的所有接口。</span><br><span class="line">getSuperclass() 返回Class对象，表示Class对象所引用的类所继承的直接基类。应用该方法可在运行时发现一个对象完整的继承结构</span><br><span class="line">newInstance() 返回一个Oject对象，是实现“虚拟构造器”的一种途径。使用该方法创建的类，必须带有无参的构造器</span><br><span class="line">getFields() 获得某个类的所有的公共（public）的字段，包括继承自父类的所有公共字段。 类似的还有getMethods和getConstructors</span><br><span class="line">getDeclaredFields 获得某个类的自己声明的字段，即包括public、private和proteced，默认但是不包括父类声明的任何字段。类似的还有getDeclaredMethods和getDeclaredConstructors</span><br></pre></td></tr></table></figure>
<p>Constructor类：Constructor对象是通过Class类中的方法获取的</p>
<p>Field类：提供有关类或接口的单个字段的信息，以及对它的动态访问权限</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set(Object obj, Object value) 将指定对象变量上此 Field 对象表示的字段设置为指定的新值</span><br><span class="line">get(Object obj) 返回指定对象上此 Field 表示的字段的值</span><br><span class="line">getType() 返回一个 Class 对象，它标识了此Field 对象所表示字段的声明类型</span><br><span class="line">isEnumConstant() 如果此字段表示枚举类型的元素则返回 true；否则返回 false</span><br><span class="line">toGenericString() 返回一个描述此 Field（包括其一般类型）的字符串</span><br><span class="line">getName() 返回此 Field 对象表示的字段的名称</span><br><span class="line">getDeclaringClass() 返回表示类或接口的 Class 对象，该类或接口声明由此 Field 对象表示的字段</span><br><span class="line">setAccessible(boolean flag) 将此对象的 accessible 标志设置为指示的布尔值,即设置其可访问性</span><br></pre></td></tr></table></figure>

<p>Method类：提供关于类或接口上单独某个方法（以及如何访问该方法）的信息，所反映的方法可能是类方法或实例方法（包括抽象方法）</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">invoke(Object obj, Object... args) 对带有指定参数的指定对象调用由此 Method 对象表示的底层方法 </span><br><span class="line">getName() 以 String 形式返回此 Method 对象表示的方法名称，即返回方法的名称</span><br></pre></td></tr></table></figure>

<h3 id="SPI机制"><a href="#SPI机制" class="headerlink" title="SPI机制"></a>SPI机制</h3><p>SPI机制是一种基于接口的服务发现机制。它允许在应用程序中定义接口，然后允许第三方供应商为这些接口提供实现，并通过在类路径上的配置文件中声明服务提供者。这种机制可以实现模块化和可插拔的架构，使得应用程序能够在运行时动态地加载和使用不同的实现。</p>
<h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><p>Java容器里只能放对象，对于基本类型(int, long, float, double等)，需要将其包装成对象类型后(Integer, Long, Float, Double等)才能放到容器里。很多时候拆包装和解包装能够自动完成。这虽然会导致额外的性能和空间开销，但简化了设计和编程</p>
<p>容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对(两个对象)的映射表</p>
<p>TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)</p>
<p>HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</p>
<p>LinkedHashSet：具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序</p>
<p>ArrayList：基于动态数组实现，支持随机访问</p>
<p>Vector：和 ArrayList 类似，但它是线程安全的</p>
<p>LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列</p>
<p>PriorityQueue：基于堆结构实现，可以用它来实现优先队列</p>
<p>TreeMap：基于红黑树实现</p>
<p>HashMap：基于哈希表实现</p>
<p>HashTable：和 HashMap 类似，但它是线程安全的，是遗留类，不应该去使用它</p>
<p>LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用(LRU)顺序</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>数组：一种连续存储线性结构，元素类型相同，大小相等</p>
<p>链表：n个节点离散分配，彼此通过指针相连，每个节点只有一个前驱节点，每个节点只有一个后续节点，首节点没有前驱节点，尾节点没有后续节点</p>
<p>哈希表：根据关键码值(Key value)直接进行访问的数据结构</p>
<p>栈和队列：栈为先进后出，队列先进先出</p>
<p>树：<br>1.二叉搜索树BST：左子树上所有结点的值均小于它的根结点的值，右子树上所有结点的值均大于它的根结点的值，对于一个节点，其左、右子树也分别为二叉搜索树<br>2.平衡二叉树AVL：左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树<br>3.红黑树：一种自平衡二叉查找树<br>4.哈夫曼树：一种带权路径长度最短的二叉树<br>5.字典树：又称前缀树、单词查找树或键树</p>
<p>图：</p>
<p>遍历方式：<br>DFS 深度优先搜索<br>BFS 广度优先搜索</p>
<p>最小生成树：<br>kruskal算法 对边的权重排序，选边并判断环（并查集实现），直到选完n-1条边<br>prim算法 选择任意点出发，每次选择到达价值最小的点，直到全中所有点</p>
<p>最短路径：<br>dijkstra算法 单源最短路径 从起点出发BFS，遍历其邻接点，更新到邻接点的最短距离<br>floyd算法 多源最短路径 枚举中转点k，对于每一点对i，j，如果i到j的距离大于先从i到k，再从k到j，则更新i与j之间的最短距离</p>
<p>拓扑排序：不断选取入度为0的点，加入拓扑排序的列表中，并将与其邻接的点的入度减1，直到得到完整的拓扑排序结果</p>
<p>AOE：AOE网是一个带权的有向无环图，在AOE网中，具有最大路径长度的路径称为关键路径，关键路径表示完成工程的最短工期<br>关键路径：在AOE网中从源点到汇点路径最长的路径</p>
<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>插入排序</p>
<pre><code>直接插入排序：
    思想：把n个待排序的元素看成为一个有序表和一个无序表。开始时有序表中只包含1个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，将它插入到有序表中的适当位置，使之成为新的有序表，重复n-1次可完成排序过程
    时间复杂度：平均o(n^2) 最好o(n) 最坏o(n^2) 
    稳定
    
希尔排序：
    思想：实质上是一种分组插入方法。对于n个待排序的数列，取一个小于n的整数gap(gap被称为步长)将待排序元素分成若干个组子序列，所有距离为gap的倍数的记录放在同一个组中；然后，对各组内的元素进行直接插入排序。 这一趟排序完成之后，每一个组的元素都是有序的。然后减小gap的值，并重复执行上述的分组和排序。重复这样的操作，当gap=1时，整个数列就是有序的
    时间复杂度：与增量(即，步长gap)的选取有关。当增量为1时，希尔排序退化成了直接插入排序，此时的时间复杂度为O(n^2)
    不稳定
    
</code></pre>
<p>选择排序</p>
<pre><code>直接选择排序：
    思想：在未排序的区间中选取最小元素放在最前面，再从剩余未排序的元素中继续寻找，直到所有元素均排序完毕
    时间复杂度：平均o(n^2) 最好o(n^2) 最坏o(n^2) 
    不稳定
    
堆排序：
    思想：把所有元素放入小顶堆再取出
    时间复杂度：o(logn)
    不稳定
</code></pre>
<p>交换排序</p>
<pre><code>冒泡排序：
    思想：遍历数组时不断如果相邻的两个元素前者小于后者，则交换位置，第一轮遍历结束后，最大元素将位于数组末尾，不断遍历直到数组有序
    时间复杂度：平均o(n^2) 最好o(n) 最坏o(n^2) 
    稳定
    
快速排序：
    思想：选择一个基准数，通过一趟排序将要排序的数据分割成独立的两部分；其中一部分的所有数据都比另外一部分的所有数据都要小。然后，再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列
    时间复杂度：平均o(logn) 最好o(logn) 最坏o(n^2)
    不稳定
</code></pre>
<p>归并排序：<br>    思想：从上往下的归并是不断将区间划分为两个小区间，递归进行排序<br>    时间复杂度：O(n*lgn)<br>    稳定</p>
<p>桶排序：<br>    思想：将数组分到有限数量的桶子里，再通过从每个桶取出元素完成排序<br>    时间复杂度：取决与对各个桶之间数据进行排序的时间复杂度。桶划分得越小，桶中的数据越少，排序所用的时间也会越少<br>    稳定</p>
<p>基数排序：<br>    思想：将整数按位数切割成不同的数字，然后按每个位数分别比较。 具体做法是: 将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。<br>    时间复杂度：o(d(r+n)) 其中r为关键字的基数，d为长度，n为关键字的个数<br>    稳定</p>
<h3 id="常用类库"><a href="#常用类库" class="headerlink" title="常用类库"></a>常用类库</h3><p>Apache Common包：是对JDK的拓展，包含了很多开源的工具，用于解决平时编程经常会遇到的问题，减少重复劳动。官网网址:<a target="_blank" rel="noopener" href="http://commons.apache.org/">http://commons.apache.org</a><br>    BeanUtils：针对Bean的一个工具集，常用来copyProperties<br>    Codec：编码和解码组件，提供常用的编码和解码方法，如DES、SHA1、MD5、Base64、URL和Soundx等<br>    Collections：一个集合组件，扩展了Java标准Collections API，对常用的集合操作进行了很好的封装、抽象和补充，在保证性能的同时大大简化代码</p>
<p>Google Guava包：包含了若干被Google的 Java项目广泛依赖 的核心库，例如：集合 [collections] 、缓存 [caching] 、原生类型支持 [primitives support] 、并发库 [concurrency libraries] 、通用注解 [common annotations] 、字符串处理 [string processing] 、I&#x2F;O 等等。 所有这些工具每天都在被Google的工程师应用在产品服务中</p>
<p>Hutool包：一个小而全的Java工具类库，通过静态方法封装，降低相关API的学习成本，提高工作效率</p>
<p>日志库：<br>    日志门面：一种设计模式，用于在应用程序中实现日志记录的抽象层 如：common-logging、slf4j<br>    日志系统：实际用于记录和管理日志消息的软件组件或库 如：Log4j、Logback、Log4j2</p>
<p>JSON库：<br>    FastJson: 阿里巴巴开发的 JSON 库，性能优秀<br>    Jackson: 社区十分活跃且更新速度很快<br>    Gson: 谷歌开发的 JSON 库，功能十分全面</p>
<p>Lombok工具库：一款非常实用Java工具，可用来帮助开发人员消除Java的冗长代码，尤其是对于简单的Java对象</p>
<p>MapStruct工具库：主要用于解决对象之间的拷贝问题，比如PO&#x2F;DTO&#x2F;VO&#x2F;QueryParam之间的转换问题。区别于BeanUtils这种通过反射，它通过编译器编译生成常规方法，将可以很大程度上提升效率</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-python速成" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2023-06-27T07:52:00.000Z"><a href="/2023/06/27/python%E9%80%9F%E6%88%90/">2023-06-27</a></time>
      
      
  
    <h1 class="title"><a href="/2023/06/27/python%E9%80%9F%E6%88%90/">python速成</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h6 id="检查版本"><a href="#检查版本" class="headerlink" title="检查版本"></a>检查版本</h6><p>*在cmd中输入python并回车查看python版本</p>
<h6 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h6><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#定义字符串变量并输出</span><br><span class="line">message = &quot;Hello world!&quot;</span><br><span class="line">print(message)</span><br><span class="line"></span><br><span class="line">#变量的命名和使用</span><br><span class="line">#变量名只能包含字母、数字和下划线。变量名可以字母或下划线打头，但不能以数字打头</span><br><span class="line">#变量名不能包含空格，但可使用下划线来分隔其中的单词</span><br></pre></td></tr></table></figure>
<h6 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h6><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name=&quot;Li Hua&quot;</span><br><span class="line">print(name.title()) #将单词首字母转化为大写</span><br><span class="line">print(name.upper()) #将字符串改为全部大写</span><br><span class="line">print(name.lower()) #将字符串改为全部小写</span><br><span class="line">print(name.rstrip()) #去除字符串末尾空格，lstrip去除首部空格，strip去除首尾空格</span><br><span class="line">str(age) #将整数转化为字符串</span><br></pre></td></tr></table></figure>

<h6 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h6><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"># 定义一个列表</span><br><span class="line">arr = [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;]</span><br><span class="line"># 添加元素(到列表末尾)</span><br><span class="line">arr.append(&#x27;four&#x27;)</span><br><span class="line"># 插入元素</span><br><span class="line">arr.insert(0,&#x27;zero&#x27;)</span><br><span class="line"># 使用del删除指定下标元素</span><br><span class="line">del arr[0]</span><br><span class="line"># 使用pop()删除并获取末尾元素</span><br><span class="line">ele = arr.pop()</span><br><span class="line"># 使用pop()获取任何位置处的元素</span><br><span class="line">ele = arr.pop(0)</span><br><span class="line"># 根据值删除元素</span><br><span class="line">arr.remove(&#x27;zero&#x27;)</span><br><span class="line"># 列表可通过下标取值和赋值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># sort对列表永久性排序</span><br><span class="line">arr.sort() # 正序</span><br><span class="line">arr.sort(reverse=True) # 逆序</span><br><span class="line"></span><br><span class="line"># sorted对列表进行临时性排序</span><br><span class="line">print(arr.sorted())</span><br><span class="line"></span><br><span class="line"># 列表倒序</span><br><span class="line">arr.reverse()</span><br><span class="line"></span><br><span class="line"># 获取列表长度</span><br><span class="line">a = len(cars)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 遍历整个列表</span><br><span class="line">for ele in arr:</span><br><span class="line">    print(ele)</span><br><span class="line">    </span><br><span class="line"># 使用range()生成一系列数字 区间前闭后开</span><br><span class="line">for ele in range(1,5):</span><br><span class="line">    print(ele)</span><br><span class="line">    </span><br><span class="line"># 对数字列表执行简单的统计计算</span><br><span class="line">a = min(arr) # 取最小元素</span><br><span class="line">b = max(arr) # 取最大元素</span><br><span class="line">c = sum(arr) # 取数组元素和</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 列表切片 区间前闭后开 </span><br><span class="line">print(arr[0:3])</span><br><span class="line"># arr[2:] 终止于列表末尾</span><br><span class="line"># arr[-3:] 负数索引表示到末尾的距离，这里表示最后三个元素</span><br><span class="line"># arr[:3] 起始于列表头部</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 复制列表</span><br><span class="line">arr2 = arr[:]</span><br><span class="line"># arr2 = arr的方式两个变量指向同一个列表，不能得到两个列表</span><br></pre></td></tr></table></figure>

<h6 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h6><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">元组看起来犹如列表，但使用圆括号而不是方括号来标识。</span><br><span class="line">定义元组后，就可以使用索引来访问其元素，就像访问列表元素一样。</span><br><span class="line">arr = (200, 50)</span><br><span class="line">print(arr[1]) </span><br><span class="line">元组中的元素不能被重新赋值 如arr[0] = 250 报错</span><br></pre></td></tr></table></figure>

<h6 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h6><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 简单if语句</span><br><span class="line">car = &#x27;奔驰&#x27;</span><br><span class="line">if car == &#x27;奔驰&#x27;:</span><br><span class="line">    print(&#x27;cool&#x27;)</span><br><span class="line">else:</span><br><span class="line">    print(&#x27;rubbish&#x27;)</span><br><span class="line"></span><br><span class="line"># 多个条件判断</span><br><span class="line">age &gt;= 20 and age &lt;= 35</span><br><span class="line">age &lt; 14 or age &gt;70</span><br><span class="line"></span><br><span class="line"># 多个if语句 </span><br><span class="line">car = &#x27;奔驰&#x27;</span><br><span class="line">if car == &#x27;劳斯莱斯&#x27;:</span><br><span class="line">    print(&#x27;cool&#x27;)</span><br><span class="line">elif car == &#x27;奔驰&#x27;:</span><br><span class="line">    print(&#x27;very cool&#x27;)</span><br><span class="line">else:</span><br><span class="line">    print(&#x27;rubbish&#x27;);</span><br><span class="line"># 多个elif的后面可以没有else    </span><br></pre></td></tr></table></figure>

<h6 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h6><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 字典是一系列键值对,每个键都与一个值相关联,下面语句定义了一个字典：</span><br><span class="line">alien = &#123;&#x27;color&#x27;: &#x27;green&#x27;, &#x27;points&#x27;: 5&#125;</span><br><span class="line"></span><br><span class="line"># 访问字典中的值</span><br><span class="line">print(alien[&#x27;color&#x27;])</span><br><span class="line"></span><br><span class="line"># 添加键值对/修改键值对</span><br><span class="line">alien[&#x27;x_position&#x27;]=25</span><br><span class="line"></span><br><span class="line"># 创建一个空字典</span><br><span class="line">alien_1 = &#123;&#125;</span><br><span class="line"></span><br><span class="line"># 删除键值对</span><br><span class="line">del alien[&#x27;color&#x27;]</span><br><span class="line"></span><br><span class="line"># 遍历字典,items()返回一个键值对列表,使用keys()可遍历所有键,使用values()遍历所有值</span><br><span class="line">for key,value in alien.items():</span><br><span class="line">    print(key + &quot;:&quot; + value)</span><br><span class="line"></span><br><span class="line"># 按顺序遍历字典中所有键</span><br><span class="line">for name in sorted(alien.keys()):</span><br><span class="line">    print(str(name))</span><br></pre></td></tr></table></figure>

<h6 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入"></a>用户输入</h6><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input() 让程序暂停运行，等待用户输入一些文本。获取用户输入后，Python将其存储在一个变量中</span><br><span class="line">int() 获取数值输入</span><br></pre></td></tr></table></figure>

<h6 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h6><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">break 退出循环</span><br><span class="line">continue 继续新的一轮循环</span><br><span class="line"></span><br><span class="line"># 使用while循环弹出列表所有元素</span><br><span class="line">while arr:</span><br><span class="line">    ele = arr.pop()</span><br><span class="line">    print(ele)</span><br></pre></td></tr></table></figure>

<h6 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h6><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 定义简单函数，传入形参username</span><br><span class="line">def greet_user(username):</span><br><span class="line">    print(&quot;Hello!&quot;+username)</span><br><span class="line"># 调用函数</span><br><span class="line">greet_user(&#x27;jack&#x27;)</span><br><span class="line"></span><br><span class="line"># 给形参指定默认值</span><br><span class="line">def describe(animal=&#x27;dog&#x27;):</span><br><span class="line">    print(animal)</span><br><span class="line">describe()</span><br><span class="line"></span><br><span class="line"># 返回值</span><br><span class="line">def add(a,b)</span><br><span class="line">    return a+b</span><br><span class="line">result=add(15,30)</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line"># 可向函数传递列表的副本而不是原件；这样函数所做的任何修改都只影响副本，而丝毫不影响原件</span><br><span class="line">def function(list):</span><br><span class="line">    print(list)</span><br><span class="line"></span><br><span class="line">list=[10,10,10]</span><br><span class="line">function(list[:])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 传递任意数量的实参</span><br><span class="line">def make(*toppings):</span><br><span class="line">    print(toppings)</span><br><span class="line">make(&#x27;aaa&#x27;,&#x27;bbb&#x27;,&#x27;ccc&#x27;,&#x27;ddd&#x27;)</span><br></pre></td></tr></table></figure>

<h6 id="类"><a href="#类" class="headerlink" title="类"></a>类</h6><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Dog():</span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line">    def sit(self):</span><br><span class="line">        print(self.name+&quot; is now sitting.&quot;)</span><br><span class="line"></span><br><span class="line">my_dog=Dog(&#x27;willie&#x27;,6)</span><br><span class="line"></span><br><span class="line">Dog.sit(my_dog)</span><br></pre></td></tr></table></figure>



      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
  
    <a href="/page/2/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  

  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/java/">java</a><small>1</small></li>
  
    <li><a href="/tags/%E7%AE%97%E6%B3%95/">算法</a><small>2</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2023 comin-lin
  
</div>
<div class="clearfix"></div></footer>
  
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/jquery.imagesloaded.min.js"></script>


<script src="/js/gallery.js"></script>





</body>
</html>
