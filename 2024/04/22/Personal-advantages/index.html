

  <!DOCTYPE html>
  <html lang="zh-CN">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="renderer" content="webkit">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta name="description" content= >
  <meta name="keywords" content=hexo,theme,MiHoYo >

  <head>
    <title>
      Personal advantages [ comin-lin&#39;s blog ]
    </title>
  <meta name="generator" content="Hexo 6.3.0"></head>

  <body>

    <link rel="stylesheet" href="/css/header.css">
<div class="header">
  <div class="logo">
    <span class="pull-left">
      <a id="site-name" href="/">
        comin-lin&#39;s blog
      </a>
    </span>
  </div>
  <ul class="nav-list">
    
      <li>
        <a href="/">
          首页
        </a>
      </li>
      
  </ul>
</div>

      <!--<link rel="stylesheet" href="/css/top-header.css">
<div id="top-bar" class="fixed">

  <a class="goto-top" href="#"></a>
  <ul class="bar-list bar-list-1">
    
      <li>
        <p>
          <a href="/">
            <text class="bar-text bar-p1">
              首页
            </text>
            <text class="bar-text bar-p2"></text>
          </a>
          <text class="bar-p3">/</text>
        </p>
      </li>
      
  </ul>
</div>-->

        <div id="content-outer">
          <div class="content-inner">
            <link rel="stylesheet" href="/css/post.css">
<div class="posts">
  <a href="/index.html"><i class="fa fa-home
replay-btn" aria-hidden="true"></i></a>
  <div class="post-title">
    <p>
      Personal advantages
    </p>
    <hr>
  </div>
  <div class="post-content">
    <h1 id="Personal-advantages"><a href="#Personal-advantages" class="headerlink" title="Personal advantages"></a>Personal advantages</h1><p>掌握<a href="#java-base">JavaSE基础知识</a>，如<a href="#collection">集合</a>、<a href="#exception">异常</a>、<a href="#IO">IO</a>、<a href="#reflect">反射</a>、多线程，具有良好的编码习惯，熟悉常用的数据结构和算法</p>
<p>熟练使用Spring、SpringMVC、SpringBoot、Mybatis、Mybatis-plus、Spring Cloud Alibaba等主流<a href="#spring">框架</a></p>
<p>熟练使用<a href="#mysql">MySQL</a>数据库，了解InnoDB、索引、SQL优化、事务、锁机制、MVCC、分库分表、慢查询日志、三大日志、集群等</p>
<p>熟悉<a href="#redis">Redis</a>数据库，了解核心数据类型和使用场景、持久化、数据淘汰策略、分布式锁、集群，了解缓存穿透、击穿、雪崩</p>
<p>熟悉<a href="#network">计算机网络相关知识</a>，如OSI七层模型，TCP&#x2F;IP四层模型、HTTP&#x2F;HTTPS等协议</p>
<p>熟悉<a href="#juc">并发编程</a>，了解synchronized、volatile、CAS、AQS、线程池、ThreadLocal</p>
<p>了解消息中间件<a href="#rabbitmq">RabbitMQ</a>，了解延迟队列、消息可靠性原理、高可用机制</p>
<p>了解<a href="#jvm">JVM</a>、JMM，如内存结构、双亲委派机制、垃圾回收算法和垃圾回收器、类加载过程和类加载器</p>
<p>了解<a href="#nginx">Nginx</a>的使用，如反向代理、负载均衡、动静分离、限流、缓存</p>
<p>了解<a href="#linux">linux</a>，<a href="#docker">docker</a>常用命令，了解<a href="#es">elasticsearch</a>基本使用</p>
<p>了解常见的<a href="#principle">软件设计原则</a>和<a href="#mode">设计模式</a>，了解<a href="#mongodb">mongodb</a>和<a href="#k8s">k8s</a>集群部署</p>
<h6 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h6><ul>
<li>javaguide：<a target="_blank" rel="noopener" href="https://javaguide.cn/">https://javaguide.cn/</a></li>
<li>通义千问：<a target="_blank" rel="noopener" href="https://tongyi.aliyun.com/qianwen/">https://tongyi.aliyun.com/qianwen/</a></li>
</ul>
<h1 id="java基础知识"><a href="#java基础知识" class="headerlink" title="java基础知识"></a><p id="java-base">java基础知识</p></h1><p>java语言特点：</p>
<ul>
<li>面向对象（封装，继承，多态）</li>
<li>平台无关性（ Java 虚拟机实现平台无关性）</li>
<li>支持多线程</li>
<li>可靠性（具备异常处理和自动内存管理机制）</li>
<li>安全性（Java 语言本身的设计就提供了多重安全防护机制如访问权限修饰符、限制程序直接访问操作系统资源）</li>
</ul>
<p>javaSE：Java 平台标准版（Java Platform，Standard Edition）<br>javaEE：Java 平台企业版（Java Platform, Enterprise Edition ）</p>
<p>JDK：Java 开发环境（包含JRE）<br>JRE：Java 运行时环境</p>
<p>Java和C++的区别：<br>Java 不提供指针来直接访问内存<br>Java 的类是单继承的，C++ 支持多重继承<br>Java 有自动内存管理垃圾回收机制(GC)</p>
<p>基本类型：<br>名称 字节<br>byte 1<br>short 2<br>int 4<br>long 8<br>float 4<br>double 8<br>char 2<br>boolean 1</p>
<p>基本类型存放位置：局部变量存放在栈中，成员变量存放在堆中</p>
<p>包装类型的缓存机制：</p>
<ul>
<li>Byte,Short,Integer,Long默认创建了数值 [-128，127] 的相应类型的缓存数据</li>
<li>Character 创建了数值在 [0,127] 范围的缓存数据</li>
<li>Boolean 直接返回 True or False</li>
</ul>
<p>封装：把数据和对数据的操作封装在一个类中，对外提供公共方法，隐藏内部实现细节<br>继承：子类继承父类，得到父类的方法和变量<br>编译时多态：指方法重载<br>运行时多态：父类引用指向子类对象</p>
<p>抽象类：不能实例化，可以有抽象方法和具体方法</p>
<p>接口：不能实例化，Java 8及更高版本 可以用 default 关键字在接口中定义默认方法</p>
<p>&#x3D;&#x3D; 比较的是值或地址，equals比较内容判断对象是否相同</p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a><p id="collection">集合</p></h3><p>集合两大接口：</p>
<ol>
<li>Collection接口，主要用于存放单一元素</li>
<li>Map 接口，主要用于存放键值对</li>
</ol>
<p>Comparable 和 Comparator 的区别：</p>
<ol>
<li>都是 Java 中用于排序的接口</li>
<li>Comparable 接口使用compareTo(Object obj)方法来排序</li>
<li>Comparator 接口使用compare(Object obj1, Object obj2)方法来排序</li>
</ol>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a><p id="exception">异常</p></h3><p>所有的异常共同的祖先：java.lang 包中的 Throwable 类</p>
<p>Throwable 类有两个重要的子类：</p>
<ol>
<li>Exception：程序本身可以处理的异常，可以通过 catch 来进行捕获。Exception 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)</li>
<li>Error：属于程序无法处理的错误</li>
</ol>
<p>受检查异常：Java 代码在编译过程中，如果受检查异常没有被 catch或者throws 关键字处理的话，就没办法通过编译<br>除了 RuntimeException 及其子类以外，其他的Exception类及其子类都属于受检查异常</p>
<h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a><p id="IO">IO</p></h3><p>IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流<br>IO涉及的设计模式：装饰器模式 适配器模式 工厂模式 观察者模式</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a><p id="reflect">反射</p></h3><p>反射：获取任意一个类的所有属性和方法，可以调用这些方法和属性<br>优点：代码更加灵活、为各种框架提供开箱即用的功能提供了便利<br>缺点：增加了安全问题</p>
<h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a><p id="spring">框架</p></h3><p>IOC是什么？<br>IOC（控制反转），把对象的创建和管理交给Spring容器</p>
<p>IOC的优势？<br>降低耦合性：对象不再直接依赖其他对象，而是依赖于抽象（接口或抽象类）。容器负责将具体的依赖对象注入到需要它们的地方，从而降低了对象之间的耦合度。<br>易于配置和管理：依赖关系集中由容器管理，可以通过配置文件或注解灵活地配置和更改依赖关系，无需修改代码。</p>
<p>IOC的原理？<br>ApplicationContext作为IOC容器<br>通过XML配置文件、Java配置类或注解完成Bean定义<br>Spring提供了多种依赖注入方式，如构造函数注入、setter注入和字段注入</p>
<p>AOP相关概念？<br>切面（Aspect）：包含跨越多个对象的横切关注点的模块化代码。它定义了要添加到系统的交叉功能<br>通知（Advice）：切面的具体实现，描述了在何时何地执行切面逻辑。常见的通知类型包括前置通知（before advice）、后置通知（after advice）、环绕通知（around advice）、异常抛出通知（throwing advice）和最终通知（after returning advice）<br>连接点（Join Point）：程序执行过程中可能插入切面的一个点，如方法调用、异常抛出等<br>切入点（Pointcut）：一组匹配连接点的表达式，定义了切面将在哪些特定的连接点上执行</p>
<p>AOP作用？<br>日志记录：前置通知和后置通知记录日志<br>事务管理：环绕通知在方法执行前后开启、提交或回滚事务</p>
<p>Spring AOP与AspectJ的区别？<br>Spring AOP基于代理，仅支持方法级别的切面<br>AspectJ是一种编译器插件，支持更全面的切点表达式和更丰富的通知类型，性能通常优于Spring AOP</p>
<p>Bean的生命周期：<br>Bean的定义与配置：<br>Bean元信息配置阶段：通过XML配置文件、Java配置类、注解等方式定义Bean的基本信息，包括Bean的类型、作用域、初始化方法、销毁方法、依赖关系等。<br>Bean元信息解析阶段：Spring容器加载配置信息，解析这些元信息，创建BeanDefinition对象，它包含了创建和管理Bean所需的所有必要数据。</p>
<p>Bean的注册与载入：<br>将Bean注册到容器中：Spring容器根据配置信息将BeanDefinition注册到内部的数据结构（如BeanDefinitionRegistry）中。<br>BeanDefinition合并阶段：如果有多个来源的配置信息定义了同一个Bean，Spring会合并这些定义，确定最终的配置。<br>Bean Class加载阶段：在需要创建Bean实例时，Spring会确保其对应类已经被类加载器加载到JVM中。</p>
<p>Bean的实例化：<br>Bean实例化阶段：Spring容器通过反射或其他用户指定的方式（如FactoryBean或Supplier）创建Bean的实例。实例化前，可能会先执行InstantiationAwareBeanPostProcessor的预实例化回调。</p>
<p>依赖注入：<br>属性填充阶段：Spring容器解析Bean的依赖关系，查找并注入其他Bean或外部资源（如@Autowired、@Value注解所标注的依赖）。这个阶段可能会触发BeanPostProcessor的postProcessProperties方法。</p>
<p>初始化：<br>初始化阶段：实例化和依赖注入完成后，Spring会执行Bean的初始化工作：<br>调用实现了InitializingBean接口的Bean的afterPropertiesSet方法。<br>如果在配置中指定了init-method属性，调用该方法进行初始化。<br>调用@PostConstruct注解标记的方法。</p>
<p>使用：<br>Bean的使用阶段：此时Bean已经完全准备就绪，可以被应用程序通过ApplicationContext或BeanFactory获取并使用。在应用程序运行期间，Bean持续提供其服务。</p>
<p>销毁：<br>销毁阶段：当Spring容器关闭或Bean的作用域结束时，Spring会执行Bean的清理工作：<br>调用实现了DisposableBean接口的Bean的destroy方法。<br>如果在配置中指定了destroy-method属性，调用该方法进行销毁。<br>调用@PreDestroy注解标记的方法。</p>
<p>循环依赖：<br>两个或者两个以上的bean互相持有对方，最终形成闭环。<br>解决：Spring三级缓存</p>
<h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a><p id="mysql">mysql</p></h3><p>InnoDB引擎的特点及其应用场景</p>
<p>特点：</p>
<ol>
<li>支持事务：InnoDB遵循事务的ACID（原子性、一致性、隔离性、持久性），确保在并发环境下的数据完整性</li>
<li>行级锁定：InnoDB提供了行级锁定机制，能够在高并发场景下显著减少锁冲突，提高并发性能。相较于全表锁定或页级锁定，行级锁定能够使得多个事务同时对同一表的不同行进行操作，而不必相互等待</li>
<li>外键支持：InnoDB允许定义外键约束，确保数据间的参照完整性</li>
<li>崩溃恢复能力：InnoDB使用redo日志（重做日志）和undo日志（回滚日志）来实现崩溃恢复</li>
<li>缓冲池：InnoDB使用缓冲池来缓存数据和索引，减少对磁盘I&#x2F;O的需求，加速数据访问。</li>
</ol>
<p>应用场景：</p>
<ol>
<li>需要支持事务处理</li>
<li>高并发读写场景</li>
<li>需要外键约束</li>
<li>数据完整性要求高</li>
</ol>
<p>解释InnoDB的MVCC（多版本并发控制）机制，并描述其如何实现读写并发</p>
<p>MVCC允许多个事务在同一时刻看到数据的不同版本，从而避免了读写冲突，提高了并发性能</p>
<p>在MVCC中，每个事务都有自己的视图（read view），这个视图决定了事务能看到哪些数据版本。具体实现原理包括：</p>
<ol>
<li>隐藏列：InnoDB为每行数据添加了两个隐藏列（事务ID和回滚指针），分别记录了最后修改该行的事务ID和指向该行旧版本的指针。</li>
<li>事务ID：每个事务都有一个唯一的事务ID（transaction ID），新插入或修改数据时，会将当前事务ID写入隐藏列。</li>
<li>Read View：当事务开始读取数据时，会生成一个Read View，记录当前系统中活跃事务（未提交事务）的最小和最大事务ID，以及当前系统版本号（system version number）。</li>
</ol>
<p>数据版本可见性判断：</p>
<ol>
<li>对于未提交事务（未分配事务ID）修改的数据，任何事务都无法看到其更改，因为这些更改尚未提交到数据库。</li>
<li>对于已提交事务（分配了事务ID）修改的数据，根据其事务ID与Read View的关系判断是否可见：<br>若事务ID小于Read View的最小事务ID，表示该事务在当前事务启动前已提交，其修改的数据对当前事务可见。<br>若事务ID大于等于Read View的最大事务ID，表示该事务在当前事务启动后才开始，其修改的数据对当前事务不可见。<br>若事务ID在Read View的最小和最大事务ID之间，需要进一步判断该事务是否已提交。已提交则可见，否则不可见。</li>
</ol>
<p>通过MVCC，InnoDB能够在不阻塞读操作的情况下进行写操作，实现读写并发。读事务看到的是历史版本的数据，而写事务可以修改当前数据版本，互不影响。</p>
<p>MySQL中的锁类型及其适用场景</p>
<p>MySQL中的锁类型主要包括全局锁、表级锁、行级锁以及元数据锁</p>
<ol>
<li>全局锁：对整个数据库实例加锁，通常使用FLUSH TABLES WITH READ LOCK命令获得。适用于全库逻辑备份场景，确保备份期间无数据更新，保证数据一致性。全局锁会导致所有写操作阻塞，因此在生产环境中应谨慎使用，并尽量在低峰时段执行</li>
<li>表级锁：</li>
</ol>
<ul>
<li>表锁：直接锁定整张表，常用于MyISAM存储引擎。表锁粒度较大，锁定期间其他事务无法对该表进行任何操作，可能导致并发性能下降。适用于以读为主、写操作较少且对数据一致性要求较高的场景。</li>
<li>元数据锁（MDL）：在对表进行DML（如INSERT、UPDATE、DELETE）或DDL（如ALTER TABLE、DROP TABLE）操作时，MySQL会自动加MDL。读操作仅加读锁，允许并发；写操作加写锁，会阻塞其他读写操作。MDL用于防止在操作表结构时与其他事务发生冲突，确保元数据的一致性。</li>
</ul>
<ol start="3">
<li>行级锁：锁定作用于单行数据，常见于InnoDB存储引擎。行级锁可以最大程度地支持并发访问，减小锁争用，适用于高并发且需要细粒度锁定的场景。根据锁定模式，行级锁又可分为共享锁（S锁，用于读操作）、排他锁（X锁，用于写操作）以及意向锁（用于表明即将对表或行加锁的意图，分为意向共享锁和意向排他锁）。</li>
</ol>
<p>MySQL中如何检测和处理死锁</p>
<ol>
<li>检测：MySQL通过内部的死锁检测机制定期检查是否存在循环等待锁的情况。当检测到死锁时，会选择牺牲其中一个事务以打破死锁循环。</li>
<li>处理：</li>
</ol>
<ul>
<li>自动处理：MySQL默认配置下会自动检测并回滚死锁链条中的某一个事务，释放其持有的锁，使其他事务得以继续执行</li>
<li>手动处理：用户可以设置innodb_deadlock_detect参数为OFF来关闭自动死锁检测，改为在事务超时后（由innodb_lock_wait_timeout参数设定）强制回滚等待最久的事务。</li>
</ul>
<p>MySQL中InnoDB引擎的行锁升级过程，并说明何时会发生这种情况</p>
<p>行锁升级指的是原本持有的行锁扩大到更高级别的锁（如从行锁升级到表锁），以适应更严格的并发控制需求</p>
<p>行锁升级通常发生在以下情况下：</p>
<p>间隙锁（Next-Key Locks）：InnoDB在可重复读（Repeatable Read）隔离级别下，不仅对索引记录加行锁，还会对索引记录之间的间隙加锁，以防止“幻读”。当一个事务需要锁定一个范围内的记录时，可能会触发间隙锁，实际上相当于行锁的隐式升级。</p>
<p>锁升级到表锁：</p>
<p>锁升级阈值：InnoDB在短时间内对同一表的多个不同行加锁时，如果达到内部设定的锁升级阈值，可能会将行锁升级为表锁，以减少系统开销。这通常发生在并发插入大量新行或更新大量不同行时。<br>FOR UPDATE&#x2F;FOR SHARE：在某些情况下，使用带有FOR UPDATE或FOR SHARE子句的查询可能会导致锁升级。例如，全表扫描时使用这些子句可能导致InnoDB将行锁升级为表锁，以简化锁的管理。<br>行锁升级虽然能在某些场景下简化锁管理或防止幻读，但也可能导致并发性能下降。因此，开发人员应合理设计查询和事务，尽量避免不必要的行锁升级，特别是在高并发环境中。</p>

  </div>
  
</div>
          </div>
        </div>

        <link rel="stylesheet" href="/css/footer.css">
<div class="bottom-outer">
  <div class="framework-info">
  </div>
</div>

          
            <!-- scripts list from theme config.yml -->
            
              <script src="/js/MiHoYo.js"></script>
              
                

  </body>

  </html>